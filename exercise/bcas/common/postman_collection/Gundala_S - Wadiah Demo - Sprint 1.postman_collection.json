{
	"info": {
		"_postman_id": "d5647b05-6e74-4ad9-813d-7c12fe171796",
		"name": "Gundala_S - Wadiah Demo - Sprint 1",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "13722108"
	},
	"item": [
		{
			"name": "Simulation",
			"item": [
				{
					"name": "Bonus Distribution Using Base Rate",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"Main account\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{access_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-01T00:00:00+00:00\",\n    \"end_timestamp\": \"2022-03-02T00:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.6\\\"\\ndisplay_name = \\\"Tahapan Wadiah iB\\\"\\nsummary = \\\"A type of account that could be used by a customer to hold \\\"\\n\\\"everyday savings. It allows customer to hold money within the account \\\"\\n\\\"and perform transactional activities such as deposits and withdrawals. \\\"\\ntside = Tside.LIABILITY\\n\\n# Time zone offset constants\\nUTC_HOUR_FOR_LOCAL_MIDNIGHT = 0\\nWIB_UTC_OFFSET = 0\\n\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\n# Global parameters\\nglobal_parameters = [\\\"tax_rate\\\", \\\"zakat_rate\\\"]\\n\\nevent_types = [\\n    EventType(\\n        name=\\\"APPLY_MONTHLY_FEES\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_APPLY_MONTHLY_FEES_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=\\\"BONUS_DISTRIBUTION\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_BONUS_DISTRIBUTION_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n]\\n\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nINTERNAL_POSTING = \\\"INTERNAL_POSTING\\\"\\n\\n# Instruction Detail keys\\nDORMANCY_FLAG = \\\"&{ACCOUNT_DORMANT}\\\"\\nWAIVE_TAX_FLAG = \\\"&{ACCOUNT_WAIVE_TAX}\\\"\\nWAIVE_ZAKAT_FLAG = \\\"&{ACCOUNT_WAIVE_ZAKAT}\\\"\\n\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nInterestRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\n\\nparameters = [\\n    # Instance parameters\\n    Parameter(\\n        name=\\\"bonus_distribution\\\",\\n        shape=UnionShape(\\n            UnionItem(key=\\\"true\\\", display_name=\\\"True\\\"),\\n            UnionItem(key=\\\"false\\\", display_name=\\\"False\\\"),\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"Defines whether this account get bonus distribution monthly\\\",\\n        display_name=\\\"Bonus distribution\\\",\\n        update_permission=UpdatePermission.FIXED,\\n        default_value=UnionItemValue(key=\\\"false\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_special_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus special rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used instead of base rate if set. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus special rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_spread_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus spread rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used along with the base or special rate. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus Spread rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    # Template parameters\\n    Parameter(\\n        name=\\\"denomination\\\",\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The currency in which the product operates.\\\",\\n        display_name=\\\"Denomination\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=\\\"bonus_base_rate\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Bonus Distributions rates applicable.\\\"\\n        \\\"This is the bonus base rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus base rate (p.a.)\\\",\\n        shape=InterestRateShape,\\n        default_value=Decimal(\\\"0.2\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_day\\\",\\n        shape=NumberShape(min_value=1, max_value=28, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The day of the month on which bonus is distributed.\\\"\\n        \\\" The day can be within 1 and 28, inclusive of both\\\",\\n        display_name=\\\"Bonus application day\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_monthly\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged for account maintenance.\\\",\\n        display_name=\\\"Monthly maintenance fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"minimum_balance\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The minimum amount that will be held in the account and cannot be used for\\\"\\n        \\\" transactions. It can be used for paying fees though.\\\",\\n        display_name=\\\"Minimum balance\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"25000\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"account_inactivity_fee\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged while the account is inactive. While inactive this fee\\\"\\n        \\\" replaces other minimum balance and periodic maintenance fees.\\\",\\n        display_name=\\\"Account inactivity fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which fees are applied.\\\",\\n        display_name=\\\"Fees application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which fees are applied.\\\",\\n        display_name=\\\"Fees application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which fees are applied.\\\",\\n        display_name=\\\"Fees application second\\\",\\n        default_value=0,\\n    ),\\n    # internal accounts\\n    Parameter(\\n        name=\\\"bonus_payable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for bonus payable balance.\\\",\\n        display_name=\\\"Bonus Payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"BONUS_PAYABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"tax_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for tax receivable balance.\\\",\\n        display_name=\\\"Tax Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"TAX_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"zakat_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for zakat receivable balance.\\\",\\n        display_name=\\\"Zakat Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"ZAKAT_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for maintenance fee income balance.\\\",\\n        display_name=\\\"Maintenance fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"MAINTENANCE_FEE_INCOME\\\",\\n    ),\\n    Parameter(\\n        name=\\\"inactivity_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for account inactivity fee income balance.\\\",\\n        display_name=\\\"Account inactivity fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"INACTIVITY_FEE_INCOME\\\",\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"get_transaction_type\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    ),\\n]\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n    account_creation_date = vault.get_account_creation_date()\\n    schedule_list = []\\n    bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault,\\n        \\\"bonus_distribution\\\",\\n        at=account_creation_date,\\n        union=True,\\n        is_boolean=True,\\n    )\\n    if bonus_distribution:\\n        bonus_distribution_schedule = _create_bonus_distribution_schedule(vault)\\n        bonus_distribution_schedule_dict = (\\\"BONUS_DISTRIBUTION\\\", bonus_distribution_schedule)\\n        schedule_list.append(bonus_distribution_schedule_dict)\\n\\n    # Every month anniversary from account opening at time set by template parameters\\n    apply_monthly_fees_schedule = _get_next_fee_schedule(\\n        vault, account_creation_date, timedelta(months=1)\\n    )\\n    apply_monthly_fees_schedule_dict = (\\\"APPLY_MONTHLY_FEES\\\", apply_monthly_fees_schedule)\\n    schedule_list.append(apply_monthly_fees_schedule_dict)\\n    return schedule_list\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"APPLY_MONTHLY_FEES\\\",\\n    flags=True,\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"BONUS_DISTRIBUTION\\\",\\n    parameters=True,\\n    balances=\\\"32 days live\\\",\\n    flags=True,\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    account_creation_date = vault.get_account_creation_date()\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == \\\"BONUS_DISTRIBUTION\\\":\\n        # Check if bonus distribution is enabled\\n        bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault,\\n            \\\"bonus_distribution\\\",\\n            at=account_creation_date,\\n            union=True,\\n            is_boolean=True,\\n        )\\n        if bonus_distribution:\\n            posting_instructions.extend(_handle_bonus_distribution(vault, effective_date))\\n\\n    elif event_type == \\\"APPLY_MONTHLY_FEES\\\":\\n        posting_instructions.extend(_apply_monthly_fees(vault, effective_date))\\n        new_schedule = _get_next_fee_schedule(vault, effective_date, timedelta(months=1))\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n    if new_schedule:\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    flags=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef pre_posting_code(incoming_posting_batch: PostingInstructionBatch, effective_date: datetime):\\n\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    if is_account_dormant is True:\\n        raise Rejected(\\n            'Account flagged \\\"Dormant\\\" does not accept external transactions.',\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n\\n    _check_posting_denomination(incoming_posting_batch, denomination)\\n\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    available_balance = _get_outgoing_available_balance(balances, denomination)\\n\\n    withdrawal_balance_delta = _get_outgoing_available_balance(\\n        incoming_posting_batch.balances(), denomination\\n    )\\n\\n    _check_balance_limits(\\n        vault,\\n        denomination,\\n        withdrawal_balance_delta,\\n        available_balance,\\n    )\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if \\\"bonus_distribution\\\" in parameters:\\n        raise Rejected(\\n            f\\\"Cannot update the bonus distribution after account creation\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n# Helpers\\ndef _check_balance_limits(\\n    vault,\\n    denomination: str,\\n    withdrawal_balance_delta: Decimal,\\n    available_balance: Decimal,\\n) -> None:\\n    minimum_balance = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"minimum_balance\\\")\\n    available_balance_without_minimum_balance = available_balance - minimum_balance\\n\\n    if (\\n        0 > withdrawal_balance_delta\\n        and 0 > withdrawal_balance_delta + available_balance_without_minimum_balance\\n    ):\\n        raise Rejected(\\n            f\\\"Postings total {denomination} {withdrawal_balance_delta}, which exceeds the\\\"\\n            f\\\" available balance of {denomination} {available_balance_without_minimum_balance}.\\\",\\n            reason_code=RejectedReason.INSUFFICIENT_FUNDS,\\n        )\\n\\n\\ndef _apply_monthly_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Applies maintenance fees to the account. By design these are not accrued\\n    daily on a pro-rata basis but applied when due monthly. When the account is\\n    closed they are not prorated.\\n\\n    :param vault: Vault object\\n    :param effective_date: date and time of hook being run\\n\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    maintenance_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"maintenance_fee_income_account\\\"\\n    )\\n    inactivity_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"inactivity_fee_income_account\\\"\\n    )\\n    monthly_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"maintenance_fee_monthly\\\")\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    account_inactivity_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"account_inactivity_fee\\\")\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    posting_instructions = []\\n\\n    # Post monthly maintenance fee if set for this account\\n    if not is_account_dormant and monthly_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=maintenance_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_MAINTENANCE\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Monthly maintenance fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    # Post inactivity fee if set for this account and account is dormant\\n    if is_account_dormant and account_inactivity_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=account_inactivity_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=inactivity_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_INACTIVITY\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Account inactivity fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _handle_bonus_distribution(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Handles the bonus distribution, tax and zakat application\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n    # Apply bonus\\n    bonus_posting_intructions, bonus_calculated = _distribute_bonus(\\n        vault, effective_date=effective_date\\n    )\\n    posting_ins.extend(bonus_posting_intructions)\\n\\n    # Apply tax\\n    tax_posting_intructions, tax_amount = _apply_tax(vault, bonus_calculated=bonus_calculated)\\n    posting_ins.extend(tax_posting_intructions)\\n\\n    # Apply zakat\\n    zakat_posting_intructions = _apply_zakat(\\n        vault, bonus_calculated=bonus_calculated, tax_calculated=tax_amount\\n    )\\n    posting_ins.extend(zakat_posting_intructions)\\n\\n    return posting_ins\\n\\n\\ndef _distribute_bonus(vault, effective_date: datetime) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the bonus to be distributed to the account\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions and the bonus calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    bonus_payable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_payable_account\\\")\\n\\n    monthly_bonus_base_rate = _get_monthly_bonus_rate(vault)\\n    if monthly_bonus_base_rate == 0:\\n        return posting_ins, Decimal(0)\\n\\n    eod_midnight_cut_off_time = _determine_midnight_cutoff_datetime(effective_date)\\n    monthly_mean_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n        _monthly_mean_balance(\\n            vault, denomination=denomination, effective_date=eod_midnight_cut_off_time\\n        ),\\n        2,\\n    )\\n    if monthly_mean_balance == 0:\\n        return posting_ins, Decimal(0)\\n\\n    bonus_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        monthly_bonus_base_rate * monthly_mean_balance, 2\\n    )\\n\\n    if bonus_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=bonus_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"BONUS_DISTRIBUTION_{vault.get_hook_execution_id()}\\\",\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=bonus_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Bonus distributed at monthly rate of \\\"\\n                    f\\\"{(monthly_bonus_base_rate * 100):0.4f}% on monthly average balance of \\\"\\n                    f\\\"{denomination}{monthly_mean_balance}\\\",\\n                    \\\"event\\\": \\\"BONUS_DISTRIBUTION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, bonus_calculated\\n\\n\\ndef _apply_tax(vault, bonus_calculated: Decimal) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the tax on the bonus calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :return: posting instructions and the tax calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    tax_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"tax_receivable_account\\\")\\n    tax_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"tax_rate\\\"))\\n    is_tax_waived = vault.get_flag_timeseries(flag=WAIVE_TAX_FLAG).latest()\\n\\n    if tax_rate == 0 or is_tax_waived is True or bonus_calculated == 0:\\n        return posting_ins, Decimal(0)\\n\\n    tax_calculated = vault.modules[\\\"utils\\\"].round_decimal(bonus_calculated * tax_rate, 2)\\n\\n    if tax_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tax_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"TAX_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=tax_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Tax applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated}\\\",\\n                    \\\"event\\\": \\\"TAX_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, tax_calculated\\n\\n\\ndef _apply_zakat(\\n    vault, bonus_calculated: Decimal, tax_calculated: Decimal\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculates the zakat on the bonus and tax calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :param tax_calculated: Tax calculated\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    zakat_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"zakat_receivable_account\\\"\\n    )\\n    zakat_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"zakat_rate\\\"))\\n    is_zakat_waived = vault.get_flag_timeseries(flag=WAIVE_ZAKAT_FLAG).latest()\\n\\n    if zakat_rate == 0 or is_zakat_waived is True:\\n        return posting_ins\\n\\n    zakat_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        (bonus_calculated - tax_calculated) * zakat_rate, 2\\n    )\\n\\n    if zakat_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=zakat_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"ZAKAT_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=zakat_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Zakat applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated} and tax {tax_calculated}\\\",\\n                    \\\"event\\\": \\\"ZAKAT_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins\\n\\n\\ndef _instruct_posting_batch(\\n    vault,\\n    instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\ndef _monthly_mean_balance(vault, denomination: str, effective_date: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Determine whether the average balance for the preceding month fell below the account threshold\\n    The sampling time is the same time as the fee application time\\n    The sampling period is from one month ago until yesterday, inclusive\\n    i.e. not including today/now. If the sampling time is before the account\\n    was opened then skip that day.\\n\\n    :param vault: Vault object\\n    :param denomination: Account denomination\\n    :param effective_date: date and time of hook being run\\n    :return: mean balance at sampling time for previous month\\n    \\\"\\\"\\\"\\n    creation_date = vault.get_account_creation_date()\\n    period_start = effective_date - timedelta(months=1)\\n    if period_start < creation_date:\\n        period_start = creation_date\\n    num_days = (effective_date - period_start).days\\n    # Move the period start to 23:59:59.9999 of the same day\\n    period_start = period_start + timedelta(days=1, microseconds=-1)\\n    if num_days == 0:\\n        return Decimal(0)\\n    total = sum(\\n        [\\n            vault.get_balance_timeseries()\\n            .at(timestamp=period_start + timedelta(days=i))[\\n                (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n            ]\\n            .net\\n            for i in range(num_days)\\n        ]\\n    )\\n    mean_balance = total / num_days\\n    return mean_balance\\n\\n\\ndef _get_outgoing_available_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)].net\\n    )\\n\\n\\ndef _get_incoming_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_IN)].net\\n    )\\n\\n\\ndef _create_bonus_distribution_schedule(\\n    vault,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next bonus application day\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :return: dict, representation of BONUS_DISTRIBUTION schedule\\n    \\\"\\\"\\\"\\n\\n    bonus_distribution_day = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_day\\\")\\n    bonus_distribution_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_hour\\\")\\n    bonus_distribution_minute = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_minute\\\"\\n    )\\n    bonus_distribution_second = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_second\\\"\\n    )\\n\\n    bonus_distribution_schedule = {\\n        \\\"day\\\": str(bonus_distribution_day),\\n        \\\"hour\\\": str(bonus_distribution_hour),\\n        \\\"minute\\\": str(bonus_distribution_minute),\\n        \\\"second\\\": str(bonus_distribution_second),\\n    }\\n\\n    return bonus_distribution_schedule\\n\\n\\ndef _get_monthly_bonus_rate(vault):\\n    bonus_base_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"bonus_base_rate\\\"))\\n    bonus_special_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_special_rate\\\", optional=True\\n    )\\n    bonus_spread_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_spread_rate\\\", optional=True\\n    )\\n\\n    bonus_spread_rate = Decimal(bonus_spread_rate) if bonus_spread_rate else Decimal(0)\\n\\n    final_bonus_rate = Decimal(0)\\n    if bonus_special_rate:\\n        final_bonus_rate = (bonus_special_rate + bonus_spread_rate) / 12\\n    else:\\n        final_bonus_rate = (bonus_base_rate + bonus_spread_rate) / 12\\n\\n    return final_bonus_rate\\n\\n\\ndef _get_next_fee_schedule(vault, start_date: datetime, offset: timedelta) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for next run time of APPLY_???_FEES, taking the hh:mm:ss\\n    from contract parameters and the period from the \\\"offset\\\" parameter.\\n\\n    :param vault: Vault object\\n    :param start_date: datetime, date from which to calculate next event datetime\\n    :param offset: timedelta, offset to add to start_date\\n    :return: dict, representation of schedule\\n    \\\"\\\"\\\"\\n\\n    fees_application_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_hour\\\")\\n    fees_application_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_minute\\\")\\n    fees_application_second = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_second\\\")\\n\\n    next_schedule_date = start_date + offset\\n\\n    next_schedule_date = next_schedule_date.replace(\\n        hour=fees_application_hour,\\n        minute=fees_application_minute,\\n        second=fees_application_second,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_schedule_date)\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _create_schedule_dict_from_params(\\n    year: Optional[int] = None,\\n    month: Optional[int] = None,\\n    day: Optional[int] = None,\\n    hour: Optional[int] = None,\\n    minute: Optional[int] = None,\\n    second: Optional[int] = None,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n\\n    :param year: int, year for schedule to run\\n    :param month: int, month for schedule to run\\n    :param day: int, day of month for schedule to run\\n    :param hour: int, hour of day for schedule to run\\n    :param minute: int, minute of hour for schedule to run\\n    :param second: int, second of minute for schedule to run\\n    :return: dict, representation of schedule from function input\\n    \\\"\\\"\\\"\\n    schedule_dict = {}\\n    if year is not None:\\n        schedule_dict[\\\"year\\\"] = str(year)\\n    if month is not None:\\n        schedule_dict[\\\"month\\\"] = str(month)\\n    if day is not None:\\n        schedule_dict[\\\"day\\\"] = str(day)\\n    if hour is not None:\\n        schedule_dict[\\\"hour\\\"] = str(hour)\\n    if minute is not None:\\n        schedule_dict[\\\"minute\\\"] = str(minute)\\n    if second is not None:\\n        schedule_dict[\\\"second\\\"] = str(second)\\n    return schedule_dict\\n\\n\\ndef _check_posting_denomination(postings: List[PostingInstruction], accepted_denomination: str):\\n    for posting in postings:\\n        if posting.denomination != accepted_denomination:\\n            raise Rejected(\\n                f\\\"Postings received in unauthorised denomination {posting.denomination}.\\\"\\n                f\\\" Authorised denomination is {accepted_denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n\\n\\ndef _determine_midnight_cutoff_datetime(scheduled_datetime: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Determines the midnight datetime in local time\\n    Bonus distribution, monthly mean balance should always use the effective balance from\\n    00:00:00 WIB on the current day (17:00:00 UTC)\\n    :param scheduled_datetime: UTC schedule datetime\\n    :return: datetime, UTC local-midnight cut-off\\n    \\\"\\\"\\\"\\n    # Calculate the cutoff for 17:00:00 UTC\\n    local_balance_cutoff_ts = scheduled_datetime + timedelta(\\n        hour=UTC_HOUR_FOR_LOCAL_MIDNIGHT, minute=0, second=0, microsecond=0\\n    )\\n\\n    return local_balance_cutoff_ts\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"bonus_distribution_hour\": \"0\",\n                \"bonus_distribution_minute\": \"1\",\n                \"bonus_distribution_second\": \"0\",\n                \"bonus_payable_account\": \"BONUS_PAYABLE\",\n                \"maintenance_fee_income_account\": \"MAINTENANCE_FEE_INCOME\",\n                \"inactivity_fee_income_account\": \"INACTIVITY_FEE_INCOME\",\n                \"tax_receivable_account\": \"TAX_RECEIVABLE\",\n                \"zakat_receivable_account\": \"ZAKAT_RECEIVABLE\",\n                \"maintenance_fee_monthly\": \"0\",\n                \"minimum_balance\": \"25000\",\n                \"account_inactivity_fee\": \"0\",\n                \"fees_application_hour\": \"0\",\n                \"fees_application_minute\": \"1\",\n                \"fees_application_second\": \"0\",\n                \"bonus_base_rate\": \"0.01\",\n                \"bonus_distribution_day\": \"1\"\n            },\n            \"smart_contract_version_id\": \"1000\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"5197736121490366464\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7145871606771306598\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8904078363962271283\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6632383930890487524\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7884032891663598059\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8844474970154615954\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"BONUS_PAYABLE\",\n                \"product_version_id\": \"5197736121490366464\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MAINTENANCE_FEE_INCOME\",\n                \"product_version_id\": \"7145871606771306598\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"INACTIVITY_FEE_INCOME\",\n                \"product_version_id\": \"8904078363962271283\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAX_RECEIVABLE\",\n                \"product_version_id\": \"6632383930890487524\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"ZAKAT_RECEIVABLE\",\n                \"product_version_id\": \"7884032891663598059\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"1\",\n                \"product_version_id\": \"8844474970154615954\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_1000\",\n                \"smart_contract_version_id\": \"1000\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"tax_rate\",\n                    \"display_name\": \"Tax Rate\",\n                    \"description\": \"Tax Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"zakat_rate\",\n                    \"display_name\": \"Zakat Rate\",\n                    \"description\": \"Zakat Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-15T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"Main account\",\n                \"product_version_id\": \"1000\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"bonus_distribution\": \"true\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-15T01:00:00+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"c56b82ee-772a-4f4d-8ce9-b33ee3f0bc14\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"5056f2fc-247a-4fee-b297-721900dc9203\",\n                        \"instruction_details\": {},\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"5000000\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"Main account\"\n                            },\n                            \"internal_account_id\": \"1\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"event\": \"DEPOSIT_1\"\n                },\n                \"value_timestamp\": \"2022-01-15T01:00:00+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-16T01:00:00+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"c56b82ee-772a-4f4d-8ce9-b33ee3f0bc24\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"5056f2fc-247a-4fee-b297-7219002c9203\",\n                        \"instruction_details\": {},\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"500000\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"Main account\"\n                            },\n                            \"internal_account_id\": \"1\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"event\": \"DEPOSIT_2\"\n                },\n                \"value_timestamp\": \"2022-01-16T01:00:00+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-17T01:00:00+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"c56b82ee-772a-4f4d-8ce9-b3eee3f0bc24\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"5056f2fc-247a-4fee-b295-7219002c9203\",\n                        \"instruction_details\": {},\n                        \"override\": {},\n                        \"outbound_hard_settlement\": {\n                            \"amount\": \"750000\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"Main account\"\n                            },\n                            \"internal_account_id\": \"1\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"event\": \"OUTBOUND_RTOL\"\n                },\n                \"value_timestamp\": \"2022-01-17T01:00:00+00:00\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				},
				{
					"name": "Bonus Distribution Using Base Rate - No change",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"Main account\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{access_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-01T00:00:00+00:00\",\n    \"end_timestamp\": \"2022-03-02T00:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.6\\\"\\ndisplay_name = \\\"Tahapan Wadiah iB\\\"\\nsummary = \\\"A type of account that could be used by a customer to hold \\\"\\n\\\"everyday savings. It allows customer to hold money within the account \\\"\\n\\\"and perform transactional activities such as deposits and withdrawals. \\\"\\ntside = Tside.LIABILITY\\n\\n# Time zone offset constants\\nUTC_HOUR_FOR_LOCAL_MIDNIGHT = 0\\nWIB_UTC_OFFSET = 0\\n\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\n# Global parameters\\nglobal_parameters = [\\\"tax_rate\\\", \\\"zakat_rate\\\"]\\n\\nevent_types = [\\n    EventType(\\n        name=\\\"APPLY_MONTHLY_FEES\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_APPLY_MONTHLY_FEES_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=\\\"BONUS_DISTRIBUTION\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_BONUS_DISTRIBUTION_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n]\\n\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nINTERNAL_POSTING = \\\"INTERNAL_POSTING\\\"\\n\\n# Instruction Detail keys\\nDORMANCY_FLAG = \\\"&{ACCOUNT_DORMANT}\\\"\\nWAIVE_TAX_FLAG = \\\"&{ACCOUNT_WAIVE_TAX}\\\"\\nWAIVE_ZAKAT_FLAG = \\\"&{ACCOUNT_WAIVE_ZAKAT}\\\"\\n\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nInterestRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\n\\nparameters = [\\n    # Instance parameters\\n    Parameter(\\n        name=\\\"bonus_distribution\\\",\\n        shape=UnionShape(\\n            UnionItem(key=\\\"true\\\", display_name=\\\"True\\\"),\\n            UnionItem(key=\\\"false\\\", display_name=\\\"False\\\"),\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"Defines whether this account get bonus distribution monthly\\\",\\n        display_name=\\\"Bonus distribution\\\",\\n        update_permission=UpdatePermission.FIXED,\\n        default_value=UnionItemValue(key=\\\"false\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_special_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus special rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used instead of base rate if set. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus special rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_spread_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus spread rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used along with the base or special rate. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus Spread rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    # Template parameters\\n    Parameter(\\n        name=\\\"denomination\\\",\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The currency in which the product operates.\\\",\\n        display_name=\\\"Denomination\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=\\\"bonus_base_rate\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Bonus Distributions rates applicable.\\\"\\n        \\\"This is the bonus base rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus base rate (p.a.)\\\",\\n        shape=InterestRateShape,\\n        default_value=Decimal(\\\"0.2\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_day\\\",\\n        shape=NumberShape(min_value=1, max_value=28, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The day of the month on which bonus is distributed.\\\"\\n        \\\" The day can be within 1 and 28, inclusive of both\\\",\\n        display_name=\\\"Bonus application day\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_monthly\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged for account maintenance.\\\",\\n        display_name=\\\"Monthly maintenance fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"minimum_balance\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The minimum amount that will be held in the account and cannot be used for\\\"\\n        \\\" transactions. It can be used for paying fees though.\\\",\\n        display_name=\\\"Minimum balance\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"25000\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"account_inactivity_fee\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged while the account is inactive. While inactive this fee\\\"\\n        \\\" replaces other minimum balance and periodic maintenance fees.\\\",\\n        display_name=\\\"Account inactivity fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which fees are applied.\\\",\\n        display_name=\\\"Fees application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which fees are applied.\\\",\\n        display_name=\\\"Fees application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which fees are applied.\\\",\\n        display_name=\\\"Fees application second\\\",\\n        default_value=0,\\n    ),\\n    # internal accounts\\n    Parameter(\\n        name=\\\"bonus_payable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for bonus payable balance.\\\",\\n        display_name=\\\"Bonus Payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"BONUS_PAYABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"tax_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for tax receivable balance.\\\",\\n        display_name=\\\"Tax Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"TAX_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"zakat_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for zakat receivable balance.\\\",\\n        display_name=\\\"Zakat Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"ZAKAT_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for maintenance fee income balance.\\\",\\n        display_name=\\\"Maintenance fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"MAINTENANCE_FEE_INCOME\\\",\\n    ),\\n    Parameter(\\n        name=\\\"inactivity_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for account inactivity fee income balance.\\\",\\n        display_name=\\\"Account inactivity fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"INACTIVITY_FEE_INCOME\\\",\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"get_transaction_type\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    ),\\n]\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n    account_creation_date = vault.get_account_creation_date()\\n    schedule_list = []\\n    bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault,\\n        \\\"bonus_distribution\\\",\\n        at=account_creation_date,\\n        union=True,\\n        is_boolean=True,\\n    )\\n    if bonus_distribution:\\n        bonus_distribution_schedule = _create_bonus_distribution_schedule(vault)\\n        bonus_distribution_schedule_dict = (\\\"BONUS_DISTRIBUTION\\\", bonus_distribution_schedule)\\n        schedule_list.append(bonus_distribution_schedule_dict)\\n\\n    # Every month anniversary from account opening at time set by template parameters\\n    apply_monthly_fees_schedule = _get_next_fee_schedule(\\n        vault, account_creation_date, timedelta(months=1)\\n    )\\n    apply_monthly_fees_schedule_dict = (\\\"APPLY_MONTHLY_FEES\\\", apply_monthly_fees_schedule)\\n    schedule_list.append(apply_monthly_fees_schedule_dict)\\n    return schedule_list\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"APPLY_MONTHLY_FEES\\\",\\n    flags=True,\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"BONUS_DISTRIBUTION\\\",\\n    parameters=True,\\n    balances=\\\"32 days live\\\",\\n    flags=True,\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    account_creation_date = vault.get_account_creation_date()\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == \\\"BONUS_DISTRIBUTION\\\":\\n        # Check if bonus distribution is enabled\\n        bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault,\\n            \\\"bonus_distribution\\\",\\n            at=account_creation_date,\\n            union=True,\\n            is_boolean=True,\\n        )\\n        if bonus_distribution:\\n            posting_instructions.extend(_handle_bonus_distribution(vault, effective_date))\\n\\n    elif event_type == \\\"APPLY_MONTHLY_FEES\\\":\\n        posting_instructions.extend(_apply_monthly_fees(vault, effective_date))\\n        new_schedule = _get_next_fee_schedule(vault, effective_date, timedelta(months=1))\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n    if new_schedule:\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    flags=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef pre_posting_code(incoming_posting_batch: PostingInstructionBatch, effective_date: datetime):\\n\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    if is_account_dormant is True:\\n        raise Rejected(\\n            'Account flagged \\\"Dormant\\\" does not accept external transactions.',\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n\\n    _check_posting_denomination(incoming_posting_batch, denomination)\\n\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    available_balance = _get_outgoing_available_balance(balances, denomination)\\n\\n    withdrawal_balance_delta = _get_outgoing_available_balance(\\n        incoming_posting_batch.balances(), denomination\\n    )\\n\\n    _check_balance_limits(\\n        vault,\\n        denomination,\\n        withdrawal_balance_delta,\\n        available_balance,\\n    )\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if \\\"bonus_distribution\\\" in parameters:\\n        raise Rejected(\\n            f\\\"Cannot update the bonus distribution after account creation\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n# Helpers\\ndef _check_balance_limits(\\n    vault,\\n    denomination: str,\\n    withdrawal_balance_delta: Decimal,\\n    available_balance: Decimal,\\n) -> None:\\n    minimum_balance = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"minimum_balance\\\")\\n    available_balance_without_minimum_balance = available_balance - minimum_balance\\n\\n    if (\\n        0 > withdrawal_balance_delta\\n        and 0 > withdrawal_balance_delta + available_balance_without_minimum_balance\\n    ):\\n        raise Rejected(\\n            f\\\"Postings total {denomination} {withdrawal_balance_delta}, which exceeds the\\\"\\n            f\\\" available balance of {denomination} {available_balance_without_minimum_balance}.\\\",\\n            reason_code=RejectedReason.INSUFFICIENT_FUNDS,\\n        )\\n\\n\\ndef _apply_monthly_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Applies maintenance fees to the account. By design these are not accrued\\n    daily on a pro-rata basis but applied when due monthly. When the account is\\n    closed they are not prorated.\\n\\n    :param vault: Vault object\\n    :param effective_date: date and time of hook being run\\n\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    maintenance_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"maintenance_fee_income_account\\\"\\n    )\\n    inactivity_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"inactivity_fee_income_account\\\"\\n    )\\n    monthly_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"maintenance_fee_monthly\\\")\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    account_inactivity_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"account_inactivity_fee\\\")\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    posting_instructions = []\\n\\n    # Post monthly maintenance fee if set for this account\\n    if not is_account_dormant and monthly_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=maintenance_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_MAINTENANCE\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Monthly maintenance fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    # Post inactivity fee if set for this account and account is dormant\\n    if is_account_dormant and account_inactivity_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=account_inactivity_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=inactivity_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_INACTIVITY\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Account inactivity fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _handle_bonus_distribution(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Handles the bonus distribution, tax and zakat application\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n    # Apply bonus\\n    bonus_posting_intructions, bonus_calculated = _distribute_bonus(\\n        vault, effective_date=effective_date\\n    )\\n    posting_ins.extend(bonus_posting_intructions)\\n\\n    # Apply tax\\n    tax_posting_intructions, tax_amount = _apply_tax(vault, bonus_calculated=bonus_calculated)\\n    posting_ins.extend(tax_posting_intructions)\\n\\n    # Apply zakat\\n    zakat_posting_intructions = _apply_zakat(\\n        vault, bonus_calculated=bonus_calculated, tax_calculated=tax_amount\\n    )\\n    posting_ins.extend(zakat_posting_intructions)\\n\\n    return posting_ins\\n\\n\\ndef _distribute_bonus(vault, effective_date: datetime) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the bonus to be distributed to the account\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions and the bonus calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    bonus_payable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_payable_account\\\")\\n\\n    monthly_bonus_base_rate = _get_monthly_bonus_rate(vault)\\n    if monthly_bonus_base_rate == 0:\\n        return posting_ins, Decimal(0)\\n\\n    eod_midnight_cut_off_time = _determine_midnight_cutoff_datetime(effective_date)\\n    monthly_mean_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n        _monthly_mean_balance(\\n            vault, denomination=denomination, effective_date=eod_midnight_cut_off_time\\n        ),\\n        2,\\n    )\\n    if monthly_mean_balance == 0:\\n        return posting_ins, Decimal(0)\\n\\n    bonus_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        monthly_bonus_base_rate * monthly_mean_balance, 2\\n    )\\n\\n    if bonus_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=bonus_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"BONUS_DISTRIBUTION_{vault.get_hook_execution_id()}\\\",\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=bonus_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Bonus distributed at monthly rate of \\\"\\n                    f\\\"{(monthly_bonus_base_rate * 100):0.4f}% on monthly average balance of \\\"\\n                    f\\\"{denomination}{monthly_mean_balance}\\\",\\n                    \\\"event\\\": \\\"BONUS_DISTRIBUTION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, bonus_calculated\\n\\n\\ndef _apply_tax(vault, bonus_calculated: Decimal) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the tax on the bonus calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :return: posting instructions and the tax calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    tax_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"tax_receivable_account\\\")\\n    tax_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"tax_rate\\\"))\\n    is_tax_waived = vault.get_flag_timeseries(flag=WAIVE_TAX_FLAG).latest()\\n\\n    if tax_rate == 0 or is_tax_waived is True or bonus_calculated == 0:\\n        return posting_ins, Decimal(0)\\n\\n    tax_calculated = vault.modules[\\\"utils\\\"].round_decimal(bonus_calculated * tax_rate, 2)\\n\\n    if tax_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tax_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"TAX_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=tax_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Tax applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated}\\\",\\n                    \\\"event\\\": \\\"TAX_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, tax_calculated\\n\\n\\ndef _apply_zakat(\\n    vault, bonus_calculated: Decimal, tax_calculated: Decimal\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculates the zakat on the bonus and tax calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :param tax_calculated: Tax calculated\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    zakat_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"zakat_receivable_account\\\"\\n    )\\n    zakat_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"zakat_rate\\\"))\\n    is_zakat_waived = vault.get_flag_timeseries(flag=WAIVE_ZAKAT_FLAG).latest()\\n\\n    if zakat_rate == 0 or is_zakat_waived is True:\\n        return posting_ins\\n\\n    zakat_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        (bonus_calculated - tax_calculated) * zakat_rate, 2\\n    )\\n\\n    if zakat_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=zakat_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"ZAKAT_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=zakat_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Zakat applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated} and tax {tax_calculated}\\\",\\n                    \\\"event\\\": \\\"ZAKAT_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins\\n\\n\\ndef _instruct_posting_batch(\\n    vault,\\n    instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\ndef _monthly_mean_balance(vault, denomination: str, effective_date: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Determine whether the average balance for the preceding month fell below the account threshold\\n    The sampling time is the same time as the fee application time\\n    The sampling period is from one month ago until yesterday, inclusive\\n    i.e. not including today/now. If the sampling time is before the account\\n    was opened then skip that day.\\n\\n    :param vault: Vault object\\n    :param denomination: Account denomination\\n    :param effective_date: date and time of hook being run\\n    :return: mean balance at sampling time for previous month\\n    \\\"\\\"\\\"\\n    creation_date = vault.get_account_creation_date()\\n    period_start = effective_date - timedelta(months=1)\\n    if period_start < creation_date:\\n        period_start = creation_date\\n    num_days = (effective_date - period_start).days\\n    # Move the period start to 23:59:59.9999 of the same day\\n    period_start = period_start + timedelta(days=1, microseconds=-1)\\n    if num_days == 0:\\n        return Decimal(0)\\n    total = sum(\\n        [\\n            vault.get_balance_timeseries()\\n            .at(timestamp=period_start + timedelta(days=i))[\\n                (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n            ]\\n            .net\\n            for i in range(num_days)\\n        ]\\n    )\\n    mean_balance = total / num_days\\n    return mean_balance\\n\\n\\ndef _get_outgoing_available_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)].net\\n    )\\n\\n\\ndef _get_incoming_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_IN)].net\\n    )\\n\\n\\ndef _create_bonus_distribution_schedule(\\n    vault,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next bonus application day\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :return: dict, representation of BONUS_DISTRIBUTION schedule\\n    \\\"\\\"\\\"\\n\\n    bonus_distribution_day = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_day\\\")\\n    bonus_distribution_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_hour\\\")\\n    bonus_distribution_minute = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_minute\\\"\\n    )\\n    bonus_distribution_second = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_second\\\"\\n    )\\n\\n    bonus_distribution_schedule = {\\n        \\\"day\\\": str(bonus_distribution_day),\\n        \\\"hour\\\": str(bonus_distribution_hour),\\n        \\\"minute\\\": str(bonus_distribution_minute),\\n        \\\"second\\\": str(bonus_distribution_second),\\n    }\\n\\n    return bonus_distribution_schedule\\n\\n\\ndef _get_monthly_bonus_rate(vault):\\n    bonus_base_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"bonus_base_rate\\\"))\\n    bonus_special_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_special_rate\\\", optional=True\\n    )\\n    bonus_spread_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_spread_rate\\\", optional=True\\n    )\\n\\n    bonus_spread_rate = Decimal(bonus_spread_rate) if bonus_spread_rate else Decimal(0)\\n\\n    final_bonus_rate = Decimal(0)\\n    if bonus_special_rate:\\n        final_bonus_rate = (bonus_special_rate + bonus_spread_rate) / 12\\n    else:\\n        final_bonus_rate = (bonus_base_rate + bonus_spread_rate) / 12\\n\\n    return final_bonus_rate\\n\\n\\ndef _get_next_fee_schedule(vault, start_date: datetime, offset: timedelta) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for next run time of APPLY_???_FEES, taking the hh:mm:ss\\n    from contract parameters and the period from the \\\"offset\\\" parameter.\\n\\n    :param vault: Vault object\\n    :param start_date: datetime, date from which to calculate next event datetime\\n    :param offset: timedelta, offset to add to start_date\\n    :return: dict, representation of schedule\\n    \\\"\\\"\\\"\\n\\n    fees_application_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_hour\\\")\\n    fees_application_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_minute\\\")\\n    fees_application_second = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_second\\\")\\n\\n    next_schedule_date = start_date + offset\\n\\n    next_schedule_date = next_schedule_date.replace(\\n        hour=fees_application_hour,\\n        minute=fees_application_minute,\\n        second=fees_application_second,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_schedule_date)\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _create_schedule_dict_from_params(\\n    year: Optional[int] = None,\\n    month: Optional[int] = None,\\n    day: Optional[int] = None,\\n    hour: Optional[int] = None,\\n    minute: Optional[int] = None,\\n    second: Optional[int] = None,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n\\n    :param year: int, year for schedule to run\\n    :param month: int, month for schedule to run\\n    :param day: int, day of month for schedule to run\\n    :param hour: int, hour of day for schedule to run\\n    :param minute: int, minute of hour for schedule to run\\n    :param second: int, second of minute for schedule to run\\n    :return: dict, representation of schedule from function input\\n    \\\"\\\"\\\"\\n    schedule_dict = {}\\n    if year is not None:\\n        schedule_dict[\\\"year\\\"] = str(year)\\n    if month is not None:\\n        schedule_dict[\\\"month\\\"] = str(month)\\n    if day is not None:\\n        schedule_dict[\\\"day\\\"] = str(day)\\n    if hour is not None:\\n        schedule_dict[\\\"hour\\\"] = str(hour)\\n    if minute is not None:\\n        schedule_dict[\\\"minute\\\"] = str(minute)\\n    if second is not None:\\n        schedule_dict[\\\"second\\\"] = str(second)\\n    return schedule_dict\\n\\n\\ndef _check_posting_denomination(postings: List[PostingInstruction], accepted_denomination: str):\\n    for posting in postings:\\n        if posting.denomination != accepted_denomination:\\n            raise Rejected(\\n                f\\\"Postings received in unauthorised denomination {posting.denomination}.\\\"\\n                f\\\" Authorised denomination is {accepted_denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n\\n\\ndef _determine_midnight_cutoff_datetime(scheduled_datetime: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Determines the midnight datetime in local time\\n    Bonus distribution, monthly mean balance should always use the effective balance from\\n    00:00:00 WIB on the current day (17:00:00 UTC)\\n    :param scheduled_datetime: UTC schedule datetime\\n    :return: datetime, UTC local-midnight cut-off\\n    \\\"\\\"\\\"\\n    # Calculate the cutoff for 17:00:00 UTC\\n    local_balance_cutoff_ts = scheduled_datetime + timedelta(\\n        hour=UTC_HOUR_FOR_LOCAL_MIDNIGHT, minute=0, second=0, microsecond=0\\n    )\\n\\n    return local_balance_cutoff_ts\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"bonus_distribution_hour\": \"0\",\n                \"bonus_distribution_minute\": \"1\",\n                \"bonus_distribution_second\": \"0\",\n                \"bonus_payable_account\": \"BONUS_PAYABLE\",\n                \"maintenance_fee_income_account\": \"MAINTENANCE_FEE_INCOME\",\n                \"inactivity_fee_income_account\": \"INACTIVITY_FEE_INCOME\",\n                \"tax_receivable_account\": \"TAX_RECEIVABLE\",\n                \"zakat_receivable_account\": \"ZAKAT_RECEIVABLE\",\n                \"maintenance_fee_monthly\": \"0\",\n                \"minimum_balance\": \"25000\",\n                \"account_inactivity_fee\": \"0\",\n                \"fees_application_hour\": \"0\",\n                \"fees_application_minute\": \"1\",\n                \"fees_application_second\": \"0\",\n                \"bonus_base_rate\": \"0.01\",\n                \"bonus_distribution_day\": \"1\"\n            },\n            \"smart_contract_version_id\": \"1000\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"5197736121490366464\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7145871606771306598\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8904078363962271283\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6632383930890487524\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7884032891663598059\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8844474970154615954\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"BONUS_PAYABLE\",\n                \"product_version_id\": \"5197736121490366464\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MAINTENANCE_FEE_INCOME\",\n                \"product_version_id\": \"7145871606771306598\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"INACTIVITY_FEE_INCOME\",\n                \"product_version_id\": \"8904078363962271283\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAX_RECEIVABLE\",\n                \"product_version_id\": \"6632383930890487524\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"ZAKAT_RECEIVABLE\",\n                \"product_version_id\": \"7884032891663598059\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"1\",\n                \"product_version_id\": \"8844474970154615954\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_1000\",\n                \"smart_contract_version_id\": \"1000\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"tax_rate\",\n                    \"display_name\": \"Tax Rate\",\n                    \"description\": \"Tax Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"zakat_rate\",\n                    \"display_name\": \"Zakat Rate\",\n                    \"description\": \"Zakat Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-15T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"Main account\",\n                \"product_version_id\": \"1000\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"bonus_distribution\": \"true\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-15T01:00:00+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"c56b82ee-772a-4f4d-8ce9-b33ee3f0bc14\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"5056f2fc-247a-4fee-b297-721900dc9203\",\n                        \"instruction_details\": {},\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"5000000\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"Main account\"\n                            },\n                            \"internal_account_id\": \"1\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"event\": \"DEPOSIT_1\"\n                },\n                \"value_timestamp\": \"2022-01-15T01:00:00+00:00\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				},
				{
					"name": "Bonus Distribution Using Base Rate - No change 1st Jan",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"Main account\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{access_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-01T00:00:00+00:00\",\n    \"end_timestamp\": \"2022-03-02T00:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.6\\\"\\ndisplay_name = \\\"Tahapan Wadiah iB\\\"\\nsummary = \\\"A type of account that could be used by a customer to hold \\\"\\n\\\"everyday savings. It allows customer to hold money within the account \\\"\\n\\\"and perform transactional activities such as deposits and withdrawals. \\\"\\ntside = Tside.LIABILITY\\n\\n# Time zone offset constants\\nUTC_HOUR_FOR_LOCAL_MIDNIGHT = 0\\nWIB_UTC_OFFSET = 0\\n\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\n# Global parameters\\nglobal_parameters = [\\\"tax_rate\\\", \\\"zakat_rate\\\"]\\n\\nevent_types = [\\n    EventType(\\n        name=\\\"APPLY_MONTHLY_FEES\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_APPLY_MONTHLY_FEES_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=\\\"BONUS_DISTRIBUTION\\\",\\n        scheduler_tag_ids=[\\\"WADIAH_BONUS_DISTRIBUTION_AST\\\", \\\"WADIAH_TC_AST\\\"],\\n    ),\\n]\\n\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nINTERNAL_POSTING = \\\"INTERNAL_POSTING\\\"\\n\\n# Instruction Detail keys\\nDORMANCY_FLAG = \\\"&{ACCOUNT_DORMANT}\\\"\\nWAIVE_TAX_FLAG = \\\"&{ACCOUNT_WAIVE_TAX}\\\"\\nWAIVE_ZAKAT_FLAG = \\\"&{ACCOUNT_WAIVE_ZAKAT}\\\"\\n\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nInterestRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\n\\nparameters = [\\n    # Instance parameters\\n    Parameter(\\n        name=\\\"bonus_distribution\\\",\\n        shape=UnionShape(\\n            UnionItem(key=\\\"true\\\", display_name=\\\"True\\\"),\\n            UnionItem(key=\\\"false\\\", display_name=\\\"False\\\"),\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"Defines whether this account get bonus distribution monthly\\\",\\n        display_name=\\\"Bonus distribution\\\",\\n        update_permission=UpdatePermission.FIXED,\\n        default_value=UnionItemValue(key=\\\"false\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_special_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus special rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used instead of base rate if set. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus special rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_spread_rate\\\",\\n        level=Level.INSTANCE,\\n        description=\\\"This is the bonus spread rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is used along with the base or special rate. \\\"\\n        \\\"This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus Spread rate (p.a.)\\\",\\n        shape=OptionalShape(InterestRateShape),\\n        update_permission=UpdatePermission.OPS_EDITABLE,\\n        default_value=OptionalValue(Decimal(\\\"0\\\")),\\n    ),\\n    # Template parameters\\n    Parameter(\\n        name=\\\"denomination\\\",\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The currency in which the product operates.\\\",\\n        display_name=\\\"Denomination\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=\\\"bonus_base_rate\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Bonus Distributions rates applicable.\\\"\\n        \\\"This is the bonus base rate (per annum) used to calculate bonus on \\\"\\n        \\\"customers deposits. This is distributed according to the schedule.\\\",\\n        display_name=\\\"Bonus base rate (p.a.)\\\",\\n        shape=InterestRateShape,\\n        default_value=Decimal(\\\"0.2\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_day\\\",\\n        shape=NumberShape(min_value=1, max_value=28, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The day of the month on which bonus is distributed.\\\"\\n        \\\" The day can be within 1 and 28, inclusive of both\\\",\\n        display_name=\\\"Bonus application day\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"bonus_distribution_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which bonus is distributed.\\\",\\n        display_name=\\\"Bonus application second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_monthly\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged for account maintenance.\\\",\\n        display_name=\\\"Monthly maintenance fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"minimum_balance\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The minimum amount that will be held in the account and cannot be used for\\\"\\n        \\\" transactions. It can be used for paying fees though.\\\",\\n        display_name=\\\"Minimum balance\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"25000\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"account_inactivity_fee\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"The monthly fee charged while the account is inactive. While inactive this fee\\\"\\n        \\\" replaces other minimum balance and periodic maintenance fees.\\\",\\n        display_name=\\\"Account inactivity fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"0.00\\\"),\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_hour\\\",\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which fees are applied.\\\",\\n        display_name=\\\"Fees application hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_minute\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the hour at which fees are applied.\\\",\\n        display_name=\\\"Fees application minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=\\\"fees_application_second\\\",\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the minute at which fees are applied.\\\",\\n        display_name=\\\"Fees application second\\\",\\n        default_value=0,\\n    ),\\n    # internal accounts\\n    Parameter(\\n        name=\\\"bonus_payable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for bonus payable balance.\\\",\\n        display_name=\\\"Bonus Payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"BONUS_PAYABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"tax_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for tax receivable balance.\\\",\\n        display_name=\\\"Tax Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"TAX_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"zakat_receivable_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for zakat receivable balance.\\\",\\n        display_name=\\\"Zakat Receivable account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"ZAKAT_RECEIVABLE\\\",\\n    ),\\n    Parameter(\\n        name=\\\"maintenance_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for maintenance fee income balance.\\\",\\n        display_name=\\\"Maintenance fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"MAINTENANCE_FEE_INCOME\\\",\\n    ),\\n    Parameter(\\n        name=\\\"inactivity_fee_income_account\\\",\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for account inactivity fee income balance.\\\",\\n        display_name=\\\"Account inactivity fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=\\\"INACTIVITY_FEE_INCOME\\\",\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"get_transaction_type\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    ),\\n]\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n    account_creation_date = vault.get_account_creation_date()\\n    schedule_list = []\\n    bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault,\\n        \\\"bonus_distribution\\\",\\n        at=account_creation_date,\\n        union=True,\\n        is_boolean=True,\\n    )\\n    if bonus_distribution:\\n        bonus_distribution_schedule = _create_bonus_distribution_schedule(vault)\\n        bonus_distribution_schedule_dict = (\\\"BONUS_DISTRIBUTION\\\", bonus_distribution_schedule)\\n        schedule_list.append(bonus_distribution_schedule_dict)\\n\\n    # Every month anniversary from account opening at time set by template parameters\\n    apply_monthly_fees_schedule = _get_next_fee_schedule(\\n        vault, account_creation_date, timedelta(months=1)\\n    )\\n    apply_monthly_fees_schedule_dict = (\\\"APPLY_MONTHLY_FEES\\\", apply_monthly_fees_schedule)\\n    schedule_list.append(apply_monthly_fees_schedule_dict)\\n    return schedule_list\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"APPLY_MONTHLY_FEES\\\",\\n    flags=True,\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"BONUS_DISTRIBUTION\\\",\\n    parameters=True,\\n    balances=\\\"32 days live\\\",\\n    flags=True,\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    account_creation_date = vault.get_account_creation_date()\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == \\\"BONUS_DISTRIBUTION\\\":\\n        # Check if bonus distribution is enabled\\n        bonus_distribution = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault,\\n            \\\"bonus_distribution\\\",\\n            at=account_creation_date,\\n            union=True,\\n            is_boolean=True,\\n        )\\n        if bonus_distribution:\\n            posting_instructions.extend(_handle_bonus_distribution(vault, effective_date))\\n\\n    elif event_type == \\\"APPLY_MONTHLY_FEES\\\":\\n        posting_instructions.extend(_apply_monthly_fees(vault, effective_date))\\n        new_schedule = _get_next_fee_schedule(vault, effective_date, timedelta(months=1))\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n    if new_schedule:\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    flags=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef pre_posting_code(incoming_posting_batch: PostingInstructionBatch, effective_date: datetime):\\n\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    if is_account_dormant is True:\\n        raise Rejected(\\n            'Account flagged \\\"Dormant\\\" does not accept external transactions.',\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n\\n    _check_posting_denomination(incoming_posting_batch, denomination)\\n\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    available_balance = _get_outgoing_available_balance(balances, denomination)\\n\\n    withdrawal_balance_delta = _get_outgoing_available_balance(\\n        incoming_posting_batch.balances(), denomination\\n    )\\n\\n    _check_balance_limits(\\n        vault,\\n        denomination,\\n        withdrawal_balance_delta,\\n        available_balance,\\n    )\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if \\\"bonus_distribution\\\" in parameters:\\n        raise Rejected(\\n            f\\\"Cannot update the bonus distribution after account creation\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n# Helpers\\ndef _check_balance_limits(\\n    vault,\\n    denomination: str,\\n    withdrawal_balance_delta: Decimal,\\n    available_balance: Decimal,\\n) -> None:\\n    minimum_balance = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"minimum_balance\\\")\\n    available_balance_without_minimum_balance = available_balance - minimum_balance\\n\\n    if (\\n        0 > withdrawal_balance_delta\\n        and 0 > withdrawal_balance_delta + available_balance_without_minimum_balance\\n    ):\\n        raise Rejected(\\n            f\\\"Postings total {denomination} {withdrawal_balance_delta}, which exceeds the\\\"\\n            f\\\" available balance of {denomination} {available_balance_without_minimum_balance}.\\\",\\n            reason_code=RejectedReason.INSUFFICIENT_FUNDS,\\n        )\\n\\n\\ndef _apply_monthly_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Applies maintenance fees to the account. By design these are not accrued\\n    daily on a pro-rata basis but applied when due monthly. When the account is\\n    closed they are not prorated.\\n\\n    :param vault: Vault object\\n    :param effective_date: date and time of hook being run\\n\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    maintenance_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"maintenance_fee_income_account\\\"\\n    )\\n    inactivity_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"inactivity_fee_income_account\\\"\\n    )\\n    monthly_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"maintenance_fee_monthly\\\")\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    account_inactivity_fee = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"account_inactivity_fee\\\")\\n    is_account_dormant = vault.get_flag_timeseries(flag=DORMANCY_FLAG).latest()\\n\\n    posting_instructions = []\\n\\n    # Post monthly maintenance fee if set for this account\\n    if not is_account_dormant and monthly_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=maintenance_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_MAINTENANCE\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Monthly maintenance fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    # Post inactivity fee if set for this account and account is dormant\\n    if is_account_dormant and account_inactivity_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=account_inactivity_fee,\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=inactivity_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"APPLY_MONTHLY_FEES\\\"\\n                f\\\"_INACTIVITY\\\"\\n                f\\\"_{vault.get_hook_execution_id()}\\\"\\n                f\\\"_{denomination}_INTERNAL\\\",\\n                instruction_details={\\n                    \\\"description\\\": \\\"Account inactivity fee\\\",\\n                    \\\"event\\\": \\\"APPLY_MONTHLY_FEES\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _handle_bonus_distribution(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Handles the bonus distribution, tax and zakat application\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n    # Apply bonus\\n    bonus_posting_intructions, bonus_calculated = _distribute_bonus(\\n        vault, effective_date=effective_date\\n    )\\n    posting_ins.extend(bonus_posting_intructions)\\n\\n    # Apply tax\\n    tax_posting_intructions, tax_amount = _apply_tax(vault, bonus_calculated=bonus_calculated)\\n    posting_ins.extend(tax_posting_intructions)\\n\\n    # Apply zakat\\n    zakat_posting_intructions = _apply_zakat(\\n        vault, bonus_calculated=bonus_calculated, tax_calculated=tax_amount\\n    )\\n    posting_ins.extend(zakat_posting_intructions)\\n\\n    return posting_ins\\n\\n\\ndef _distribute_bonus(vault, effective_date: datetime) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the bonus to be distributed to the account\\n\\n    :param vault: Vault object\\n    :param effective_date: hook runtime\\n    :return: posting instructions and the bonus calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    bonus_payable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_payable_account\\\")\\n\\n    monthly_bonus_base_rate = _get_monthly_bonus_rate(vault)\\n    if monthly_bonus_base_rate == 0:\\n        return posting_ins, Decimal(0)\\n\\n    eod_midnight_cut_off_time = _determine_midnight_cutoff_datetime(effective_date)\\n    monthly_mean_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n        _monthly_mean_balance(\\n            vault, denomination=denomination, effective_date=eod_midnight_cut_off_time\\n        ),\\n        2,\\n    )\\n    if monthly_mean_balance == 0:\\n        return posting_ins, Decimal(0)\\n\\n    bonus_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        monthly_bonus_base_rate * monthly_mean_balance, 2\\n    )\\n\\n    if bonus_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=bonus_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"BONUS_DISTRIBUTION_{vault.get_hook_execution_id()}\\\",\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=bonus_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Bonus distributed at monthly rate of \\\"\\n                    f\\\"{(monthly_bonus_base_rate * 100):0.4f}% on monthly average balance of \\\"\\n                    f\\\"{denomination}{monthly_mean_balance}\\\",\\n                    \\\"event\\\": \\\"BONUS_DISTRIBUTION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, bonus_calculated\\n\\n\\ndef _apply_tax(vault, bonus_calculated: Decimal) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Calculates the tax on the bonus calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :return: posting instructions and the tax calculated\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    tax_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"tax_receivable_account\\\")\\n    tax_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"tax_rate\\\"))\\n    is_tax_waived = vault.get_flag_timeseries(flag=WAIVE_TAX_FLAG).latest()\\n\\n    if tax_rate == 0 or is_tax_waived is True or bonus_calculated == 0:\\n        return posting_ins, Decimal(0)\\n\\n    tax_calculated = vault.modules[\\\"utils\\\"].round_decimal(bonus_calculated * tax_rate, 2)\\n\\n    if tax_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tax_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"TAX_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=tax_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Tax applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated}\\\",\\n                    \\\"event\\\": \\\"TAX_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins, tax_calculated\\n\\n\\ndef _apply_zakat(\\n    vault, bonus_calculated: Decimal, tax_calculated: Decimal\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculates the zakat on the bonus and tax calculated\\n\\n    :param vault: Vault object\\n    :param bonus_calculated: Bonus calculated\\n    :param tax_calculated: Tax calculated\\n    :return: posting instructions\\n    \\\"\\\"\\\"\\n    posting_ins = []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"denomination\\\")\\n    zakat_receivable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"zakat_receivable_account\\\"\\n    )\\n    zakat_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"zakat_rate\\\"))\\n    is_zakat_waived = vault.get_flag_timeseries(flag=WAIVE_ZAKAT_FLAG).latest()\\n\\n    if zakat_rate == 0 or is_zakat_waived is True:\\n        return posting_ins\\n\\n    zakat_calculated = vault.modules[\\\"utils\\\"].round_decimal(\\n        (bonus_calculated - tax_calculated) * zakat_rate, 2\\n    )\\n\\n    if zakat_calculated > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=zakat_calculated,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"ZAKAT_APPLICATION_{vault.get_hook_execution_id()}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=zakat_receivable_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Zakat applied on bonus calculated \\\"\\n                    f\\\"{denomination}{bonus_calculated} and tax {tax_calculated}\\\",\\n                    \\\"event\\\": \\\"ZAKAT_APPLICATION\\\",\\n                },\\n            )\\n        )\\n\\n    return posting_ins\\n\\n\\ndef _instruct_posting_batch(\\n    vault,\\n    instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\ndef _monthly_mean_balance(vault, denomination: str, effective_date: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Determine whether the average balance for the preceding month fell below the account threshold\\n    The sampling time is the same time as the fee application time\\n    The sampling period is from one month ago until yesterday, inclusive\\n    i.e. not including today/now. If the sampling time is before the account\\n    was opened then skip that day.\\n\\n    :param vault: Vault object\\n    :param denomination: Account denomination\\n    :param effective_date: date and time of hook being run\\n    :return: mean balance at sampling time for previous month\\n    \\\"\\\"\\\"\\n    creation_date = vault.get_account_creation_date()\\n    period_start = effective_date - timedelta(months=1)\\n    if period_start < creation_date:\\n        period_start = creation_date\\n    num_days = (effective_date - period_start).days\\n    # Move the period start to 23:59:59.9999 of the same day\\n    period_start = period_start + timedelta(days=1, microseconds=-1)\\n    if num_days == 0:\\n        return Decimal(0)\\n    total = sum(\\n        [\\n            vault.get_balance_timeseries()\\n            .at(timestamp=period_start + timedelta(days=i))[\\n                (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n            ]\\n            .net\\n            for i in range(num_days)\\n        ]\\n    )\\n    mean_balance = total / num_days\\n    return mean_balance\\n\\n\\ndef _get_outgoing_available_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)].net\\n    )\\n\\n\\ndef _get_incoming_balance(\\n    balances: Dict[Tuple[str, str, str, Phase], Balance], denomination: str\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get the available balance on account for outgoing postings. Only settled funds are considered.\\n    Phase.PENDING_OUT net amount will be negative for outbound authorisations.\\n\\n    :param balances: defaultdict of balance dimensions to balance object\\n    :return: Decimal, available outgoing balance\\n    \\\"\\\"\\\"\\n    return (\\n        balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        + balances[(DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_IN)].net\\n    )\\n\\n\\ndef _create_bonus_distribution_schedule(\\n    vault,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next bonus application day\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :return: dict, representation of BONUS_DISTRIBUTION schedule\\n    \\\"\\\"\\\"\\n\\n    bonus_distribution_day = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_day\\\")\\n    bonus_distribution_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"bonus_distribution_hour\\\")\\n    bonus_distribution_minute = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_minute\\\"\\n    )\\n    bonus_distribution_second = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, \\\"bonus_distribution_second\\\"\\n    )\\n\\n    bonus_distribution_schedule = {\\n        \\\"day\\\": str(bonus_distribution_day),\\n        \\\"hour\\\": str(bonus_distribution_hour),\\n        \\\"minute\\\": str(bonus_distribution_minute),\\n        \\\"second\\\": str(bonus_distribution_second),\\n    }\\n\\n    return bonus_distribution_schedule\\n\\n\\ndef _get_monthly_bonus_rate(vault):\\n    bonus_base_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=\\\"bonus_base_rate\\\"))\\n    bonus_special_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_special_rate\\\", optional=True\\n    )\\n    bonus_spread_rate = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=\\\"bonus_spread_rate\\\", optional=True\\n    )\\n\\n    bonus_spread_rate = Decimal(bonus_spread_rate) if bonus_spread_rate else Decimal(0)\\n\\n    final_bonus_rate = Decimal(0)\\n    if bonus_special_rate:\\n        final_bonus_rate = (bonus_special_rate + bonus_spread_rate) / 12\\n    else:\\n        final_bonus_rate = (bonus_base_rate + bonus_spread_rate) / 12\\n\\n    return final_bonus_rate\\n\\n\\ndef _get_next_fee_schedule(vault, start_date: datetime, offset: timedelta) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for next run time of APPLY_???_FEES, taking the hh:mm:ss\\n    from contract parameters and the period from the \\\"offset\\\" parameter.\\n\\n    :param vault: Vault object\\n    :param start_date: datetime, date from which to calculate next event datetime\\n    :param offset: timedelta, offset to add to start_date\\n    :return: dict, representation of schedule\\n    \\\"\\\"\\\"\\n\\n    fees_application_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_hour\\\")\\n    fees_application_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_minute\\\")\\n    fees_application_second = vault.modules[\\\"utils\\\"].get_parameter(vault, \\\"fees_application_second\\\")\\n\\n    next_schedule_date = start_date + offset\\n\\n    next_schedule_date = next_schedule_date.replace(\\n        hour=fees_application_hour,\\n        minute=fees_application_minute,\\n        second=fees_application_second,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_schedule_date)\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _create_schedule_dict_from_params(\\n    year: Optional[int] = None,\\n    month: Optional[int] = None,\\n    day: Optional[int] = None,\\n    hour: Optional[int] = None,\\n    minute: Optional[int] = None,\\n    second: Optional[int] = None,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n\\n    :param year: int, year for schedule to run\\n    :param month: int, month for schedule to run\\n    :param day: int, day of month for schedule to run\\n    :param hour: int, hour of day for schedule to run\\n    :param minute: int, minute of hour for schedule to run\\n    :param second: int, second of minute for schedule to run\\n    :return: dict, representation of schedule from function input\\n    \\\"\\\"\\\"\\n    schedule_dict = {}\\n    if year is not None:\\n        schedule_dict[\\\"year\\\"] = str(year)\\n    if month is not None:\\n        schedule_dict[\\\"month\\\"] = str(month)\\n    if day is not None:\\n        schedule_dict[\\\"day\\\"] = str(day)\\n    if hour is not None:\\n        schedule_dict[\\\"hour\\\"] = str(hour)\\n    if minute is not None:\\n        schedule_dict[\\\"minute\\\"] = str(minute)\\n    if second is not None:\\n        schedule_dict[\\\"second\\\"] = str(second)\\n    return schedule_dict\\n\\n\\ndef _check_posting_denomination(postings: List[PostingInstruction], accepted_denomination: str):\\n    for posting in postings:\\n        if posting.denomination != accepted_denomination:\\n            raise Rejected(\\n                f\\\"Postings received in unauthorised denomination {posting.denomination}.\\\"\\n                f\\\" Authorised denomination is {accepted_denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n\\n\\ndef _determine_midnight_cutoff_datetime(scheduled_datetime: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Determines the midnight datetime in local time\\n    Bonus distribution, monthly mean balance should always use the effective balance from\\n    00:00:00 WIB on the current day (17:00:00 UTC)\\n    :param scheduled_datetime: UTC schedule datetime\\n    :return: datetime, UTC local-midnight cut-off\\n    \\\"\\\"\\\"\\n    # Calculate the cutoff for 17:00:00 UTC\\n    local_balance_cutoff_ts = scheduled_datetime + timedelta(\\n        hour=UTC_HOUR_FOR_LOCAL_MIDNIGHT, minute=0, second=0, microsecond=0\\n    )\\n\\n    return local_balance_cutoff_ts\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"bonus_distribution_hour\": \"0\",\n                \"bonus_distribution_minute\": \"1\",\n                \"bonus_distribution_second\": \"0\",\n                \"bonus_payable_account\": \"BONUS_PAYABLE\",\n                \"maintenance_fee_income_account\": \"MAINTENANCE_FEE_INCOME\",\n                \"inactivity_fee_income_account\": \"INACTIVITY_FEE_INCOME\",\n                \"tax_receivable_account\": \"TAX_RECEIVABLE\",\n                \"zakat_receivable_account\": \"ZAKAT_RECEIVABLE\",\n                \"maintenance_fee_monthly\": \"0\",\n                \"minimum_balance\": \"25000\",\n                \"account_inactivity_fee\": \"0\",\n                \"fees_application_hour\": \"0\",\n                \"fees_application_minute\": \"1\",\n                \"fees_application_second\": \"0\",\n                \"bonus_base_rate\": \"0.01\",\n                \"bonus_distribution_day\": \"1\"\n            },\n            \"smart_contract_version_id\": \"1000\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"5197736121490366464\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7145871606771306598\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8904078363962271283\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6632383930890487524\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"7884032891663598059\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8844474970154615954\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"BONUS_PAYABLE\",\n                \"product_version_id\": \"5197736121490366464\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MAINTENANCE_FEE_INCOME\",\n                \"product_version_id\": \"7145871606771306598\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"INACTIVITY_FEE_INCOME\",\n                \"product_version_id\": \"8904078363962271283\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAX_RECEIVABLE\",\n                \"product_version_id\": \"6632383930890487524\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"ZAKAT_RECEIVABLE\",\n                \"product_version_id\": \"7884032891663598059\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"1\",\n                \"product_version_id\": \"8844474970154615954\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_1000\",\n                \"smart_contract_version_id\": \"1000\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"18620c58-4b7c-4e37-9b2f-d5b311040cad\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"tax_rate\",\n                    \"display_name\": \"Tax Rate\",\n                    \"description\": \"Tax Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_global_parameter\": {\n                \"global_parameter\": {\n                    \"id\": \"zakat_rate\",\n                    \"display_name\": \"Zakat Rate\",\n                    \"description\": \"Zakat Rate\",\n                    \"number\": {\n                        \"kind\": {\n                            \"_value_\": \"percentage\",\n                            \"_name_\": \"PERCENTAGE\",\n                            \"__objclass__\": \"{'_generate_next_value_': <function Enum._generate_next_value_ at 0x7f6b5c7835e0>, '__module__': 'inception_sdk.vault.contracts.types', '__doc__': 'An enumeration.', '_member_names_': ['MONEY', 'MONTHS', 'PERCENTAGE', 'PLAIN'], '_member_map_': {'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>}, '_member_type_': <class 'object'>, '_value2member_map_': {'money': <NumberKind.MONEY: 'money'>, 'months': <NumberKind.MONTHS: 'months'>, 'percentage': <NumberKind.PERCENTAGE: 'percentage'>, 'plain': <NumberKind.PLAIN: 'plain'>}, 'MONEY': <NumberKind.MONEY: 'money'>, 'MONTHS': <NumberKind.MONTHS: 'months'>, 'PERCENTAGE': <NumberKind.PERCENTAGE: 'percentage'>, 'PLAIN': <NumberKind.PLAIN: 'plain'>, '__new__': <function Enum.__new__ at 0x7f6b5c783550>}\"\n                        },\n                        \"min_value\": \"0\",\n                        \"max_value\": \"1\",\n                        \"step\": \"0.0001\"\n                    },\n                    \"str\": null,\n                    \"denomination\": null,\n                    \"date\": null\n                },\n                \"initial_value\": \"0\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"Main account\",\n                \"product_version_id\": \"1000\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"bonus_distribution\": \"true\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T01:00:00+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"c56b82ee-772a-4f4d-8ce9-b33ee3f0bc14\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"5056f2fc-247a-4fee-b297-721900dc9203\",\n                        \"instruction_details\": {},\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"5000000\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"Main account\"\n                            },\n                            \"internal_account_id\": \"1\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"event\": \"DEPOSIT_1\"\n                },\n                \"value_timestamp\": \"2022-01-01T01:00:00+00:00\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "E2E",
			"item": [
				{
					"name": "Customer setup",
					"item": [
						{
							"name": "Create customer",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"var jsonData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable(\"customer_id\", jsonData.id);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "X-Auth-Token",
										"value": "{{access_token}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"customer\": {\n    \"status\": \"CUSTOMER_STATUS_ACTIVE\",\n    \"identifiers\": [],\n    \"customer_details\": null,\n    \"additional_details\": {}\n  },\n  \"request_id\": \"{{$guid}}\"\n}"
								},
								"url": {
									"raw": "{{core_api_base}}/v1/customers",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"customers"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Account creation",
					"item": [
						{
							"name": "Create Live Wadiah Account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"var jsonData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable(\"wadiah_account_id\", jsonData.id);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Auth-Token",
										"type": "text",
										"value": "{{access_token}}"
									},
									{
										"key": "Content-Type",
										"name": "Content-Type",
										"type": "text",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n          \"request_id\": \"{{$guid}}\",\n          \"account\": {\n            \"product_id\": \"tahapan_wadiah_ib\",\n            \"stakeholder_ids\": [\n              \"{{customer_id}}\"\n            ],\n            \"instance_param_vals\": {\n                \"bonus_distribution\": \"true\"\n            },\n            \"details\": {},\n            \"status\": \"ACCOUNT_STATUS_OPEN\"\n          }\n        }\n   "
								},
								"url": {
									"raw": "{{core_api_base}}/v1/accounts",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"accounts"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Transactions",
					"item": [
						{
							"name": "Deposit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"var jsonData = JSON.parse(responseBody);",
											"pm.environment.get(\"variable_key\");",
											"postman.setEnvironmentVariable(\"posting_async_operation_id\", jsonData.id);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Auth-Token",
										"type": "text",
										"value": "{{access_token}}"
									},
									{
										"key": "Content-Type",
										"type": "text",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"request_id\": \"{{$timestamp}}\",\n    \"posting_instruction_batch\": {\n        \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n        \"client_batch_id\": \"{{$guid}}\",\n        \"posting_instructions\": [\n            {\n                \"client_transaction_id\": \"{{$guid}}\",\n                \"inbound_hard_settlement\": {\n                    \"amount\": \"1000000\",\n                    \"denomination\": \"IDR\",\n                    \"target_account\": {\n                        \"account_id\": \"{{wadiah_account_id}}\"\n                    },\n                    \"internal_account_id\": \"1\",\n                    \"advice\": null\n                },\n                \"instruction_details\": {\n                    \"transaction_code\": \"DEPOSIT\"\n                }\n            }\n        ],\n        \"batch_details\": {}\n    }\n}"
								},
								"url": {
									"raw": "{{core_api_base}}/v1/posting-instruction-batches:asyncCreate",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"posting-instruction-batches:asyncCreate"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get async operation for PIB",
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "X-Auth-Token",
										"type": "text",
										"value": "{{access_token}}"
									}
								],
								"url": {
									"raw": "{{core_api_base}}/v1/posting-instruction-batches/async-operations:batchGet?&ids={{posting_async_operation_id}}",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"posting-instruction-batches",
										"async-operations:batchGet"
									],
									"query": [
										{
											"key": null,
											"value": ""
										},
										{
											"key": "ids",
											"value": "{{posting_async_operation_id}}"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Update instance parameter",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{access_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"request_id\": \"{{$timestamp}}\",\n    \"account_update\": {\n        \"account_id\": \"{{wadiah_account_id}}\",\n        \"instance_param_vals_update\": {\n            \"instance_param_vals\": {\n                \"bonus_distribution\": \"false\"\n            }\n        }\n    }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/account-updates",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"account-updates"
							]
						}
					},
					"response": []
				}
			]
		}
	]
}