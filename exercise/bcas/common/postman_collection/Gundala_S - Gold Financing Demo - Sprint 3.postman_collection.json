{
	"info": {
		"_postman_id": "427bbafd-c1ad-48d5-a8a9-34f2e9f81680",
		"name": "Gundala_S - Gold Financing Sprint 3",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "2084487"
	},
	"item": [
		{
			"name": "Simulation",
			"item": [
				{
					"name": "Gold Financing - Demo Normal Maturity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"GOLD_FINANCING_ACCOUNT\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{sa_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-20T00:00:00+00:00\",\n    \"end_timestamp\": \"2023-01-21T00:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.8\\\"\\ndisplay_name = \\\"Gold Financing\\\"\\nsummary = \\\"A financing product based on akad Murabaha from BCA Syariah \\\"\\n\\\"which aims for Logam Mulia (Gold) ownership using Sharia principles\\\"\\ntside = Tside.ASSET\\n\\n# Time zone offset constants\\nWIB_UTC_OFFSET = 0\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\nnotification_types = [\\n    \\\"GOLD_FINANCING_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_DELIQUENT\\\",\\n]\\n\\n# Schedule events\\nACCRUE_MARGIN_AND_FEES = \\\"ACCRUE_MARGIN_AND_FEES\\\"\\nREPAYMENT_DAY_SCHEDULE = \\\"REPAYMENT_DAY_SCHEDULE\\\"\\nCHECK_OVERDUE = \\\"CHECK_OVERDUE\\\"\\n\\n# Posting events\\nREPAYMENT_EVENT = \\\"REPAYMENT\\\"\\nSETTLEMENT_EVENT = \\\"SETTLEMENT\\\"\\n\\nevent_types_groups = [\\n    EventTypesGroup(\\n        name=\\\"MARGIN\\\",\\n        event_types_order=[ACCRUE_MARGIN_AND_FEES, REPAYMENT_DAY_SCHEDULE, CHECK_OVERDUE],\\n    ),\\n]\\nevent_types = [\\n    EventType(\\n        name=ACCRUE_MARGIN_AND_FEES,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_ACCRUE_MARGIN_AND_FEES_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=REPAYMENT_DAY_SCHEDULE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_REPAYMENT_DAY_SCHEDULE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=CHECK_OVERDUE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_CHECK_OVERDUE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n]\\n\\n# Product Params\\nDENOMINATION = \\\"denomination\\\"\\nEQUIVALENT_RATE = \\\"equivalent_rate\\\"\\nEARLY_MATURITY_MARGIN = \\\"early_maturity_margin\\\"\\nREPAYMENT_PERIOD = \\\"repayment_period\\\"\\nACCRUAL_PRECISION = \\\"accrual_precision\\\"\\nFULFILLMENT_PRECISION = \\\"fulfillment_precision\\\"\\n\\n# Fees\\nTAWIDH_FEE = \\\"tawidh_fee\\\"\\n\\n# Periods\\nTAZIR_PERIOD = \\\"tazir_period\\\"\\nMAXIMUM_DPD = \\\"maximum_dpd\\\"\\n\\n# Schedule Params\\nACCRUE_MARGIN_HOUR = \\\"accrue_margin_hour\\\"\\nACCRUE_MARGIN_MINUTE = \\\"accrue_margin_minute\\\"\\nACCRUE_MARGIN_SECOND = \\\"accrue_margin_second\\\"\\nCHECK_OVERDUE_HOUR = \\\"check_overdue_hour\\\"\\nCHECK_OVERDUE_MINUTE = \\\"check_overdue_minute\\\"\\nCHECK_OVERDUE_SECOND = \\\"check_overdue_second\\\"\\nREPAYMENT_HOUR = \\\"repayment_hour\\\"\\nREPAYMENT_MINUTE = \\\"repayment_minute\\\"\\nREPAYMENT_SECOND = \\\"repayment_second\\\"\\n\\n# Instance Params\\nGOLD_FINANCING_PRINCIPAL = \\\"principal\\\"\\nTOTAL_TERM = \\\"total_term\\\"\\nFIRST_REPAYMENT_DATE = \\\"first_repayment_date\\\"\\nGOLD_FINANCING_START_DATE = \\\"gold_financing_start_date\\\"\\n\\nINSTANCE_PARAMS = [\\n    GOLD_FINANCING_PRINCIPAL,\\n    TOTAL_TERM,\\n    FIRST_REPAYMENT_DATE,\\n    GOLD_FINANCING_START_DATE,\\n]\\n\\n# Derived Params\\nTOTAL_OUTSTANDING = \\\"total_outstanding\\\"\\nGOLD_FINANCING_REMAINING_PRINCIPAL = \\\"gold_financing_remaining_principal\\\"\\nOUTSTANDING_PAYMENTS = \\\"outstanding_payments\\\"\\nREMAINING_TERM = \\\"remaining_term\\\"\\nEXPECTED_EMI = \\\"expected_emi\\\"\\nNEXT_REPAYMENT_DATE = \\\"next_repayment_date\\\"\\nNEXT_OVERDUE_DATE = \\\"next_overdue_date\\\"\\nEARLY_MATURITY_REPAYMENT_AMOUNT = \\\"early_maturity_repayment_amount\\\"\\n\\n# Internal Accounts\\nSUSPENSE_ACCOUNT = \\\"supense_account\\\"\\nDISBURSEMENT_ACCOUNT = \\\"disbursement_account\\\"\\nSETTLEMENT_ACCOUNT = \\\"settlement_account\\\"\\nMARGIN_INCOME_ACCOUNT = \\\"margin_income_account\\\"\\nTAWIDH_FEE_INCOME_ACCOUNT = \\\"tawidh_fee_income_account\\\"\\nMUQASAH_PAYABLE_ACCOUNT = \\\"muqasah_payable_account\\\"\\nTAZIR_FEE_INCOME_ACCOUNT = \\\"tazir_fee_income_account\\\"\\n\\n\\n# Financing Addresses\\nOVERPAYMENT = \\\"OVERPAYMENT\\\"\\nEMI_ADDRESS = \\\"EMI\\\"\\nPRINCIPAL_DUE = \\\"PRINCIPAL_DUE\\\"\\nMARGIN_DUE = \\\"MARGIN_DUE\\\"\\nACCRUED_MARGIN = \\\"ACCRUED_MARGIN\\\"\\nPRINCIPAL = \\\"PRINCIPAL\\\"\\nMARGIN = \\\"MARGIN\\\"\\nPRINCIPAL_OVERDUE = \\\"PRINCIPAL_OVERDUE\\\"\\nMARGIN_OVERDUE = \\\"MARGIN_OVERDUE\\\"\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nTAWIDH_ADDRESS = \\\"TAWIDH\\\"\\nTAZIR_ADDRESS = \\\"TAZIR\\\"\\n\\n# Days calculation\\nDAYS_IN_A_WEEK = 7\\nDAYS_IN_A_MONTH = 30\\nDAYS_IN_A_YEAR = 360\\nWEEKS_IN_YEAR = 52\\nMONTHS_IN_A_YEAR = 12\\n\\n# Repayment Order\\nOVERDUE_ADDRESSES = [PRINCIPAL_OVERDUE, MARGIN_OVERDUE]\\nMARGIN_ADDRESSES = [MARGIN_DUE, MARGIN_OVERDUE]\\nDUE_ADDRESSES = [PRINCIPAL_DUE, MARGIN_DUE]\\nFEES_ADDRESSES = [TAWIDH_ADDRESS, TAZIR_ADDRESS]\\n\\nOVERDUE_ORDER = {\\n    PRINCIPAL_OVERDUE: 0,\\n    MARGIN_OVERDUE: 1,\\n}\\n\\nREPAYMENT_DUES_ORDER = [FEES_ADDRESSES] + [DUE_ADDRESSES]\\n\\nOVERDUE_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    PRINCIPAL_DUE,\\n    MARGIN_OVERDUE,\\n    PRINCIPAL_OVERDUE,\\n]\\n\\nMARGIN_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    MARGIN_OVERDUE,\\n]\\n\\n# Parameter Shape\\nRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nparameters = [\\n    # Instance Parameters\\n    Parameter(\\n        name=TOTAL_TERM,\\n        shape=NumberShape(min_value=Decimal(12), max_value=Decimal(60), step=Decimal(1)),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed length of the gold financing (in months).\\\",\\n        display_name=\\\"Loan term (months)\\\",\\n        default_value=Decimal(12),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_PRINCIPAL,\\n        shape=NumberShape(\\n            min_value=Decimal(1),\\n            max_value=Decimal(300000000),\\n            step=Decimal(1),\\n            kind=NumberKind.MONEY,\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed amount the customer will borrow from the bank.\\\",\\n        display_name=\\\"Loan principal\\\",\\n        default_value=Decimal(1),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=FIRST_REPAYMENT_DATE,\\n        shape=OptionalShape(DateShape(min_date=datetime.min, max_date=datetime.max)),\\n        level=Level.INSTANCE,\\n        description=\\\"The selected date which customer will make first repayment.\\\"\\n        \\\" The next monthly repayment day will be derived based on first repayment date.\\\",\\n        display_name=\\\"First Repayment Date\\\",\\n        default_value=OptionalValue(datetime.min),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_START_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        description=\\\"Start of the gold financing contract terms, either after account opening \\\"\\n        \\\"or top up.\\\",\\n        display_name=\\\"Start date of the Gold Finance\\\",\\n        default_value=datetime.min,\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    # Derived Parameters\\n    Parameter(\\n        name=TOTAL_OUTSTANDING,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total balance on this account (including fees).\\\",\\n        display_name=\\\"Total outstanding\\\",\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_REMAINING_PRINCIPAL,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Total remaining principal on this account.\\\",\\n        display_name=\\\"Remaining Principal\\\",\\n    ),\\n    Parameter(\\n        name=OUTSTANDING_PAYMENTS,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Unpaid dues, overdues and penalties\\\",\\n        display_name=\\\"Outstanding payments\\\",\\n    ),\\n    Parameter(\\n        name=REMAINING_TERM,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total term of the gold financing in months\\\",\\n        display_name=\\\"Remaining term in months\\\",\\n    ),\\n    Parameter(\\n        name=EXPECTED_EMI,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected EMI (Equated Monthly Installment)\\\",\\n        display_name=\\\"Expected EMI\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_REPAYMENT_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Next scheduled repayment date\\\",\\n        display_name=\\\"Next Repayment date\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_OVERDUE_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"The date on which current due principal and margin will become overdue.\\\",\\n        display_name=\\\"Overdue date\\\",\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_REPAYMENT_AMOUNT,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected amount to be paid for early maturity repayment\\\",\\n        display_name=\\\"Early Maturity Repayment Amount\\\",\\n    ),\\n    # Template Parameters\\n    Parameter(\\n        name=DENOMINATION,\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Currency in which the product operates.\\\",\\n        display_name=\\\"Denomination.\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=EQUIVALENT_RATE,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin rate used to calculate margin amount.\\\",\\n        display_name=\\\"Equivalent Rate \\\",\\n        default_value=Decimal(\\\"0.09\\\"),\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_MARGIN,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin percentage to calculate margin need to be paid by customer \\\"\\n        \\\"during early mature process.\\\",\\n        display_name=\\\"Early Maturity Margin Rate \\\",\\n        default_value=Decimal(\\\"0.02\\\"),\\n    ),\\n    Parameter(\\n        name=REPAYMENT_PERIOD,\\n        shape=NumberShape(max_value=31, min_value=1, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days to repay due amount before incurring penalties.\\\",\\n        display_name=\\\"Repayment period (days)\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which due amount is calculated.\\\",\\n        display_name=\\\"Repayment hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUAL_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=15, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin accruals.\\\",\\n        display_name=\\\"Margin accrual precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=FULFILLMENT_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=4, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin fulfillment.\\\",\\n        display_name=\\\"Margin fulfillment precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE,\\n        level=Level.TEMPLATE,\\n        description=\\\"The amount of daily ta'widh will be charged at overdue\\\",\\n        display_name=\\\"Ta'widh fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"2000\\\"),\\n    ),\\n    Parameter(\\n        name=TAZIR_PERIOD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir will accrue since the overdue\\\",\\n        display_name=\\\"Tazir Period\\\",\\n        default_value=10,\\n    ),\\n    Parameter(\\n        name=MAXIMUM_DPD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir and tawidh will not be accrued\\\"\\n        \\\" and send notification to mark the account as deliquent\\\",\\n        display_name=\\\"Maximum Days Past Due\\\",\\n        default_value=90,\\n    ),\\n    # Internal Accounts\\n    Parameter(\\n        name=DISBURSEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The account to which the principal borrowed amount will be transferred.\\\",\\n        display_name=\\\"Disbursement account\\\",\\n        default_value=DISBURSEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=SETTLEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for settlement balance.\\\",\\n        display_name=\\\"Settlement account\\\",\\n        default_value=SETTLEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MARGIN_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for margin income balance.\\\",\\n        display_name=\\\"Margin income account\\\",\\n        shape=AccountIdShape,\\n        default_value=MARGIN_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'widh fee income balance.\\\",\\n        display_name=\\\"Ta'widh fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAWIDH_FEE_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MUQASAH_PAYABLE_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for muqasah payment.\\\",\\n        display_name=\\\"Muqasah payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=MUQASAH_PAYABLE_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAZIR_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'zir fee income balance.\\\",\\n        display_name=\\\"Ta'zir fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAZIR_FEE_INCOME_ACCOUNT,\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    )\\n]\\n\\n# Vault hooks\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=GOLD_FINANCING_START_DATE\\n    )\\n    daily_accrual_schedule = _get_accrue_margin_and_fees_schedule(\\n        vault, gold_financing_start_date.date()\\n    )\\n    monthly_schedule_dict = _get_initial_monthly_schedule(vault)\\n\\n    repayment_day_dict = monthly_schedule_dict.get(REPAYMENT_DAY_SCHEDULE)\\n    check_overdue_dict = monthly_schedule_dict.get(CHECK_OVERDUE)\\n\\n    repayment_day_schedule = {\\n        \\\"day\\\": repayment_day_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": repayment_day_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": repayment_day_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": repayment_day_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    # Check overdue schedule would be runs at the same month as repayment day\\n    check_overdue_schedule = {\\n        \\\"day\\\": check_overdue_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": check_overdue_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": check_overdue_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": check_overdue_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    schedules = [\\n        (ACCRUE_MARGIN_AND_FEES, daily_accrual_schedule),\\n        (REPAYMENT_DAY_SCHEDULE, repayment_day_schedule),\\n        (CHECK_OVERDUE, check_overdue_schedule),\\n    ]\\n\\n    return schedules\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef derived_parameters(effective_date):\\n    total_outstanding = _get_all_outstanding(vault)\\n    next_repayment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    total_term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, TOTAL_TERM))\\n    next_overdue_date = next_repayment_date + timedelta(days=int(repayment_period))\\n    sum_outstanding_dues = _sum_outstanding_dues(vault)\\n    outstanding_actual_principal = _get_outstanding_actual_principal(vault)\\n    return {\\n        TOTAL_OUTSTANDING: total_outstanding,\\n        GOLD_FINANCING_REMAINING_PRINCIPAL: outstanding_actual_principal,\\n        OUTSTANDING_PAYMENTS: sum_outstanding_dues,\\n        NEXT_REPAYMENT_DATE: next_repayment_date,\\n        NEXT_OVERDUE_DATE: next_overdue_date,\\n        REMAINING_TERM: _get_expected_remaining_term(vault, effective_date, total_term),\\n        EXPECTED_EMI: _get_expected_emi(vault, effective_date),\\n        EARLY_MATURITY_REPAYMENT_AMOUNT: _calculate_early_maturity_repayment_amount(\\n            vault, effective_date\\n        ),\\n    }\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef post_activate_code():\\n\\n    account_creation_date = vault.get_account_creation_date()\\n    principal = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL))\\n    disbursement_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DISBURSEMENT_ACCOUNT)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n\\n    monthly_instalment = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, eq_rate, term),\\n        precision,\\n    )\\n    margin_receivable_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_instalment * term) - principal,\\n        precision,\\n    )\\n\\n    posting_ins = []\\n    posting_ins.extend(\\n        vault.make_internal_transfer_instructions(\\n            amount=principal,\\n            denomination=denomination,\\n            client_transaction_id=vault.get_hook_execution_id() + \\\"_PRINCIPAL_DISBURSMENT\\\",\\n            from_account_id=vault.account_id,\\n            from_account_address=PRINCIPAL,\\n            to_account_id=disbursement_account,\\n            to_account_address=DEFAULT_ADDRESS,\\n            instruction_details={\\n                \\\"description\\\": f\\\"Disbursement of {principal} of gold financing principal\\\",\\n                \\\"event\\\": \\\"PRINCIPAL_DISBURSEMENT\\\",\\n            },\\n            asset=DEFAULT_ASSET,\\n            override_all_restrictions=True,\\n        )\\n    )\\n\\n    if margin_receivable_amount > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_receivable_amount,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_MARGIN_RECEIVABLE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Disbursement of {margin_receivable_amount} of gold financing \\\"\\n                    \\\"margin receivable\\\",\\n                    \\\"event\\\": \\\"MARGIN_RECEIVABLE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if monthly_instalment > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_instalment,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_STORE_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Store monthly installment at \\\"\\n                    f\\\"{denomination}{monthly_instalment} \\\"\\n                    f\\\"of gold financing to {EMI_ADDRESS}\\\",\\n                    \\\"event\\\": \\\"STORE_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    vault.instruct_posting_batch(\\n        posting_instructions=posting_ins,\\n        effective_date=account_creation_date,\\n        client_batch_id=f\\\"BATCH_{vault.get_hook_execution_id()}_INITIAL_GOLD_FINANCING_DISBURSMENT\\\",\\n    )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"ACCRUE_MARGIN_AND_FEES\\\",\\n    parameters=True,\\n    balances=\\\"2 months\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\", \\\"CHECK_OVERDUE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"REPAYMENT_DAY_SCHEDULE\\\",\\n    parameters=True,\\n    balances=\\\"2 days live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"CHECK_OVERDUE\\\",\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == ACCRUE_MARGIN_AND_FEES:\\n        posting_instructions.extend(_handle_accrue_margin_and_fees(vault, effective_date))\\n    elif event_type == REPAYMENT_DAY_SCHEDULE:\\n        posting_instructions.extend(_handle_repayment_due(vault, effective_date))\\n        new_schedule = _get_next_repayment_day_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    elif event_type == CHECK_OVERDUE:\\n        posting_instructions.extend(_handle_overdue(vault, effective_date))\\n        new_schedule = _get_next_check_overdue_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef pre_posting_code(postings, effective_date):\\n    if len(postings) > 1:\\n        raise Rejected(\\n            \\\"Multiple postings in batch not supported\\\",\\n            reason_code=RejectedReason.CLIENT_CUSTOM_REASON,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    for posting in postings:\\n        if posting.denomination != denomination:\\n            raise Rejected(\\n                \\\"Cannot make transactions in given denomination; \\\"\\n                f\\\"transactions must be in {denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n        proposed_amount = _get_posting_amount(posting)\\n        if proposed_amount <= 0:\\n            if vault.modules[\\\"utils\\\"].str_to_bool(\\n                postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n            ):\\n                early_maturity_repayment_amount = _calculate_early_maturity_repayment_amount(\\n                    vault, effective_date\\n                )\\n                if abs(proposed_amount) != early_maturity_repayment_amount:\\n                    raise Rejected(\\n                        \\\"Does not match the early repayment amount of \\\"\\n                        f\\\"{early_maturity_repayment_amount}\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n            else:\\n                outstanding = _get_all_outstanding(vault)\\n                if abs(proposed_amount) > outstanding:\\n                    raise Rejected(\\n                        \\\"Cannot pay more than is owed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n                maximum_payment = _sum_outstanding_dues(vault)\\n                if abs(proposed_amount) > maximum_payment:\\n                    raise Rejected(\\n                        \\\"Overpayment transaction is not allowed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n\\n        elif not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"fee\\\", \\\"false\\\")\\n        ) and not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"interest_adjustment\\\", \\\"false\\\")\\n        ):\\n            raise Rejected(\\n                \\\"Debiting not allowed from this account\\\",\\n                reason_code=RejectedReason.AGAINST_TNC,\\n            )\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef post_posting_code(postings: PostingInstructionBatch, effective_date: datetime):\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_amount = _get_posting_batch_amount(postings, denomination)\\n    posting_instructions = []\\n    if posting_amount < 0:\\n        client_transaction_id = (\\n            f\\\"{postings[0].client_transaction_id}_{vault.get_hook_execution_id()}\\\"\\n        )\\n        if vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n        ):\\n            posting_instructions.extend(\\n                _process_early_maturity(\\n                    vault, effective_date, posting_amount, client_transaction_id\\n                )\\n            )\\n        else:\\n            posting_instructions.extend(\\n                _process_payment(vault, effective_date, posting_amount, client_transaction_id)\\n            )\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, REPAYMENT_EVENT)\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if any(param in INSTANCE_PARAMS for param in parameters):\\n        raise Rejected(\\n            \\\"Cannot update the parameter after account is created\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef close_code(effective_date: datetime):\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n    # Check current outstanding balance\\n    outstanding_balance = _get_all_outstanding(vault)\\n    posting_ins = []\\n\\n    # Create settlement posting instrution if there is outstanding balance left in account\\n    cti_settlement = f\\\"{vault.get_hook_execution_id()}_{SETTLEMENT_EVENT}\\\"\\n    if outstanding_balance > 0:\\n        settlemnet_account = vault.modules[\\\"utils\\\"].get_parameter(vault, SETTLEMENT_ACCOUNT)\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_balance,\\n                denomination=denomination,\\n                client_transaction_id=cti_settlement,\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=settlemnet_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                instruction_details={\\n                    \\\"event\\\": SETTLEMENT_EVENT,\\n                    \\\"description\\\": \\\"Settle all outstanding balance before close the account\\\"\\n                    f\\\" at {denomination}{outstanding_balance}\\\",\\n                },\\n                override_all_restrictions=True,\\n            )\\n        )\\n        # Create repayment order for settlement\\n        posting_ins.extend(\\n            _process_payment(vault, effective_date, outstanding_balance, cti_settlement)\\n        )\\n\\n        # Pay Outstanding Principal and Margin\\n        outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL])\\n        outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN])\\n        margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, name=MARGIN_INCOME_ACCOUNT\\n        )\\n        # repay outstanding principal\\n        if outstanding_principal > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_principal,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=PRINCIPAL,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                        f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n        # record margin as income\\n        if outstanding_margin > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{MARGIN}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=margin_income_account,\\n                    to_account_address=DEFAULT_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{MARGIN}_INCOME_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=MARGIN,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n    \\n    # clear EMI\\n    if emi > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {EMI_ADDRESS}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {ACCRUED_MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{ACCRUED_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if len(posting_ins) > 0:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_ins,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"CLOSE_ACCOUNT-{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\n# Helper Functions\\ndef _handle_accrue_margin_and_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate daily margin and fees accrual posting instructions at\\n    the effective datetime\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle daily margin and fees accrual\\n    \\\"\\\"\\\"\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    margin_accrual_date = _get_balance_date_for_margin_accrual(vault)\\n\\n    outstanding_principal = _get_outstanding_actual_principal(vault, margin_accrual_date)\\n\\n    outstanding_accrue = _get_accrued_margin(vault, effective_date)\\n\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    margin_data = _get_daily_margin_accrual(\\n        vault,\\n        outstanding_principal,\\n        outstanding_accrue,\\n        margin_rate,\\n        effective_date,\\n    )\\n\\n    margin_to_accrue = margin_data[\\\"margin_to_accrue\\\"]\\n\\n    posting_instructions = []\\n    if margin_to_accrue > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_accrue,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_MARGIN_ACCRUAL\\\"\\n                f\\\"_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=ACCRUED_MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Daily margin accrued at \\\"\\n                    f\\\"{(margin_rate/DAYS_IN_A_YEAR) * 100:0.6f}\\\",\\n                    \\\"event_type\\\": ACCRUE_MARGIN_AND_FEES,\\n                    \\\"daily_margin_rate\\\": f\\\"{(margin_rate/DAYS_IN_A_YEAR)}\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # Check late repayment fee will get all the overdue addresses and apply\\n    # fee for every overdue installment\\n    posting_instructions.extend(_check_late_repayment_fee(vault, effective_date))\\n\\n    return posting_instructions\\n\\n\\ndef _handle_repayment_due(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate monthly repayment installment which consist of principal due\\n    and margin due\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle repayment day\\n    \\\"\\\"\\\"\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    monthly_due_amounts = _calculate_monthly_payment_margin_and_principal(\\n        vault, margin_rate, effective_date\\n    )\\n    posting_instructions = _get_transfer_due_instructions(\\n        vault=vault,\\n        effective_date=effective_date,\\n        monthly_due_amounts=monthly_due_amounts,\\n        event_type=\\\"CALCULATE_AND_TRANSFER_DUE_AMOUNT\\\",\\n    )\\n\\n    _send_repayment_notification(vault, effective_date, monthly_due_amounts)\\n\\n    return posting_instructions\\n\\n\\ndef _handle_overdue(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Move unpaid due amount to overdue, charge penalty fee\\n    and schedule for delinquency check after grace period\\n    :param vault: parameters, balances\\n    :param effective_date: datetime\\n    :return: list of posting instructions to handle overdue\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    posting_instructions = []\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, PRINCIPAL_DUE, PRINCIPAL_OVERDUE, effective_date)\\n    )\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, MARGIN_DUE, MARGIN_OVERDUE, effective_date)\\n    )\\n    additional_fee = 0\\n    if len(posting_instructions) > 0:\\n        # Add late repayment fee at the first time it's become overdue for 1 installment only\\n        tazir_fee = 0\\n        if _is_apply_tazir_for_overdue(vault, effective_date):\\n            due_balance = vault.modules[\\\"utils\\\"].get_balance_sum(vault, DUE_ADDRESSES)\\n            precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n            eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n            tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                (due_balance * eq_rate / DAYS_IN_A_YEAR), precision\\n            )\\n        post_ins, additional_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, 1, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, additional_fee)\\n\\n    return posting_instructions\\n\\n\\n# Part of repayment day schedule\\ndef _get_transfer_due_instructions(\\n    vault,\\n    effective_date: datetime,\\n    monthly_due_amounts: Dict[str, Decimal],\\n    event_type: str,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Return a list of PostingInstructions to transfer\\n    funds based on the monthly due amounts.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param monthly_due_amount: Dict[str, Decimal]\\n    :param event_type: str\\n    :return list of posting instructions to transfer due and EMI balance\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=2)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n\\n    emi = monthly_due_amounts.get(\\\"emi\\\", Decimal(\\\"0\\\"))\\n    principal_due = monthly_due_amounts.get(\\\"principal_due\\\", Decimal(\\\"0\\\"))\\n    margin_due = monthly_due_amounts.get(\\\"margin_due\\\", Decimal(\\\"0\\\"))\\n\\n    stored_emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n\\n    posting_instructions = []\\n    if emi > 0 and emi != stored_emi:\\n        if stored_emi > 0:\\n            posting_instructions.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=stored_emi,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_STORED_EMI\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=EMI_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": \\\"Clearing stored EMI amount\\\",\\n                        \\\"event\\\": event_type,\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_UPDATE_STORED_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Updating stored EMI amount\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if principal_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=principal_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_PAYMENT_PERIOD_PRINCIPAL_DUE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=PRINCIPAL_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly principal added to due address: {principal_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if margin_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_APPLY_ACCRUED_MARGIN_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly margin added to due address: {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_ACCRUED_MARGIN\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clear accrued margin of : {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _send_repayment_notification(vault, effective_date: datetime, monthly_due: Dict[str, Decimal]):\\n    \\\"\\\"\\\"\\n    Instruct a repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param monthly_due: Dict[str, Decimal], monthly due values\\n    :return: None\\n    \\\"\\\"\\\"\\n    repayment_amount = monthly_due.get(\\\"principal_due\\\", Decimal(\\\"0\\\")) + monthly_due.get(\\n        \\\"margin_due\\\", Decimal(\\\"0\\\")\\n    )\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    overdue_date = effective_date + timedelta(days=int(repayment_period))\\n\\n    vault.instruct_notification(\\n        notification_type=\\\"GOLD_FINANCING_REPAYMENT\\\",\\n        notification_details={\\n            \\\"account_id\\\": vault.account_id,\\n            \\\"repayment_amount\\\": str(repayment_amount),\\n            \\\"overdue_date\\\": str(overdue_date.date()),\\n        },\\n    )\\n\\n\\ndef _process_payment(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower, paying off the balance in different addresses\\n    in the correct order\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str\\n    :return: List[PostingInstruction]\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    repayment_amount_remaining = abs(repayment_amount)\\n    sorted_repayment_addresses = _get_sorted_repayment_addresses(denomination, balances)\\n    repayment_instructions = []\\n    for repayment_order in sorted_repayment_addresses:\\n        sum_repayment_order = vault.modules[\\\"utils\\\"].get_balance_sum(vault, repayment_order)\\n        rounded_address_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n            sum_repayment_order, fulfillment_precision\\n        )\\n        if rounded_address_balance and repayment_amount_remaining > 0:\\n\\n            repayment_amount = min(repayment_amount_remaining, rounded_address_balance)\\n            repayment_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                repayment_amount, fulfillment_precision\\n            )\\n\\n            remaining_amount = 0\\n            for debt_address in repayment_order:\\n                debt_balance = _get_effective_balance_by_address(vault, debt_address)\\n                rounded_debt_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n                    debt_balance, fulfillment_precision\\n                )\\n\\n                proportion_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                    (repayment_amount / rounded_address_balance) * rounded_debt_balance,\\n                    fulfillment_precision,\\n                )\\n                posting_amount = remaining_amount if remaining_amount > 0 else proportion_amount\\n\\n                if proportion_amount > 0:\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"REPAY_{debt_address}_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=DEFAULT_ADDRESS,\\n                            to_account_id=vault.account_id,\\n                            to_account_address=debt_address,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": \\\"REPAYMENT\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n                if (\\n                    _get_parameters_from_finance_address(debt_address)[\\\"address_type\\\"]\\n                    in MARGIN_ADDRESS_TYPES\\n                ):\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"{debt_address}_INCOME_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=INTERNAL_CONTRA,\\n                            to_account_id=margin_income_account,\\n                            to_account_address=DEFAULT_ADDRESS,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": f\\\"{debt_address}_INCOME\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n\\n                # The 2nd sequence of repayment order would has remaining amount\\n                # instead of calculate the portion due to rounding calculate and the balance\\n                # must be 0 at the end of payment process.\\n                remaining_amount = repayment_amount - posting_amount\\n                repayment_amount_remaining -= posting_amount\\n\\n    return repayment_instructions\\n\\n\\ndef _process_early_maturity(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n):\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower for early maturity repayment,\\n    paying off the balance in different addresses\\n    in the correct order\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime , date and time of hook being run\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str, base client_transaction_id to be extended with event\\n    information\\n    :return: None\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    repayment_instructions = []\\n\\n    repayment_instructions.extend(\\n        _process_payment(vault, effective_date, repayment_amount, client_transaction_id)\\n    )\\n    # get balances\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, [PRINCIPAL], effective_date\\n    )\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], effective_date)\\n    margin_to_paid = _calculate_early_maturity_margin_to_be_paid(vault, effective_date)\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS], effective_date)\\n    muqasah_amount = _calculate_muqasah_amount(vault, effective_date)\\n\\n    # get internal account\\n    muqasah_payable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=MUQASAH_PAYABLE_ACCOUNT\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    # repay outstanding principal\\n    if outstanding_principal > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_principal,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                    f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # record margin as income\\n    if outstanding_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{INTERNAL_CONTRA}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=margin_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_paid,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MARGIN}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {margin_to_paid} from {MARGIN}, \\\"\\n                    f\\\"which was at {margin_to_paid} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # clear EMI\\n    if emi > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {MARGIN}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"{ACCRUE_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # discount on margin\\n    if muqasah_amount > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=muqasah_amount,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MUQASAH_PAYABLE_ACCOUNT}_WRITEOFF_{client_transaction_id}\\\",\\n                from_account_id=muqasah_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Writing off {muqasah_amount} from {MUQASAH_PAYABLE_ACCOUNT}, \\\"\\n                    f\\\"which was at {muqasah_amount} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{MARGIN}_WRITEOFF\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return repayment_instructions\\n\\n\\ndef _get_next_repayment_day_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next repayment day schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of REPAYMENT_SCHEDULE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(repayment_schedule_date)\\n\\n\\ndef _get_initial_monthly_schedule(vault) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the initial repayment day and check overdue schedule\\n\\n    :param vault: Vault object\\n    :return: tuple, representation of initial REPAYMENT_SCHEDULE and CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    first_overdue_date = _get_overdue_schedule(vault, first_repayment_date)\\n\\n    first_repayment_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_repayment_date\\n    )\\n    first_overdue_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_overdue_date\\n    )\\n\\n    return {\\n        REPAYMENT_DAY_SCHEDULE: first_repayment_schedule,\\n        CHECK_OVERDUE: first_overdue_schedule,\\n    }\\n\\n\\n# Overdue helper functions\\ndef _get_overdue_postings(\\n    vault, due_address: str, overdue_address: str, effective_date: datetime\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Instruct posting instructions to move balance between due and overdue address\\n    :param vault: Vault object\\n    :param due_address: str, due address balance name\\n    :param overdue_address: str, overdue address balance name\\n    :param effective_date: datetime\\n    :return list of posting instructions which moves due to overdue\\n    \\\"\\\"\\\"\\n    amount_to_transfer = _get_effective_balance_by_address(vault, due_address)\\n\\n    if amount_to_transfer == 0:\\n        return []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    current_month_index = _get_current_term_index(vault, effective_date)\\n\\n    return vault.make_internal_transfer_instructions(\\n        amount=amount_to_transfer,\\n        denomination=denomination,\\n        client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + overdue_address,\\n        from_account_id=vault.account_id,\\n        from_account_address=f\\\"{overdue_address}_{current_month_index}\\\",\\n        to_account_id=vault.account_id,\\n        to_account_address=due_address,\\n        instruction_details={\\n            \\\"description\\\": f\\\"Mark outstanding due amount of \\\"\\n            f\\\"{amount_to_transfer} as {overdue_address}_{current_month_index}.\\\",\\n            \\\"event\\\": \\\"MOVE_BALANCE_INTO_\\\" + overdue_address,\\n        },\\n        asset=DEFAULT_ASSET,\\n        override_all_restrictions=True,\\n    )\\n\\n\\ndef _check_late_repayment_fee(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Check if there are overdue balance in the account, then it will instruct\\n    posting to accruing the daily late repaymet fee\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to apply daily late repayment fee\\n    \\\"\\\"\\\"\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tazir_period = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAZIR_PERIOD))\\n    maximum_dpd = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=MAXIMUM_DPD))\\n    overdue_addresses = _get_sorted_overdue_addresses(denomination, balances)\\n    tawidh_number = 0\\n    tazir_fee = 0\\n    posting_instructions = []\\n\\n    if len(overdue_addresses) > 0:\\n        # Check the latest overdue bucket balance for applying tazir fee\\n        check_overdue_last_execution = vault.get_last_execution_time(event_type=CHECK_OVERDUE)\\n        latest_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_addresses[0])\\n        if check_overdue_last_execution and latest_overdue_bucket > 0:\\n            is_accrue_tazir = _is_apply_tazir_for_overdue(vault, check_overdue_last_execution)\\n            dpd_number = _calculate_days_past_due(vault, overdue_addresses[0], effective_date)\\n            if dpd_number == maximum_dpd:\\n                # If the account has days past due equal to 90 days, then it will\\n                # send notification to mark the account as deliquent\\n                _send_deliquent_notification(vault, effective_date)\\n            if is_accrue_tazir and dpd_number <= tazir_period:\\n                emi_amount = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n                tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                    ((eq_rate / DAYS_IN_A_YEAR) * emi_amount), precision\\n                )\\n\\n        # Apply ta'widh fee for each overdue installment\\n        for overdue_bucket in overdue_addresses:\\n            sum_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_bucket)\\n            if sum_overdue_bucket > 0:\\n                tawidh_number += 1\\n\\n    total_fee = 0\\n    if tawidh_number > 0 or tazir_fee > 0:\\n        post_ins, total_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, tawidh_number, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, total_fee)\\n\\n    return posting_instructions\\n\\n\\ndef _get_late_repayment_fee_postings(\\n    vault, effective_date: datetime, tawidh_number: int, tazir_fee: Decimal\\n) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Get daily late repayment fee posting as it's overdue\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param tawidh_number: int, the number of tawidh fee will be applied\\n    :param tazir_fee: Decimal, the amount of tazir fee will be applied\\n    :return list of posting instructions to apply late repayment fee\\n    and total fee amount being charged\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_instructions = []\\n    tawidh_fee = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAWIDH_FEE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tawidh_fee = vault.modules[\\\"utils\\\"].round_decimal((tawidh_fee * tawidh_number), precision)\\n    tawidh_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAWIDH_FEE_INCOME_ACCOUNT\\n    )\\n    tazir_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAZIR_FEE_INCOME_ACCOUNT\\n    )\\n    if tawidh_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tawidh_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAWIDH_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAWIDH_ADDRESS,\\n                to_account_id=tawidh_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'widh fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAWIDH_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if tazir_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tazir_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAZIR_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAZIR_ADDRESS,\\n                to_account_id=tazir_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'zir fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAZIR_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    total_fee = tawidh_fee + tazir_fee\\n    return posting_instructions, total_fee\\n\\n\\ndef _is_apply_tazir_for_overdue(vault, effective_date: datetime) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the previous month has no overdue or the overdue installment has been\\n    already repay\\n\\n    :param vault: Vault object,\\n    :param effective_date: datetime,\\n    :return boolean to indicates applying tazir\\n    \\\"\\\"\\\"\\n\\n    previous_installment_no = str(_get_current_term_index(vault, effective_date) - 1)\\n    if int(previous_installment_no) < 1:\\n        return True\\n    overdue_bucket = [\\n        PRINCIPAL_OVERDUE + \\\"_\\\" + previous_installment_no,\\n        MARGIN_OVERDUE + \\\"_\\\" + previous_installment_no,\\n    ]\\n\\n    current_overdue_balance = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, overdue_bucket, effective_date\\n    )\\n\\n    if current_overdue_balance == 0:\\n        return True\\n\\n    return False\\n\\n\\ndef _get_next_check_overdue_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next check overdue schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n    next_overdue_schedule = _get_overdue_schedule(vault, repayment_schedule_date)\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_overdue_schedule)\\n\\n\\ndef _send_overdue_repayment_notification(vault, effective_date: datetime, additional_fee: Decimal):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param additional_fee: Decimal, additional fee added to outstanding due\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"repayment_amount\\\": str(outstanding_dues + additional_fee),\\n                \\\"overdue_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _send_deliquent_notification(vault, effective_date: datetime):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_DELIQUENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"deliquent_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _get_current_term_index(vault, effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    The value returned is the index of current month that effective date is currently\\n    in on the scale form 1 to loan tenor. Hence it is equal to the number of passed repayment due\\n    days\\n    \\\"\\\"\\\"\\n    tenor = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, tenor)\\n\\n    return tenor - remaining_term\\n\\n\\n# Calculate helper functions\\ndef _calculate_monthly_instalment(\\n    outstanding_principal: Decimal, margin_rate: Decimal, total_term: int\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly installment amount at outstanding principal\\n\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :param total_term: int\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return (outstanding_principal * margin_rate / 12) / (\\n        1 - ((1 + (margin_rate / 12)) ** (-total_term))\\n    )\\n\\n\\ndef _calculate_monthly_margin(\\n    vault,\\n    precision: int,\\n    outstanding_principal: Decimal,\\n    margin_rate: Decimal,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly margin amount at outstanding principal\\n\\n    :param vault: Vault object\\n    :param precision: int\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * margin_rate / 12), precision\\n    )\\n\\n\\ndef _calculate_next_repayment_date(vault, effective_date: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, GOLD_FINANCING_START_DATE\\n    )\\n\\n    last_execution_time = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n\\n    # Localizing effective date to WIB timezone for calculation of next repayment date\\n    localized_effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    repayment_day = gold_financing_start_date.day\\n\\n    if first_repayment_date:\\n        next_payment_date = first_repayment_date + timedelta(\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        if next_payment_date > localized_effective_date:\\n            return next_payment_date\\n        else:\\n            repayment_day = first_repayment_date.day\\n\\n    earliest_event_start_date = gold_financing_start_date + timedelta(days=1)\\n\\n    if last_execution_time:\\n        # Localizing repayment schedule last execution time\\n        # to WIB timezone for calculation of next repayment date\\n        localized_last_execution_time = last_execution_time + timedelta(hours=WIB_UTC_OFFSET)\\n        while localized_last_execution_time <= localized_effective_date:\\n            localized_last_execution_time += timedelta(months=1)\\n\\n        next_payment_date = localized_last_execution_time + timedelta(\\n            day=repayment_day,\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        return next_payment_date\\n\\n    next_payment_date = localized_effective_date + timedelta(\\n        day=repayment_day,\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    if (\\n        next_payment_date <= localized_effective_date\\n        or next_payment_date <= earliest_event_start_date\\n    ):\\n        next_payment_date += timedelta(months=1)\\n\\n    return next_payment_date\\n\\n\\ndef _calculate_first_repayment_date(vault) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate first repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    if first_repayment_date is None:\\n        gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, GOLD_FINANCING_START_DATE\\n        )\\n        first_repayment_date = gold_financing_start_date + timedelta(months=1)\\n\\n    first_repayment_date = first_repayment_date + timedelta(\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    return first_repayment_date\\n\\n\\ndef _calculate_early_maturity_margin_to_be_paid(\\n    vault,\\n    timestamp: datetime,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the amount of margin that must be paid during the early maturity repayment process\\n    The formula is :\\n        (Outstanding Principal * early maturity margin rate) + accrued margin\\n    The amount of margin that must be paid should be less than or equal the outstanding margin\\n    :param vault: Vault Object to get the parameter and balance of current the account\\n    :param timestamp: timestamp of the balance to check\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    early_maturity_margin_percentage = Decimal(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, EARLY_MATURITY_MARGIN)\\n    )\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    expected_margin_to_be_paid = vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * early_maturity_margin_percentage) + accrued_margin,\\n        fulfillment_precision,\\n    )\\n\\n    return min(expected_margin_to_be_paid, outstanding_margin)\\n\\n\\ndef _calculate_early_maturity_repayment_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the value of the payment that must be made to make early maturity posting\\n    The Formula is :\\n        Outstanding Principal + Margin amount to be Paid + All outstanding Due\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n    all_outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal + margin_amount_to_be_paid + all_outstanding_due,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _calculate_muqasah_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Return the discount amount (Muqasah) that applies to early maturity repayment\\n    The Formula is :\\n        outstanding_margin - Margin amount to be Paid\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_margin - margin_amount_to_be_paid,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _create_margin_remainder_posting(\\n    vault,\\n    margin_address: str,\\n    actual_balance: Decimal,\\n    rounded_balance: Decimal,\\n    event_type: str,\\n    denomination: str,\\n    include_address_in_client_transaction_id: bool = False,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Creates and returns posting instructions for handling remainder on MARGIN address due to\\n    any difference in accrual and fulfilment precision.\\n    If positive, margin was rounded down and exra margin was charged to customer.\\n    If negative, margin was rounded up and extra margin was returned to customer.\\n\\n    :param vault: Vault object\\n    :param margin_address: str, margin address on which to handle remainder\\n    :param actual_balance: Decimal, margin balance amount prior to application\\n    :param rounded_balance: Decimal, rounded margin amount that was applied\\n    :param event_type: str, event which triggered the margin application\\n    :param denomination: str, denomination used for account\\n    :param include_address_in_client_transaction_id: bool, if True then we include the address\\n    when constructing the client transaction id, to ensure uniqueness.\\n    :return: list of posting instructions to handle margin remainder\\n    \\\"\\\"\\\"\\n    hook_execution_id = vault.get_hook_execution_id()\\n    margin_remainder = actual_balance - rounded_balance\\n    margin_remainder_postings = []\\n    if include_address_in_client_transaction_id:\\n        client_transaction_id = (\\n            f\\\"{event_type}_{margin_address}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n        )\\n    else:\\n        client_transaction_id = f\\\"{event_type}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n    if margin_remainder < 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=margin_address,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin charged to customer from negative remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded up\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n    elif margin_remainder > 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=margin_address,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin returned to customer from positive remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded down\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n\\n    return margin_remainder_postings\\n\\n\\ndef _calculate_monthly_payment_margin_and_principal(\\n    vault,\\n    annual_margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Dict[str, Decimal]:\\n    \\\"\\\"\\\" \\\"\\n    Calculate emi, accrued margin, margin due and principal due\\n\\n    :param vault: Vault object\\n    :param annual_margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return Dict[str,Decimal]\\n    \\\"\\\"\\\"\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    actual_principal = _get_outstanding_actual_principal(vault)\\n\\n    principal = vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL)\\n    total_term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n\\n    margin_due = _calculate_monthly_margin(\\n        vault, fulfillment_precision, actual_principal, annual_margin_rate\\n    )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    emi = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, annual_margin_rate, total_term),\\n        fulfillment_precision,\\n    )\\n    principal_due = emi - margin_due\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, total_term)\\n    if remaining_term <= 1:\\n        principal_due = actual_principal\\n        margin_due = _get_effective_balance_by_address(vault, MARGIN)\\n\\n    return {\\n        \\\"emi\\\": emi,\\n        \\\"margin_due\\\": margin_due,\\n        \\\"accrued_margin\\\": accrued_margin,\\n        \\\"principal_due\\\": principal_due,\\n    }\\n\\n\\ndef _calculate_days_past_due(vault, overdue_address: List[str], effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculate the number of days past since the overdue\\n\\n    :param vault: Vault object\\n    :param overdue_address: List[str], list of overdue address pair\\n    :param effective_date: datetime\\n    :return the number of days past since overdue\\n    \\\"\\\"\\\"\\n\\n    installment_number = int(overdue_address[0].split(\\\"_\\\")[-1])\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n    diff_month = installment_number - 1\\n    installment_overdue_date = first_repayment_date + timedelta(months=diff_month)\\n\\n    dpd = (effective_date - installment_overdue_date).days + 1\\n\\n    return dpd\\n\\n\\n# Posting retrieval helper functions\\ndef _get_posting_amount(posting: PostingInstruction, include_pending_out: bool = True) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction\\n\\n    :param posting: PostingInstruction\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\ndef _get_posting_batch_amount(\\n    posting: PostingInstructionBatch, denomination: str, include_pending_out: bool = False\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction batch\\n\\n    :param posting: PostingInstructionBatch\\n    :param denomination: str\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\n# Margin helper functions\\ndef _get_daily_margin_accrual(\\n    vault,\\n    outstanding_principal: Decimal,\\n    outstanding_accrue: Decimal,\\n    margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Tuple[str, Dict[str, str]]:\\n\\n    \\\"\\\"\\\"\\n    Get the amount of daily margin accrual will calculate the\\n    corresponding margin at the effective date\\n\\n    :param outstanding_principal: Decimal\\n    :param outstanding_accrue: Decimal\\n    :param margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return: Tuple[str, Dict[str, str]], representation of\\n    margin to accrue, total days, and next repayment date\\n    \\\"\\\"\\\"\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=ACCRUAL_PRECISION))\\n    term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n    outstanding_margin = _get_effective_balance_by_address(vault, MARGIN, effective_date)\\n    next_payment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    monthly_margin = vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal * margin_rate * Decimal(DAYS_IN_A_MONTH / DAYS_IN_A_YEAR), precision\\n    )\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, term)\\n    total_days = (next_payment_date - effective_date).days + 1\\n\\n    # Adjustment on the last margin accrual at a day before maturity\\n    if outstanding_margin < outstanding_accrue:\\n        return {\\n            \\\"margin_to_accrue\\\": outstanding_margin,\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n    if remaining_term <= 1 and total_days <= 1:\\n        return {\\n            \\\"margin_to_accrue\\\": vault.modules[\\\"utils\\\"].round_decimal(\\n                outstanding_margin - outstanding_accrue, precision\\n            ),\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n\\n    margin_accrual = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_margin - outstanding_accrue) / total_days, precision\\n    )\\n\\n    if margin_accrual < 0:\\n        margin_accrual = 0\\n\\n    return {\\n        \\\"margin_to_accrue\\\": margin_accrual,\\n        \\\"total_days\\\": total_days,\\n        \\\"next_repayment_date\\\": next_payment_date,\\n    }\\n\\n\\ndef _get_accrued_margin(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [ACCRUED_MARGIN], timestamp)\\n\\n\\ndef _get_accrue_margin_and_fees_schedule(\\n    vault, gold_financing_start_date: datetime\\n) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get daily margin and fees accrual schedule dict\\n\\n    :param vault: Vault object\\n    :param gold_financing_start_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    gold_financing_start_date_plus_day = gold_financing_start_date + timedelta(days=1)\\n\\n    accrue_margin_schedule = {\\n        \\\"hour\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_HOUR)),\\n        \\\"minute\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_MINUTE)),\\n        \\\"second\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_SECOND)),\\n        \\\"start_date\\\": str(gold_financing_start_date_plus_day),\\n    }\\n\\n    return accrue_margin_schedule\\n\\n\\n# Time calculation and schedule helper functions\\ndef _get_expected_remaining_term(vault, effective_date: datetime, term: int) -> int:\\n    \\\"\\\"\\\"\\n    The remaining term according to the natural end date of the gold financing.\\n\\n    :param vault\\n    :param effective_date : datetime\\n    return: int\\n    \\\"\\\"\\\"\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date += timedelta(hours=WIB_UTC_OFFSET)\\n\\n    if effective_date < first_repayment_date:\\n        remaining_term = timedelta(months=term)\\n    else:\\n        remaining_term = timedelta(first_repayment_date.date(), effective_date.date()) + timedelta(\\n            months=term\\n        )\\n\\n    if effective_date + remaining_term < effective_date + timedelta(months=1):\\n        return 0\\n    else:\\n        # negative days should reduce term by up to 1 month\\n        rounded_month = -1 if remaining_term.days < 0 else 0\\n        return remaining_term.years * 12 + remaining_term.months + rounded_month\\n\\n\\ndef _get_next_schedule_date(\\n    start_date: datetime, schedule_frequency: str, intended_day: int\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next valid date for schedule based on required frequency and day of month.\\n    Falls to last valid day of month if intended day is not in calculated month\\n    :param start_date: datetime, from which schedule frequency is calculated from\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :param intended_day: int, day of month the scheduled date should fall on\\n    :return: datetime, next occurrence of schedule\\n    \\\"\\\"\\\"\\n\\n    if start_date + timedelta(day=intended_day) > start_date:\\n        next_schedule_date = start_date + timedelta(day=intended_day)\\n    else:\\n        next_schedule_date = start_date + timedelta(months=1, day=intended_day)\\n    return next_schedule_date\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _get_overdue_schedule(vault, effective_date: datetime) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get check overdue schedule dict\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    repayment_period_end = effective_date + timedelta(days=int(repayment_period))\\n\\n    overdue_hour = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_HOUR))\\n    overdue_minute = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_MINUTE))\\n    overdue_second = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_SECOND))\\n\\n    check_overdue_datetime = repayment_period_end.replace(\\n        hour=overdue_hour,\\n        minute=overdue_minute,\\n        second=overdue_second,\\n    )\\n\\n    return check_overdue_datetime\\n\\n\\n# Balance helper functions\\ndef _get_expected_emi(vault, effective_date: datetime) -> Decimal:\\n    emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n    if emi == 0:\\n        margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n        amount_due = _calculate_monthly_payment_margin_and_principal(\\n            vault, margin_rate, effective_date\\n        )\\n        emi = amount_due.get(\\\"emi\\\", Decimal(\\\"0\\\")) if amount_due is not None else Decimal(\\\"0\\\")\\n\\n    return emi\\n\\n\\ndef _get_all_outstanding(vault, timestamp: datetime = None) -> Decimal:\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (\\n            vault.modules[\\\"utils\\\"].get_balance_sum(\\n                vault,\\n                [PRINCIPAL, MARGIN],\\n                timestamp,\\n            )\\n            + outstanding_due\\n        ),\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _sum_outstanding_dues(vault, timestamp: datetime = None) -> Decimal:\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    overdue_address = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n    all_outstanding = overdue_address + FEES_ADDRESSES + DUE_ADDRESSES\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, all_outstanding, timestamp)\\n\\n\\ndef _get_balance_date_for_margin_accrual(vault) -> datetime:\\n    last_repayment_due_date = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n    # If there hasn't been a repayment event, use balances from gold financing start date\\n    if last_repayment_due_date is None:\\n        last_repayment_due_date = vault.get_account_creation_date()\\n\\n    # Effective date of the transfer postings is 2 microseconds after repayment due event\\n    return last_repayment_due_date + timedelta(microseconds=1)\\n\\n\\ndef _get_effective_balance_by_address(vault, address: str, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [address], timestamp)\\n\\n\\ndef _get_outstanding_actual_principal(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n\\ndef _get_sorted_repayment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to repayment hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older,\\n    the repayment hierarchy:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n    TAWIDH\\n    TAZIR\\n    DUE_PRINCIPAL\\n    DUE_MARGIN\\n    PRINCIPAL\\n    MARGIN\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    sorted_repayment_addresses = sorted_all_overdue_addresses + REPAYMENT_DUES_ORDER\\n    return sorted_repayment_addresses\\n\\n\\ndef _get_sorted_overdue_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to overdue hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older, overdue order:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    return sorted_all_overdue_addresses\\n\\n\\ndef _get_all_instalment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n    address_types: List[str],\\n) -> Dict[str, List[str]]:\\n    \\\"\\\"\\\"\\n    Gets all financing addresses for address types listed in address_types.\\n    Valid address types: PRINCIPAL, INTEREST, DUE_PRINCIPAL, DUE_INTEREST, OVERDUE_PRINCIPAL,\\n                         OVERDUE_INTEREST\\n    \\\"\\\"\\\"\\n    addresses = {address_type: [] for address_type in address_types}\\n    for balance_dimension in balances.keys():\\n        address = balance_dimension[0]\\n        if (\\n            address\\n            not in [\\n                DEFAULT_ADDRESS,\\n                ACCRUED_MARGIN,\\n                INTERNAL_CONTRA,\\n            ]\\n            and balances[(address, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        ):\\n            address_type = address[0 : len(address) - 2]\\n            if address_type in addresses:\\n                addresses[address_type].append(address)\\n    return addresses\\n\\n\\ndef _sort_addresses_list(addresses_list: List[str], repayment_order: Dict[str, int]) -> List[str]:\\n    \\\"\\\"\\\"\\n    Returns a list of sorted addresses, based on provided list and respecting address types in\\n    repayment_order.\\n\\n    Sorts by installment_no, then address type (order defined in repayment_order).\\n    \\\"\\\"\\\"\\n\\n    sorted_addresses_list = sorted(\\n        sorted(\\n            addresses_list,\\n            key=lambda address: repayment_order[\\n                _get_parameters_from_finance_address(address)[\\\"address_type\\\"]\\n            ],\\n        ),\\n        key=lambda address: _get_parameters_from_finance_address(address)[\\\"installment_no\\\"],\\n    )\\n\\n    address_list = [\\n        {\\n            \\\"address\\\": address,\\n            \\\"installment_no\\\": _get_parameters_from_finance_address(address).get(\\\"installment_no\\\"),\\n        }\\n        for address in sorted_addresses_list\\n    ]\\n\\n    address_dict = {}\\n    for data in address_list:\\n        installment_no = data[\\\"installment_no\\\"]\\n        address = [data[\\\"address\\\"]]\\n        if installment_no not in address_dict:\\n            address_dict[installment_no] = address\\n        else:\\n            address_dict[installment_no].append(data[\\\"address\\\"])\\n\\n    return list(address_dict.values())\\n\\n\\ndef _get_parameters_from_finance_address(address: str) -> Dict[str, Union[str, int, Decimal]]:\\n    \\\"\\\"\\\"\\n    Gets all financing parameters from a given financing address.\\n    \\\"\\\"\\\"\\n    if len(address.split(\\\"_\\\")) > 2:\\n        address_type = address[0 : len(address) - 2]\\n        installment_no = address.split(\\\"_\\\")[-1]\\n    else:\\n        address_type = address\\n        installment_no = \\\"0\\\"\\n    return {\\n        \\\"address_type\\\": address_type,\\n        \\\"installment_no\\\": installment_no,\\n    }\\n\\n\\n# Generic helper functions\\ndef _instruct_posting_batch(\\n    vault,\\n    posting_instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if posting_instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param posting_instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if posting_instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"repayment_period\": \"1\",\n                \"fulfillment_precision\": \"2\",\n                \"accrual_precision\": \"2\",\n                \"equivalent_rate\": \"0.09\",\n                \"check_overdue_hour\": \"0\",\n                \"check_overdue_minute\": \"1\",\n                \"check_overdue_second\": \"1\",\n                \"accrue_margin_second\": \"0\",\n                \"accrue_margin_hour\": \"0\",\n                \"accrue_margin_minute\": \"1\",\n                \"disbursement_account\": \"DISBURSEMENT_ACCOUNT\",\n                \"settlement_account\": \"SETTLEMENT_ACCOUNT\",\n                \"repayment_hour\": \"0\",\n                \"repayment_minute\": \"1\",\n                \"repayment_second\": \"1\",\n                \"margin_income_account\": \"MARGIN_INCOME_ACCOUNT\",\n                \"tawidh_fee\": \"2000\",\n                \"tawidh_fee_income_account\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"early_maturity_margin\": \"0.02\",\n                \"muqasah_payable_account\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"tazir_fee_income_account\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"tazir_period\": \"10\",\n                \"maximum_dpd\": \"90\"\n            },\n            \"smart_contract_version_id\": \"0\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8106844284241980553\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6269843295464630220\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"5435469535034448449\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"3482164331482806391\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"4109182332321470620\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"1725802977839375744\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"29283285039565751\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"3e73e7c7-1fbf-4a17-9769-50065ef829ff\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SUSPENSE_ACCOUNT\",\n                \"product_version_id\": \"8106844284241980553\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"DISBURSEMENT_ACCOUNT\",\n                \"product_version_id\": \"6269843295464630220\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SETTLEMENT_ACCOUNT\",\n                \"product_version_id\": \"5435469535034448449\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MARGIN_INCOME_ACCOUNT\",\n                \"product_version_id\": \"3482164331482806391\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"4109182332321470620\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"product_version_id\": \"1725802977839375744\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"29283285039565751\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_0\",\n                \"smart_contract_version_id\": \"0\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"3e73e7c7-1fbf-4a17-9769-50065ef829ff\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"product_version_id\": \"0\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"principal\": \"8000000\",\n                    \"total_term\": \"12\",\n                    \"gold_financing_start_date\": \"2022-01-20\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-02-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"3a91dae3-28b2-4b6f-927a-188ac2e4e163\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"11097600-b0c8-4647-af7d-b4255fa414d8\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-02-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-03-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"8fc58d66-6bd7-465f-beb4-49ed40762d6c\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"594c41a0-16b8-4891-acb0-04895ce0ff4b\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-03-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-04-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"d2c9e0a3-d170-4b1c-926f-524a8e8db2b8\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"b1b08ee0-560d-42ae-85fa-898f6949b476\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-04-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-05-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"e5d3c42b-f586-4b52-93f5-f2db25f03990\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"88986def-0c71-4d2e-a7e5-17fa1456dc60\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-05-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-06-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"7a27928f-8f08-4f5b-94d0-0d2f5b7ab136\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"4790895b-326e-49d1-a730-164213888c8f\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-06-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-07-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"18cb19a6-9899-47d9-ab40-06725d803ddc\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"3d923624-7f68-46e1-bf78-eef25581d05e\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-07-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-08-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"24ce975f-95a7-4731-9352-c5c8963745ba\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"63c8fba7-1473-4092-ab9d-86e377ec3c18\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-08-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-09-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"a9991e8e-642a-4ab6-8cd5-3378e2ff8094\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"78d7a30d-d3ae-4d7a-a221-934b82cd9193\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-09-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-10-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"77f0d2bc-f92d-4d75-a3fb-7280d3672298\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"ef9d8c86-d042-40eb-bcab-d5a14064999e\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-10-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-11-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"0d417ee9-3136-42a7-b74d-11abbc0d16a8\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"487fdded-f425-4eb6-82eb-eb8236cd71e2\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-11-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-12-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"f30c13fd-8d7f-4ea7-9b3f-ed7e1bcf137c\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"791e457c-de19-480d-876c-1903dac6c692\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-12-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2023-01-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"30ed21f8-30b1-4b71-a72d-523a43170bba\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"de0d9746-9c15-4f6f-b844-b449c7c1feb3\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2023-01-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2023-01-20T00:05:00+00:00\",\n            \"update_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"status\": \"ACCOUNT_STATUS_PENDING_CLOSURE\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				},
				{
					"name": "Gold Financing - Demo Early Maturity",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"GOLD_FINANCING_ACCOUNT\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{sa_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-20T00:00:00+00:00\",\n    \"end_timestamp\": \"2022-06-30T02:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.8\\\"\\ndisplay_name = \\\"Gold Financing\\\"\\nsummary = \\\"A financing product based on akad Murabaha from BCA Syariah \\\"\\n\\\"which aims for Logam Mulia (Gold) ownership using Sharia principles\\\"\\ntside = Tside.ASSET\\n\\n# Time zone offset constants\\nWIB_UTC_OFFSET = 0\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\nnotification_types = [\\n    \\\"GOLD_FINANCING_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_DELIQUENT\\\",\\n]\\n\\n# Schedule events\\nACCRUE_MARGIN_AND_FEES = \\\"ACCRUE_MARGIN_AND_FEES\\\"\\nREPAYMENT_DAY_SCHEDULE = \\\"REPAYMENT_DAY_SCHEDULE\\\"\\nCHECK_OVERDUE = \\\"CHECK_OVERDUE\\\"\\n\\n# Posting events\\nREPAYMENT_EVENT = \\\"REPAYMENT\\\"\\nSETTLEMENT_EVENT = \\\"SETTLEMENT\\\"\\n\\nevent_types_groups = [\\n    EventTypesGroup(\\n        name=\\\"MARGIN\\\",\\n        event_types_order=[ACCRUE_MARGIN_AND_FEES, REPAYMENT_DAY_SCHEDULE, CHECK_OVERDUE],\\n    ),\\n]\\nevent_types = [\\n    EventType(\\n        name=ACCRUE_MARGIN_AND_FEES,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_ACCRUE_MARGIN_AND_FEES_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=REPAYMENT_DAY_SCHEDULE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_REPAYMENT_DAY_SCHEDULE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=CHECK_OVERDUE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_CHECK_OVERDUE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n]\\n\\n# Product Params\\nDENOMINATION = \\\"denomination\\\"\\nEQUIVALENT_RATE = \\\"equivalent_rate\\\"\\nEARLY_MATURITY_MARGIN = \\\"early_maturity_margin\\\"\\nREPAYMENT_PERIOD = \\\"repayment_period\\\"\\nACCRUAL_PRECISION = \\\"accrual_precision\\\"\\nFULFILLMENT_PRECISION = \\\"fulfillment_precision\\\"\\n\\n# Fees\\nTAWIDH_FEE = \\\"tawidh_fee\\\"\\n\\n# Periods\\nTAZIR_PERIOD = \\\"tazir_period\\\"\\nMAXIMUM_DPD = \\\"maximum_dpd\\\"\\n\\n# Schedule Params\\nACCRUE_MARGIN_HOUR = \\\"accrue_margin_hour\\\"\\nACCRUE_MARGIN_MINUTE = \\\"accrue_margin_minute\\\"\\nACCRUE_MARGIN_SECOND = \\\"accrue_margin_second\\\"\\nCHECK_OVERDUE_HOUR = \\\"check_overdue_hour\\\"\\nCHECK_OVERDUE_MINUTE = \\\"check_overdue_minute\\\"\\nCHECK_OVERDUE_SECOND = \\\"check_overdue_second\\\"\\nREPAYMENT_HOUR = \\\"repayment_hour\\\"\\nREPAYMENT_MINUTE = \\\"repayment_minute\\\"\\nREPAYMENT_SECOND = \\\"repayment_second\\\"\\n\\n# Instance Params\\nGOLD_FINANCING_PRINCIPAL = \\\"principal\\\"\\nTOTAL_TERM = \\\"total_term\\\"\\nFIRST_REPAYMENT_DATE = \\\"first_repayment_date\\\"\\nGOLD_FINANCING_START_DATE = \\\"gold_financing_start_date\\\"\\n\\nINSTANCE_PARAMS = [\\n    GOLD_FINANCING_PRINCIPAL,\\n    TOTAL_TERM,\\n    FIRST_REPAYMENT_DATE,\\n    GOLD_FINANCING_START_DATE,\\n]\\n\\n# Derived Params\\nTOTAL_OUTSTANDING = \\\"total_outstanding\\\"\\nGOLD_FINANCING_REMAINING_PRINCIPAL = \\\"gold_financing_remaining_principal\\\"\\nOUTSTANDING_PAYMENTS = \\\"outstanding_payments\\\"\\nREMAINING_TERM = \\\"remaining_term\\\"\\nEXPECTED_EMI = \\\"expected_emi\\\"\\nNEXT_REPAYMENT_DATE = \\\"next_repayment_date\\\"\\nNEXT_OVERDUE_DATE = \\\"next_overdue_date\\\"\\nEARLY_MATURITY_REPAYMENT_AMOUNT = \\\"early_maturity_repayment_amount\\\"\\n\\n# Internal Accounts\\nSUSPENSE_ACCOUNT = \\\"supense_account\\\"\\nDISBURSEMENT_ACCOUNT = \\\"disbursement_account\\\"\\nSETTLEMENT_ACCOUNT = \\\"settlement_account\\\"\\nMARGIN_INCOME_ACCOUNT = \\\"margin_income_account\\\"\\nTAWIDH_FEE_INCOME_ACCOUNT = \\\"tawidh_fee_income_account\\\"\\nMUQASAH_PAYABLE_ACCOUNT = \\\"muqasah_payable_account\\\"\\nTAZIR_FEE_INCOME_ACCOUNT = \\\"tazir_fee_income_account\\\"\\n\\n\\n# Financing Addresses\\nOVERPAYMENT = \\\"OVERPAYMENT\\\"\\nEMI_ADDRESS = \\\"EMI\\\"\\nPRINCIPAL_DUE = \\\"PRINCIPAL_DUE\\\"\\nMARGIN_DUE = \\\"MARGIN_DUE\\\"\\nACCRUED_MARGIN = \\\"ACCRUED_MARGIN\\\"\\nPRINCIPAL = \\\"PRINCIPAL\\\"\\nMARGIN = \\\"MARGIN\\\"\\nPRINCIPAL_OVERDUE = \\\"PRINCIPAL_OVERDUE\\\"\\nMARGIN_OVERDUE = \\\"MARGIN_OVERDUE\\\"\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nTAWIDH_ADDRESS = \\\"TAWIDH\\\"\\nTAZIR_ADDRESS = \\\"TAZIR\\\"\\n\\n# Days calculation\\nDAYS_IN_A_WEEK = 7\\nDAYS_IN_A_MONTH = 30\\nDAYS_IN_A_YEAR = 360\\nWEEKS_IN_YEAR = 52\\nMONTHS_IN_A_YEAR = 12\\n\\n# Repayment Order\\nOVERDUE_ADDRESSES = [PRINCIPAL_OVERDUE, MARGIN_OVERDUE]\\nMARGIN_ADDRESSES = [MARGIN_DUE, MARGIN_OVERDUE]\\nDUE_ADDRESSES = [PRINCIPAL_DUE, MARGIN_DUE]\\nFEES_ADDRESSES = [TAWIDH_ADDRESS, TAZIR_ADDRESS]\\n\\nOVERDUE_ORDER = {\\n    PRINCIPAL_OVERDUE: 0,\\n    MARGIN_OVERDUE: 1,\\n}\\n\\nREPAYMENT_DUES_ORDER = [FEES_ADDRESSES] + [DUE_ADDRESSES]\\n\\nOVERDUE_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    PRINCIPAL_DUE,\\n    MARGIN_OVERDUE,\\n    PRINCIPAL_OVERDUE,\\n]\\n\\nMARGIN_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    MARGIN_OVERDUE,\\n]\\n\\n# Parameter Shape\\nRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nparameters = [\\n    # Instance Parameters\\n    Parameter(\\n        name=TOTAL_TERM,\\n        shape=NumberShape(min_value=Decimal(12), max_value=Decimal(60), step=Decimal(1)),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed length of the gold financing (in months).\\\",\\n        display_name=\\\"Loan term (months)\\\",\\n        default_value=Decimal(12),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_PRINCIPAL,\\n        shape=NumberShape(\\n            min_value=Decimal(1),\\n            max_value=Decimal(300000000),\\n            step=Decimal(1),\\n            kind=NumberKind.MONEY,\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed amount the customer will borrow from the bank.\\\",\\n        display_name=\\\"Loan principal\\\",\\n        default_value=Decimal(1),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=FIRST_REPAYMENT_DATE,\\n        shape=OptionalShape(DateShape(min_date=datetime.min, max_date=datetime.max)),\\n        level=Level.INSTANCE,\\n        description=\\\"The selected date which customer will make first repayment.\\\"\\n        \\\" The next monthly repayment day will be derived based on first repayment date.\\\",\\n        display_name=\\\"First Repayment Date\\\",\\n        default_value=OptionalValue(datetime.min),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_START_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        description=\\\"Start of the gold financing contract terms, either after account opening \\\"\\n        \\\"or top up.\\\",\\n        display_name=\\\"Start date of the Gold Finance\\\",\\n        default_value=datetime.min,\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    # Derived Parameters\\n    Parameter(\\n        name=TOTAL_OUTSTANDING,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total balance on this account (including fees).\\\",\\n        display_name=\\\"Total outstanding\\\",\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_REMAINING_PRINCIPAL,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Total remaining principal on this account.\\\",\\n        display_name=\\\"Remaining Principal\\\",\\n    ),\\n    Parameter(\\n        name=OUTSTANDING_PAYMENTS,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Unpaid dues, overdues and penalties\\\",\\n        display_name=\\\"Outstanding payments\\\",\\n    ),\\n    Parameter(\\n        name=REMAINING_TERM,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total term of the gold financing in months\\\",\\n        display_name=\\\"Remaining term in months\\\",\\n    ),\\n    Parameter(\\n        name=EXPECTED_EMI,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected EMI (Equated Monthly Installment)\\\",\\n        display_name=\\\"Expected EMI\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_REPAYMENT_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Next scheduled repayment date\\\",\\n        display_name=\\\"Next Repayment date\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_OVERDUE_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"The date on which current due principal and margin will become overdue.\\\",\\n        display_name=\\\"Overdue date\\\",\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_REPAYMENT_AMOUNT,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected amount to be paid for early maturity repayment\\\",\\n        display_name=\\\"Early Maturity Repayment Amount\\\",\\n    ),\\n    # Template Parameters\\n    Parameter(\\n        name=DENOMINATION,\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Currency in which the product operates.\\\",\\n        display_name=\\\"Denomination.\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=EQUIVALENT_RATE,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin rate used to calculate margin amount.\\\",\\n        display_name=\\\"Equivalent Rate \\\",\\n        default_value=Decimal(\\\"0.09\\\"),\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_MARGIN,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin percentage to calculate margin need to be paid by customer \\\"\\n        \\\"during early mature process.\\\",\\n        display_name=\\\"Early Maturity Margin Rate \\\",\\n        default_value=Decimal(\\\"0.02\\\"),\\n    ),\\n    Parameter(\\n        name=REPAYMENT_PERIOD,\\n        shape=NumberShape(max_value=31, min_value=1, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days to repay due amount before incurring penalties.\\\",\\n        display_name=\\\"Repayment period (days)\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which due amount is calculated.\\\",\\n        display_name=\\\"Repayment hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUAL_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=15, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin accruals.\\\",\\n        display_name=\\\"Margin accrual precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=FULFILLMENT_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=4, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin fulfillment.\\\",\\n        display_name=\\\"Margin fulfillment precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE,\\n        level=Level.TEMPLATE,\\n        description=\\\"The amount of daily ta'widh will be charged at overdue\\\",\\n        display_name=\\\"Ta'widh fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"2000\\\"),\\n    ),\\n    Parameter(\\n        name=TAZIR_PERIOD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir will accrue since the overdue\\\",\\n        display_name=\\\"Tazir Period\\\",\\n        default_value=10,\\n    ),\\n    Parameter(\\n        name=MAXIMUM_DPD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir and tawidh will not be accrued\\\"\\n        \\\" and send notification to mark the account as deliquent\\\",\\n        display_name=\\\"Maximum Days Past Due\\\",\\n        default_value=90,\\n    ),\\n    # Internal Accounts\\n    Parameter(\\n        name=DISBURSEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The account to which the principal borrowed amount will be transferred.\\\",\\n        display_name=\\\"Disbursement account\\\",\\n        default_value=DISBURSEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=SETTLEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for settlement balance.\\\",\\n        display_name=\\\"Settlement account\\\",\\n        default_value=SETTLEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MARGIN_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for margin income balance.\\\",\\n        display_name=\\\"Margin income account\\\",\\n        shape=AccountIdShape,\\n        default_value=MARGIN_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'widh fee income balance.\\\",\\n        display_name=\\\"Ta'widh fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAWIDH_FEE_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MUQASAH_PAYABLE_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for muqasah payment.\\\",\\n        display_name=\\\"Muqasah payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=MUQASAH_PAYABLE_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAZIR_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'zir fee income balance.\\\",\\n        display_name=\\\"Ta'zir fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAZIR_FEE_INCOME_ACCOUNT,\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    )\\n]\\n\\n# Vault hooks\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=GOLD_FINANCING_START_DATE\\n    )\\n    daily_accrual_schedule = _get_accrue_margin_and_fees_schedule(\\n        vault, gold_financing_start_date.date()\\n    )\\n    monthly_schedule_dict = _get_initial_monthly_schedule(vault)\\n\\n    repayment_day_dict = monthly_schedule_dict.get(REPAYMENT_DAY_SCHEDULE)\\n    check_overdue_dict = monthly_schedule_dict.get(CHECK_OVERDUE)\\n\\n    repayment_day_schedule = {\\n        \\\"day\\\": repayment_day_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": repayment_day_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": repayment_day_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": repayment_day_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    # Check overdue schedule would be runs at the same month as repayment day\\n    check_overdue_schedule = {\\n        \\\"day\\\": check_overdue_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": check_overdue_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": check_overdue_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": check_overdue_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    schedules = [\\n        (ACCRUE_MARGIN_AND_FEES, daily_accrual_schedule),\\n        (REPAYMENT_DAY_SCHEDULE, repayment_day_schedule),\\n        (CHECK_OVERDUE, check_overdue_schedule),\\n    ]\\n\\n    return schedules\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef derived_parameters(effective_date):\\n    total_outstanding = _get_all_outstanding(vault)\\n    next_repayment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    total_term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, TOTAL_TERM))\\n    next_overdue_date = next_repayment_date + timedelta(days=int(repayment_period))\\n    sum_outstanding_dues = _sum_outstanding_dues(vault)\\n    outstanding_actual_principal = _get_outstanding_actual_principal(vault)\\n    return {\\n        TOTAL_OUTSTANDING: total_outstanding,\\n        GOLD_FINANCING_REMAINING_PRINCIPAL: outstanding_actual_principal,\\n        OUTSTANDING_PAYMENTS: sum_outstanding_dues,\\n        NEXT_REPAYMENT_DATE: next_repayment_date,\\n        NEXT_OVERDUE_DATE: next_overdue_date,\\n        REMAINING_TERM: _get_expected_remaining_term(vault, effective_date, total_term),\\n        EXPECTED_EMI: _get_expected_emi(vault, effective_date),\\n        EARLY_MATURITY_REPAYMENT_AMOUNT: _calculate_early_maturity_repayment_amount(\\n            vault, effective_date\\n        ),\\n    }\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef post_activate_code():\\n\\n    account_creation_date = vault.get_account_creation_date()\\n    principal = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL))\\n    disbursement_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DISBURSEMENT_ACCOUNT)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n\\n    monthly_instalment = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, eq_rate, term),\\n        precision,\\n    )\\n    margin_receivable_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_instalment * term) - principal,\\n        precision,\\n    )\\n\\n    posting_ins = []\\n    posting_ins.extend(\\n        vault.make_internal_transfer_instructions(\\n            amount=principal,\\n            denomination=denomination,\\n            client_transaction_id=vault.get_hook_execution_id() + \\\"_PRINCIPAL_DISBURSMENT\\\",\\n            from_account_id=vault.account_id,\\n            from_account_address=PRINCIPAL,\\n            to_account_id=disbursement_account,\\n            to_account_address=DEFAULT_ADDRESS,\\n            instruction_details={\\n                \\\"description\\\": f\\\"Disbursement of {principal} of gold financing principal\\\",\\n                \\\"event\\\": \\\"PRINCIPAL_DISBURSEMENT\\\",\\n            },\\n            asset=DEFAULT_ASSET,\\n            override_all_restrictions=True,\\n        )\\n    )\\n\\n    if margin_receivable_amount > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_receivable_amount,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_MARGIN_RECEIVABLE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Disbursement of {margin_receivable_amount} of gold financing \\\"\\n                    \\\"margin receivable\\\",\\n                    \\\"event\\\": \\\"MARGIN_RECEIVABLE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if monthly_instalment > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_instalment,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_STORE_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Store monthly installment at \\\"\\n                    f\\\"{denomination}{monthly_instalment} \\\"\\n                    f\\\"of gold financing to {EMI_ADDRESS}\\\",\\n                    \\\"event\\\": \\\"STORE_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    vault.instruct_posting_batch(\\n        posting_instructions=posting_ins,\\n        effective_date=account_creation_date,\\n        client_batch_id=f\\\"BATCH_{vault.get_hook_execution_id()}_INITIAL_GOLD_FINANCING_DISBURSMENT\\\",\\n    )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"ACCRUE_MARGIN_AND_FEES\\\",\\n    parameters=True,\\n    balances=\\\"2 months\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\", \\\"CHECK_OVERDUE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"REPAYMENT_DAY_SCHEDULE\\\",\\n    parameters=True,\\n    balances=\\\"2 days live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"CHECK_OVERDUE\\\",\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == ACCRUE_MARGIN_AND_FEES:\\n        posting_instructions.extend(_handle_accrue_margin_and_fees(vault, effective_date))\\n    elif event_type == REPAYMENT_DAY_SCHEDULE:\\n        posting_instructions.extend(_handle_repayment_due(vault, effective_date))\\n        new_schedule = _get_next_repayment_day_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    elif event_type == CHECK_OVERDUE:\\n        posting_instructions.extend(_handle_overdue(vault, effective_date))\\n        new_schedule = _get_next_check_overdue_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef pre_posting_code(postings, effective_date):\\n    if len(postings) > 1:\\n        raise Rejected(\\n            \\\"Multiple postings in batch not supported\\\",\\n            reason_code=RejectedReason.CLIENT_CUSTOM_REASON,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    for posting in postings:\\n        if posting.denomination != denomination:\\n            raise Rejected(\\n                \\\"Cannot make transactions in given denomination; \\\"\\n                f\\\"transactions must be in {denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n        proposed_amount = _get_posting_amount(posting)\\n        if proposed_amount <= 0:\\n            if vault.modules[\\\"utils\\\"].str_to_bool(\\n                postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n            ):\\n                early_maturity_repayment_amount = _calculate_early_maturity_repayment_amount(\\n                    vault, effective_date\\n                )\\n                if abs(proposed_amount) != early_maturity_repayment_amount:\\n                    raise Rejected(\\n                        \\\"Does not match the early repayment amount of \\\"\\n                        f\\\"{early_maturity_repayment_amount}\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n            else:\\n                outstanding = _get_all_outstanding(vault)\\n                if abs(proposed_amount) > outstanding:\\n                    raise Rejected(\\n                        \\\"Cannot pay more than is owed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n                maximum_payment = _sum_outstanding_dues(vault)\\n                if abs(proposed_amount) > maximum_payment:\\n                    raise Rejected(\\n                        \\\"Overpayment transaction is not allowed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n\\n        elif not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"fee\\\", \\\"false\\\")\\n        ) and not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"interest_adjustment\\\", \\\"false\\\")\\n        ):\\n            raise Rejected(\\n                \\\"Debiting not allowed from this account\\\",\\n                reason_code=RejectedReason.AGAINST_TNC,\\n            )\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef post_posting_code(postings: PostingInstructionBatch, effective_date: datetime):\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_amount = _get_posting_batch_amount(postings, denomination)\\n    posting_instructions = []\\n    if posting_amount < 0:\\n        client_transaction_id = (\\n            f\\\"{postings[0].client_transaction_id}_{vault.get_hook_execution_id()}\\\"\\n        )\\n        if vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n        ):\\n            posting_instructions.extend(\\n                _process_early_maturity(\\n                    vault, effective_date, posting_amount, client_transaction_id\\n                )\\n            )\\n        else:\\n            posting_instructions.extend(\\n                _process_payment(vault, effective_date, posting_amount, client_transaction_id)\\n            )\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, REPAYMENT_EVENT)\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if any(param in INSTANCE_PARAMS for param in parameters):\\n        raise Rejected(\\n            \\\"Cannot update the parameter after account is created\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef close_code(effective_date: datetime):\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n    # Check current outstanding balance\\n    outstanding_balance = _get_all_outstanding(vault)\\n    posting_ins = []\\n\\n    # Create settlement posting instrution if there is outstanding balance left in account\\n    cti_settlement = f\\\"{vault.get_hook_execution_id()}_{SETTLEMENT_EVENT}\\\"\\n    if outstanding_balance > 0:\\n        settlemnet_account = vault.modules[\\\"utils\\\"].get_parameter(vault, SETTLEMENT_ACCOUNT)\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_balance,\\n                denomination=denomination,\\n                client_transaction_id=cti_settlement,\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=settlemnet_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                instruction_details={\\n                    \\\"event\\\": SETTLEMENT_EVENT,\\n                    \\\"description\\\": \\\"Settle all outstanding balance before close the account\\\"\\n                    f\\\" at {denomination}{outstanding_balance}\\\",\\n                },\\n                override_all_restrictions=True,\\n            )\\n        )\\n        # Create repayment order for settlement\\n        posting_ins.extend(\\n            _process_payment(vault, effective_date, outstanding_balance, cti_settlement)\\n        )\\n\\n        # Pay Outstanding Principal and Margin\\n        outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL])\\n        outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN])\\n        margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, name=MARGIN_INCOME_ACCOUNT\\n        )\\n        # repay outstanding principal\\n        if outstanding_principal > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_principal,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=PRINCIPAL,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                        f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n        # record margin as income\\n        if outstanding_margin > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{MARGIN}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=margin_income_account,\\n                    to_account_address=DEFAULT_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{MARGIN}_INCOME_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=MARGIN,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"REPAYMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n    \\n    # clear EMI\\n    if emi > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {EMI_ADDRESS}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {ACCRUED_MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{ACCRUED_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if len(posting_ins) > 0:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_ins,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"CLOSE_ACCOUNT-{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\n# Helper Functions\\ndef _handle_accrue_margin_and_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate daily margin and fees accrual posting instructions at\\n    the effective datetime\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle daily margin and fees accrual\\n    \\\"\\\"\\\"\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    margin_accrual_date = _get_balance_date_for_margin_accrual(vault)\\n\\n    outstanding_principal = _get_outstanding_actual_principal(vault, margin_accrual_date)\\n\\n    outstanding_accrue = _get_accrued_margin(vault, effective_date)\\n\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    margin_data = _get_daily_margin_accrual(\\n        vault,\\n        outstanding_principal,\\n        outstanding_accrue,\\n        margin_rate,\\n        effective_date,\\n    )\\n\\n    margin_to_accrue = margin_data[\\\"margin_to_accrue\\\"]\\n\\n    posting_instructions = []\\n    if margin_to_accrue > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_accrue,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_MARGIN_ACCRUAL\\\"\\n                f\\\"_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=ACCRUED_MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Daily margin accrued at \\\"\\n                    f\\\"{(margin_rate/DAYS_IN_A_YEAR) * 100:0.6f}\\\",\\n                    \\\"event_type\\\": ACCRUE_MARGIN_AND_FEES,\\n                    \\\"daily_margin_rate\\\": f\\\"{(margin_rate/DAYS_IN_A_YEAR)}\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # Check late repayment fee will get all the overdue addresses and apply\\n    # fee for every overdue installment\\n    posting_instructions.extend(_check_late_repayment_fee(vault, effective_date))\\n\\n    return posting_instructions\\n\\n\\ndef _handle_repayment_due(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate monthly repayment installment which consist of principal due\\n    and margin due\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle repayment day\\n    \\\"\\\"\\\"\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    monthly_due_amounts = _calculate_monthly_payment_margin_and_principal(\\n        vault, margin_rate, effective_date\\n    )\\n    posting_instructions = _get_transfer_due_instructions(\\n        vault=vault,\\n        effective_date=effective_date,\\n        monthly_due_amounts=monthly_due_amounts,\\n        event_type=\\\"CALCULATE_AND_TRANSFER_DUE_AMOUNT\\\",\\n    )\\n\\n    _send_repayment_notification(vault, effective_date, monthly_due_amounts)\\n\\n    return posting_instructions\\n\\n\\ndef _handle_overdue(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Move unpaid due amount to overdue, charge penalty fee\\n    and schedule for delinquency check after grace period\\n    :param vault: parameters, balances\\n    :param effective_date: datetime\\n    :return: list of posting instructions to handle overdue\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    posting_instructions = []\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, PRINCIPAL_DUE, PRINCIPAL_OVERDUE, effective_date)\\n    )\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, MARGIN_DUE, MARGIN_OVERDUE, effective_date)\\n    )\\n    additional_fee = 0\\n    if len(posting_instructions) > 0:\\n        # Add late repayment fee at the first time it's become overdue for 1 installment only\\n        tazir_fee = 0\\n        if _is_apply_tazir_for_overdue(vault, effective_date):\\n            due_balance = vault.modules[\\\"utils\\\"].get_balance_sum(vault, DUE_ADDRESSES)\\n            precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n            eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n            tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                (due_balance * eq_rate / DAYS_IN_A_YEAR), precision\\n            )\\n        post_ins, additional_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, 1, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, additional_fee)\\n\\n    return posting_instructions\\n\\n\\n# Part of repayment day schedule\\ndef _get_transfer_due_instructions(\\n    vault,\\n    effective_date: datetime,\\n    monthly_due_amounts: Dict[str, Decimal],\\n    event_type: str,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Return a list of PostingInstructions to transfer\\n    funds based on the monthly due amounts.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param monthly_due_amount: Dict[str, Decimal]\\n    :param event_type: str\\n    :return list of posting instructions to transfer due and EMI balance\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=2)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n\\n    emi = monthly_due_amounts.get(\\\"emi\\\", Decimal(\\\"0\\\"))\\n    principal_due = monthly_due_amounts.get(\\\"principal_due\\\", Decimal(\\\"0\\\"))\\n    margin_due = monthly_due_amounts.get(\\\"margin_due\\\", Decimal(\\\"0\\\"))\\n\\n    stored_emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n\\n    posting_instructions = []\\n    if emi > 0 and emi != stored_emi:\\n        if stored_emi > 0:\\n            posting_instructions.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=stored_emi,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_STORED_EMI\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=EMI_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": \\\"Clearing stored EMI amount\\\",\\n                        \\\"event\\\": event_type,\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_UPDATE_STORED_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Updating stored EMI amount\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if principal_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=principal_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_PAYMENT_PERIOD_PRINCIPAL_DUE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=PRINCIPAL_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly principal added to due address: {principal_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if margin_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_APPLY_ACCRUED_MARGIN_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly margin added to due address: {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_ACCRUED_MARGIN\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clear accrued margin of : {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _send_repayment_notification(vault, effective_date: datetime, monthly_due: Dict[str, Decimal]):\\n    \\\"\\\"\\\"\\n    Instruct a repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param monthly_due: Dict[str, Decimal], monthly due values\\n    :return: None\\n    \\\"\\\"\\\"\\n    repayment_amount = monthly_due.get(\\\"principal_due\\\", Decimal(\\\"0\\\")) + monthly_due.get(\\n        \\\"margin_due\\\", Decimal(\\\"0\\\")\\n    )\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    overdue_date = effective_date + timedelta(days=int(repayment_period))\\n\\n    vault.instruct_notification(\\n        notification_type=\\\"GOLD_FINANCING_REPAYMENT\\\",\\n        notification_details={\\n            \\\"account_id\\\": vault.account_id,\\n            \\\"repayment_amount\\\": str(repayment_amount),\\n            \\\"overdue_date\\\": str(overdue_date.date()),\\n        },\\n    )\\n\\n\\ndef _process_payment(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower, paying off the balance in different addresses\\n    in the correct order\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str\\n    :return: List[PostingInstruction]\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    repayment_amount_remaining = abs(repayment_amount)\\n    sorted_repayment_addresses = _get_sorted_repayment_addresses(denomination, balances)\\n    repayment_instructions = []\\n    for repayment_order in sorted_repayment_addresses:\\n        sum_repayment_order = vault.modules[\\\"utils\\\"].get_balance_sum(vault, repayment_order)\\n        rounded_address_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n            sum_repayment_order, fulfillment_precision\\n        )\\n        if rounded_address_balance and repayment_amount_remaining > 0:\\n\\n            repayment_amount = min(repayment_amount_remaining, rounded_address_balance)\\n            repayment_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                repayment_amount, fulfillment_precision\\n            )\\n\\n            remaining_amount = 0\\n            for debt_address in repayment_order:\\n                debt_balance = _get_effective_balance_by_address(vault, debt_address)\\n                rounded_debt_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n                    debt_balance, fulfillment_precision\\n                )\\n\\n                proportion_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                    (repayment_amount / rounded_address_balance) * rounded_debt_balance,\\n                    fulfillment_precision,\\n                )\\n                posting_amount = remaining_amount if remaining_amount > 0 else proportion_amount\\n\\n                if proportion_amount > 0:\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"REPAY_{debt_address}_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=DEFAULT_ADDRESS,\\n                            to_account_id=vault.account_id,\\n                            to_account_address=debt_address,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": \\\"REPAYMENT\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n                if (\\n                    _get_parameters_from_finance_address(debt_address)[\\\"address_type\\\"]\\n                    in MARGIN_ADDRESS_TYPES\\n                ):\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"{debt_address}_INCOME_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=INTERNAL_CONTRA,\\n                            to_account_id=margin_income_account,\\n                            to_account_address=DEFAULT_ADDRESS,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": f\\\"{debt_address}_INCOME\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n\\n                # The 2nd sequence of repayment order would has remaining amount\\n                # instead of calculate the portion due to rounding calculate and the balance\\n                # must be 0 at the end of payment process.\\n                remaining_amount = repayment_amount - posting_amount\\n                repayment_amount_remaining -= posting_amount\\n\\n    return repayment_instructions\\n\\n\\ndef _process_early_maturity(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n):\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower for early maturity repayment,\\n    paying off the balance in different addresses\\n    in the correct order\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime , date and time of hook being run\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str, base client_transaction_id to be extended with event\\n    information\\n    :return: None\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    repayment_instructions = []\\n\\n    repayment_instructions.extend(\\n        _process_payment(vault, effective_date, repayment_amount, client_transaction_id)\\n    )\\n    # get balances\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, [PRINCIPAL], effective_date\\n    )\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], effective_date)\\n    margin_to_paid = _calculate_early_maturity_margin_to_be_paid(vault, effective_date)\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS], effective_date)\\n    muqasah_amount = _calculate_muqasah_amount(vault, effective_date)\\n\\n    # get internal account\\n    muqasah_payable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=MUQASAH_PAYABLE_ACCOUNT\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    # repay outstanding principal\\n    if outstanding_principal > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_principal,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                    f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # record margin as income\\n    if outstanding_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{INTERNAL_CONTRA}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=margin_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_paid,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MARGIN}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {margin_to_paid} from {MARGIN}, \\\"\\n                    f\\\"which was at {margin_to_paid} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # clear EMI\\n    if emi > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {MARGIN}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"{ACCRUE_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # discount on margin\\n    if muqasah_amount > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=muqasah_amount,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MUQASAH_PAYABLE_ACCOUNT}_WRITEOFF_{client_transaction_id}\\\",\\n                from_account_id=muqasah_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Writing off {muqasah_amount} from {MUQASAH_PAYABLE_ACCOUNT}, \\\"\\n                    f\\\"which was at {muqasah_amount} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{MARGIN}_WRITEOFF\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return repayment_instructions\\n\\n\\ndef _get_next_repayment_day_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next repayment day schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of REPAYMENT_SCHEDULE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(repayment_schedule_date)\\n\\n\\ndef _get_initial_monthly_schedule(vault) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the initial repayment day and check overdue schedule\\n\\n    :param vault: Vault object\\n    :return: tuple, representation of initial REPAYMENT_SCHEDULE and CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    first_overdue_date = _get_overdue_schedule(vault, first_repayment_date)\\n\\n    first_repayment_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_repayment_date\\n    )\\n    first_overdue_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_overdue_date\\n    )\\n\\n    return {\\n        REPAYMENT_DAY_SCHEDULE: first_repayment_schedule,\\n        CHECK_OVERDUE: first_overdue_schedule,\\n    }\\n\\n\\n# Overdue helper functions\\ndef _get_overdue_postings(\\n    vault, due_address: str, overdue_address: str, effective_date: datetime\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Instruct posting instructions to move balance between due and overdue address\\n    :param vault: Vault object\\n    :param due_address: str, due address balance name\\n    :param overdue_address: str, overdue address balance name\\n    :param effective_date: datetime\\n    :return list of posting instructions which moves due to overdue\\n    \\\"\\\"\\\"\\n    amount_to_transfer = _get_effective_balance_by_address(vault, due_address)\\n\\n    if amount_to_transfer == 0:\\n        return []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    current_month_index = _get_current_term_index(vault, effective_date)\\n\\n    return vault.make_internal_transfer_instructions(\\n        amount=amount_to_transfer,\\n        denomination=denomination,\\n        client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + overdue_address,\\n        from_account_id=vault.account_id,\\n        from_account_address=f\\\"{overdue_address}_{current_month_index}\\\",\\n        to_account_id=vault.account_id,\\n        to_account_address=due_address,\\n        instruction_details={\\n            \\\"description\\\": f\\\"Mark outstanding due amount of \\\"\\n            f\\\"{amount_to_transfer} as {overdue_address}_{current_month_index}.\\\",\\n            \\\"event\\\": \\\"MOVE_BALANCE_INTO_\\\" + overdue_address,\\n        },\\n        asset=DEFAULT_ASSET,\\n        override_all_restrictions=True,\\n    )\\n\\n\\ndef _check_late_repayment_fee(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Check if there are overdue balance in the account, then it will instruct\\n    posting to accruing the daily late repaymet fee\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to apply daily late repayment fee\\n    \\\"\\\"\\\"\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tazir_period = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAZIR_PERIOD))\\n    maximum_dpd = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=MAXIMUM_DPD))\\n    overdue_addresses = _get_sorted_overdue_addresses(denomination, balances)\\n    tawidh_number = 0\\n    tazir_fee = 0\\n    posting_instructions = []\\n\\n    if len(overdue_addresses) > 0:\\n        # Check the latest overdue bucket balance for applying tazir fee\\n        check_overdue_last_execution = vault.get_last_execution_time(event_type=CHECK_OVERDUE)\\n        latest_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_addresses[0])\\n        if check_overdue_last_execution and latest_overdue_bucket > 0:\\n            is_accrue_tazir = _is_apply_tazir_for_overdue(vault, check_overdue_last_execution)\\n            dpd_number = _calculate_days_past_due(vault, overdue_addresses[0], effective_date)\\n            if dpd_number == maximum_dpd:\\n                # If the account has days past due equal to 90 days, then it will\\n                # send notification to mark the account as deliquent\\n                _send_deliquent_notification(vault, effective_date)\\n            if is_accrue_tazir and dpd_number <= tazir_period:\\n                emi_amount = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n                tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                    ((eq_rate / DAYS_IN_A_YEAR) * emi_amount), precision\\n                )\\n\\n        # Apply ta'widh fee for each overdue installment\\n        for overdue_bucket in overdue_addresses:\\n            sum_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_bucket)\\n            if sum_overdue_bucket > 0:\\n                tawidh_number += 1\\n\\n    total_fee = 0\\n    if tawidh_number > 0 or tazir_fee > 0:\\n        post_ins, total_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, tawidh_number, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, total_fee)\\n\\n    return posting_instructions\\n\\n\\ndef _get_late_repayment_fee_postings(\\n    vault, effective_date: datetime, tawidh_number: int, tazir_fee: Decimal\\n) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Get daily late repayment fee posting as it's overdue\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param tawidh_number: int, the number of tawidh fee will be applied\\n    :param tazir_fee: Decimal, the amount of tazir fee will be applied\\n    :return list of posting instructions to apply late repayment fee\\n    and total fee amount being charged\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_instructions = []\\n    tawidh_fee = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAWIDH_FEE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tawidh_fee = vault.modules[\\\"utils\\\"].round_decimal((tawidh_fee * tawidh_number), precision)\\n    tawidh_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAWIDH_FEE_INCOME_ACCOUNT\\n    )\\n    tazir_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAZIR_FEE_INCOME_ACCOUNT\\n    )\\n    if tawidh_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tawidh_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAWIDH_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAWIDH_ADDRESS,\\n                to_account_id=tawidh_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'widh fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAWIDH_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if tazir_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tazir_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAZIR_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAZIR_ADDRESS,\\n                to_account_id=tazir_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'zir fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAZIR_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    total_fee = tawidh_fee + tazir_fee\\n    return posting_instructions, total_fee\\n\\n\\ndef _is_apply_tazir_for_overdue(vault, effective_date: datetime) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the previous month has no overdue or the overdue installment has been\\n    already repay\\n\\n    :param vault: Vault object,\\n    :param effective_date: datetime,\\n    :return boolean to indicates applying tazir\\n    \\\"\\\"\\\"\\n\\n    previous_installment_no = str(_get_current_term_index(vault, effective_date) - 1)\\n    if int(previous_installment_no) < 1:\\n        return True\\n    overdue_bucket = [\\n        PRINCIPAL_OVERDUE + \\\"_\\\" + previous_installment_no,\\n        MARGIN_OVERDUE + \\\"_\\\" + previous_installment_no,\\n    ]\\n\\n    current_overdue_balance = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, overdue_bucket, effective_date\\n    )\\n\\n    if current_overdue_balance == 0:\\n        return True\\n\\n    return False\\n\\n\\ndef _get_next_check_overdue_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next check overdue schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n    next_overdue_schedule = _get_overdue_schedule(vault, repayment_schedule_date)\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_overdue_schedule)\\n\\n\\ndef _send_overdue_repayment_notification(vault, effective_date: datetime, additional_fee: Decimal):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param additional_fee: Decimal, additional fee added to outstanding due\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"repayment_amount\\\": str(outstanding_dues + additional_fee),\\n                \\\"overdue_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _send_deliquent_notification(vault, effective_date: datetime):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_DELIQUENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"deliquent_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _get_current_term_index(vault, effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    The value returned is the index of current month that effective date is currently\\n    in on the scale form 1 to loan tenor. Hence it is equal to the number of passed repayment due\\n    days\\n    \\\"\\\"\\\"\\n    tenor = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, tenor)\\n\\n    return tenor - remaining_term\\n\\n\\n# Calculate helper functions\\ndef _calculate_monthly_instalment(\\n    outstanding_principal: Decimal, margin_rate: Decimal, total_term: int\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly installment amount at outstanding principal\\n\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :param total_term: int\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return (outstanding_principal * margin_rate / 12) / (\\n        1 - ((1 + (margin_rate / 12)) ** (-total_term))\\n    )\\n\\n\\ndef _calculate_monthly_margin(\\n    vault,\\n    precision: int,\\n    outstanding_principal: Decimal,\\n    margin_rate: Decimal,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly margin amount at outstanding principal\\n\\n    :param vault: Vault object\\n    :param precision: int\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * margin_rate / 12), precision\\n    )\\n\\n\\ndef _calculate_next_repayment_date(vault, effective_date: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, GOLD_FINANCING_START_DATE\\n    )\\n\\n    last_execution_time = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n\\n    # Localizing effective date to WIB timezone for calculation of next repayment date\\n    localized_effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    repayment_day = gold_financing_start_date.day\\n\\n    if first_repayment_date:\\n        next_payment_date = first_repayment_date + timedelta(\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        if next_payment_date > localized_effective_date:\\n            return next_payment_date\\n        else:\\n            repayment_day = first_repayment_date.day\\n\\n    earliest_event_start_date = gold_financing_start_date + timedelta(days=1)\\n\\n    if last_execution_time:\\n        # Localizing repayment schedule last execution time\\n        # to WIB timezone for calculation of next repayment date\\n        localized_last_execution_time = last_execution_time + timedelta(hours=WIB_UTC_OFFSET)\\n        while localized_last_execution_time <= localized_effective_date:\\n            localized_last_execution_time += timedelta(months=1)\\n\\n        next_payment_date = localized_last_execution_time + timedelta(\\n            day=repayment_day,\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        return next_payment_date\\n\\n    next_payment_date = localized_effective_date + timedelta(\\n        day=repayment_day,\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    if (\\n        next_payment_date <= localized_effective_date\\n        or next_payment_date <= earliest_event_start_date\\n    ):\\n        next_payment_date += timedelta(months=1)\\n\\n    return next_payment_date\\n\\n\\ndef _calculate_first_repayment_date(vault) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate first repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    if first_repayment_date is None:\\n        gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, GOLD_FINANCING_START_DATE\\n        )\\n        first_repayment_date = gold_financing_start_date + timedelta(months=1)\\n\\n    first_repayment_date = first_repayment_date + timedelta(\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    return first_repayment_date\\n\\n\\ndef _calculate_early_maturity_margin_to_be_paid(\\n    vault,\\n    timestamp: datetime,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the amount of margin that must be paid during the early maturity repayment process\\n    The formula is :\\n        (Outstanding Principal * early maturity margin rate) + accrued margin\\n    The amount of margin that must be paid should be less than or equal the outstanding margin\\n    :param vault: Vault Object to get the parameter and balance of current the account\\n    :param timestamp: timestamp of the balance to check\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    early_maturity_margin_percentage = Decimal(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, EARLY_MATURITY_MARGIN)\\n    )\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    expected_margin_to_be_paid = vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * early_maturity_margin_percentage) + accrued_margin,\\n        fulfillment_precision,\\n    )\\n\\n    return min(expected_margin_to_be_paid, outstanding_margin)\\n\\n\\ndef _calculate_early_maturity_repayment_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the value of the payment that must be made to make early maturity posting\\n    The Formula is :\\n        Outstanding Principal + Margin amount to be Paid + All outstanding Due\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n    all_outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal + margin_amount_to_be_paid + all_outstanding_due,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _calculate_muqasah_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Return the discount amount (Muqasah) that applies to early maturity repayment\\n    The Formula is :\\n        outstanding_margin - Margin amount to be Paid\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_margin - margin_amount_to_be_paid,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _create_margin_remainder_posting(\\n    vault,\\n    margin_address: str,\\n    actual_balance: Decimal,\\n    rounded_balance: Decimal,\\n    event_type: str,\\n    denomination: str,\\n    include_address_in_client_transaction_id: bool = False,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Creates and returns posting instructions for handling remainder on MARGIN address due to\\n    any difference in accrual and fulfilment precision.\\n    If positive, margin was rounded down and exra margin was charged to customer.\\n    If negative, margin was rounded up and extra margin was returned to customer.\\n\\n    :param vault: Vault object\\n    :param margin_address: str, margin address on which to handle remainder\\n    :param actual_balance: Decimal, margin balance amount prior to application\\n    :param rounded_balance: Decimal, rounded margin amount that was applied\\n    :param event_type: str, event which triggered the margin application\\n    :param denomination: str, denomination used for account\\n    :param include_address_in_client_transaction_id: bool, if True then we include the address\\n    when constructing the client transaction id, to ensure uniqueness.\\n    :return: list of posting instructions to handle margin remainder\\n    \\\"\\\"\\\"\\n    hook_execution_id = vault.get_hook_execution_id()\\n    margin_remainder = actual_balance - rounded_balance\\n    margin_remainder_postings = []\\n    if include_address_in_client_transaction_id:\\n        client_transaction_id = (\\n            f\\\"{event_type}_{margin_address}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n        )\\n    else:\\n        client_transaction_id = f\\\"{event_type}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n    if margin_remainder < 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=margin_address,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin charged to customer from negative remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded up\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n    elif margin_remainder > 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=margin_address,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin returned to customer from positive remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded down\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n\\n    return margin_remainder_postings\\n\\n\\ndef _calculate_monthly_payment_margin_and_principal(\\n    vault,\\n    annual_margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Dict[str, Decimal]:\\n    \\\"\\\"\\\" \\\"\\n    Calculate emi, accrued margin, margin due and principal due\\n\\n    :param vault: Vault object\\n    :param annual_margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return Dict[str,Decimal]\\n    \\\"\\\"\\\"\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    actual_principal = _get_outstanding_actual_principal(vault)\\n\\n    principal = vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL)\\n    total_term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n\\n    margin_due = _calculate_monthly_margin(\\n        vault, fulfillment_precision, actual_principal, annual_margin_rate\\n    )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    emi = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, annual_margin_rate, total_term),\\n        fulfillment_precision,\\n    )\\n    principal_due = emi - margin_due\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, total_term)\\n    if remaining_term <= 1:\\n        principal_due = actual_principal\\n        margin_due = _get_effective_balance_by_address(vault, MARGIN)\\n\\n    return {\\n        \\\"emi\\\": emi,\\n        \\\"margin_due\\\": margin_due,\\n        \\\"accrued_margin\\\": accrued_margin,\\n        \\\"principal_due\\\": principal_due,\\n    }\\n\\n\\ndef _calculate_days_past_due(vault, overdue_address: List[str], effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculate the number of days past since the overdue\\n\\n    :param vault: Vault object\\n    :param overdue_address: List[str], list of overdue address pair\\n    :param effective_date: datetime\\n    :return the number of days past since overdue\\n    \\\"\\\"\\\"\\n\\n    installment_number = int(overdue_address[0].split(\\\"_\\\")[-1])\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n    diff_month = installment_number - 1\\n    installment_overdue_date = first_repayment_date + timedelta(months=diff_month)\\n\\n    dpd = (effective_date - installment_overdue_date).days + 1\\n\\n    return dpd\\n\\n\\n# Posting retrieval helper functions\\ndef _get_posting_amount(posting: PostingInstruction, include_pending_out: bool = True) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction\\n\\n    :param posting: PostingInstruction\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\ndef _get_posting_batch_amount(\\n    posting: PostingInstructionBatch, denomination: str, include_pending_out: bool = False\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction batch\\n\\n    :param posting: PostingInstructionBatch\\n    :param denomination: str\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\n# Margin helper functions\\ndef _get_daily_margin_accrual(\\n    vault,\\n    outstanding_principal: Decimal,\\n    outstanding_accrue: Decimal,\\n    margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Tuple[str, Dict[str, str]]:\\n\\n    \\\"\\\"\\\"\\n    Get the amount of daily margin accrual will calculate the\\n    corresponding margin at the effective date\\n\\n    :param outstanding_principal: Decimal\\n    :param outstanding_accrue: Decimal\\n    :param margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return: Tuple[str, Dict[str, str]], representation of\\n    margin to accrue, total days, and next repayment date\\n    \\\"\\\"\\\"\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=ACCRUAL_PRECISION))\\n    term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n    outstanding_margin = _get_effective_balance_by_address(vault, MARGIN, effective_date)\\n    next_payment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    monthly_margin = vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal * margin_rate * Decimal(DAYS_IN_A_MONTH / DAYS_IN_A_YEAR), precision\\n    )\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, term)\\n    total_days = (next_payment_date - effective_date).days + 1\\n\\n    # Adjustment on the last margin accrual at a day before maturity\\n    if outstanding_margin < outstanding_accrue:\\n        return {\\n            \\\"margin_to_accrue\\\": outstanding_margin,\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n    if remaining_term <= 1 and total_days <= 1:\\n        return {\\n            \\\"margin_to_accrue\\\": vault.modules[\\\"utils\\\"].round_decimal(\\n                outstanding_margin - outstanding_accrue, precision\\n            ),\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n\\n    margin_accrual = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_margin - outstanding_accrue) / total_days, precision\\n    )\\n\\n    if margin_accrual < 0:\\n        margin_accrual = 0\\n\\n    return {\\n        \\\"margin_to_accrue\\\": margin_accrual,\\n        \\\"total_days\\\": total_days,\\n        \\\"next_repayment_date\\\": next_payment_date,\\n    }\\n\\n\\ndef _get_accrued_margin(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [ACCRUED_MARGIN], timestamp)\\n\\n\\ndef _get_accrue_margin_and_fees_schedule(\\n    vault, gold_financing_start_date: datetime\\n) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get daily margin and fees accrual schedule dict\\n\\n    :param vault: Vault object\\n    :param gold_financing_start_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    gold_financing_start_date_plus_day = gold_financing_start_date + timedelta(days=1)\\n\\n    accrue_margin_schedule = {\\n        \\\"hour\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_HOUR)),\\n        \\\"minute\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_MINUTE)),\\n        \\\"second\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_SECOND)),\\n        \\\"start_date\\\": str(gold_financing_start_date_plus_day),\\n    }\\n\\n    return accrue_margin_schedule\\n\\n\\n# Time calculation and schedule helper functions\\ndef _get_expected_remaining_term(vault, effective_date: datetime, term: int) -> int:\\n    \\\"\\\"\\\"\\n    The remaining term according to the natural end date of the gold financing.\\n\\n    :param vault\\n    :param effective_date : datetime\\n    return: int\\n    \\\"\\\"\\\"\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date += timedelta(hours=WIB_UTC_OFFSET)\\n\\n    if effective_date < first_repayment_date:\\n        remaining_term = timedelta(months=term)\\n    else:\\n        remaining_term = timedelta(first_repayment_date.date(), effective_date.date()) + timedelta(\\n            months=term\\n        )\\n\\n    if effective_date + remaining_term < effective_date + timedelta(months=1):\\n        return 0\\n    else:\\n        # negative days should reduce term by up to 1 month\\n        rounded_month = -1 if remaining_term.days < 0 else 0\\n        return remaining_term.years * 12 + remaining_term.months + rounded_month\\n\\n\\ndef _get_next_schedule_date(\\n    start_date: datetime, schedule_frequency: str, intended_day: int\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next valid date for schedule based on required frequency and day of month.\\n    Falls to last valid day of month if intended day is not in calculated month\\n    :param start_date: datetime, from which schedule frequency is calculated from\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :param intended_day: int, day of month the scheduled date should fall on\\n    :return: datetime, next occurrence of schedule\\n    \\\"\\\"\\\"\\n\\n    if start_date + timedelta(day=intended_day) > start_date:\\n        next_schedule_date = start_date + timedelta(day=intended_day)\\n    else:\\n        next_schedule_date = start_date + timedelta(months=1, day=intended_day)\\n    return next_schedule_date\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _get_overdue_schedule(vault, effective_date: datetime) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get check overdue schedule dict\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    repayment_period_end = effective_date + timedelta(days=int(repayment_period))\\n\\n    overdue_hour = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_HOUR))\\n    overdue_minute = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_MINUTE))\\n    overdue_second = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_SECOND))\\n\\n    check_overdue_datetime = repayment_period_end.replace(\\n        hour=overdue_hour,\\n        minute=overdue_minute,\\n        second=overdue_second,\\n    )\\n\\n    return check_overdue_datetime\\n\\n\\n# Balance helper functions\\ndef _get_expected_emi(vault, effective_date: datetime) -> Decimal:\\n    emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n    if emi == 0:\\n        margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n        amount_due = _calculate_monthly_payment_margin_and_principal(\\n            vault, margin_rate, effective_date\\n        )\\n        emi = amount_due.get(\\\"emi\\\", Decimal(\\\"0\\\")) if amount_due is not None else Decimal(\\\"0\\\")\\n\\n    return emi\\n\\n\\ndef _get_all_outstanding(vault, timestamp: datetime = None) -> Decimal:\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (\\n            vault.modules[\\\"utils\\\"].get_balance_sum(\\n                vault,\\n                [PRINCIPAL, MARGIN],\\n                timestamp,\\n            )\\n            + outstanding_due\\n        ),\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _sum_outstanding_dues(vault, timestamp: datetime = None) -> Decimal:\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    overdue_address = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n    all_outstanding = overdue_address + FEES_ADDRESSES + DUE_ADDRESSES\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, all_outstanding, timestamp)\\n\\n\\ndef _get_balance_date_for_margin_accrual(vault) -> datetime:\\n    last_repayment_due_date = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n    # If there hasn't been a repayment event, use balances from gold financing start date\\n    if last_repayment_due_date is None:\\n        last_repayment_due_date = vault.get_account_creation_date()\\n\\n    # Effective date of the transfer postings is 2 microseconds after repayment due event\\n    return last_repayment_due_date + timedelta(microseconds=1)\\n\\n\\ndef _get_effective_balance_by_address(vault, address: str, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [address], timestamp)\\n\\n\\ndef _get_outstanding_actual_principal(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n\\ndef _get_sorted_repayment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to repayment hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older,\\n    the repayment hierarchy:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n    TAWIDH\\n    TAZIR\\n    DUE_PRINCIPAL\\n    DUE_MARGIN\\n    PRINCIPAL\\n    MARGIN\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    sorted_repayment_addresses = sorted_all_overdue_addresses + REPAYMENT_DUES_ORDER\\n    return sorted_repayment_addresses\\n\\n\\ndef _get_sorted_overdue_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to overdue hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older, overdue order:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    return sorted_all_overdue_addresses\\n\\n\\ndef _get_all_instalment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n    address_types: List[str],\\n) -> Dict[str, List[str]]:\\n    \\\"\\\"\\\"\\n    Gets all financing addresses for address types listed in address_types.\\n    Valid address types: PRINCIPAL, INTEREST, DUE_PRINCIPAL, DUE_INTEREST, OVERDUE_PRINCIPAL,\\n                         OVERDUE_INTEREST\\n    \\\"\\\"\\\"\\n    addresses = {address_type: [] for address_type in address_types}\\n    for balance_dimension in balances.keys():\\n        address = balance_dimension[0]\\n        if (\\n            address\\n            not in [\\n                DEFAULT_ADDRESS,\\n                ACCRUED_MARGIN,\\n                INTERNAL_CONTRA,\\n            ]\\n            and balances[(address, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        ):\\n            address_type = address[0 : len(address) - 2]\\n            if address_type in addresses:\\n                addresses[address_type].append(address)\\n    return addresses\\n\\n\\ndef _sort_addresses_list(addresses_list: List[str], repayment_order: Dict[str, int]) -> List[str]:\\n    \\\"\\\"\\\"\\n    Returns a list of sorted addresses, based on provided list and respecting address types in\\n    repayment_order.\\n\\n    Sorts by installment_no, then address type (order defined in repayment_order).\\n    \\\"\\\"\\\"\\n\\n    sorted_addresses_list = sorted(\\n        sorted(\\n            addresses_list,\\n            key=lambda address: repayment_order[\\n                _get_parameters_from_finance_address(address)[\\\"address_type\\\"]\\n            ],\\n        ),\\n        key=lambda address: _get_parameters_from_finance_address(address)[\\\"installment_no\\\"],\\n    )\\n\\n    address_list = [\\n        {\\n            \\\"address\\\": address,\\n            \\\"installment_no\\\": _get_parameters_from_finance_address(address).get(\\\"installment_no\\\"),\\n        }\\n        for address in sorted_addresses_list\\n    ]\\n\\n    address_dict = {}\\n    for data in address_list:\\n        installment_no = data[\\\"installment_no\\\"]\\n        address = [data[\\\"address\\\"]]\\n        if installment_no not in address_dict:\\n            address_dict[installment_no] = address\\n        else:\\n            address_dict[installment_no].append(data[\\\"address\\\"])\\n\\n    return list(address_dict.values())\\n\\n\\ndef _get_parameters_from_finance_address(address: str) -> Dict[str, Union[str, int, Decimal]]:\\n    \\\"\\\"\\\"\\n    Gets all financing parameters from a given financing address.\\n    \\\"\\\"\\\"\\n    if len(address.split(\\\"_\\\")) > 2:\\n        address_type = address[0 : len(address) - 2]\\n        installment_no = address.split(\\\"_\\\")[-1]\\n    else:\\n        address_type = address\\n        installment_no = \\\"0\\\"\\n    return {\\n        \\\"address_type\\\": address_type,\\n        \\\"installment_no\\\": installment_no,\\n    }\\n\\n\\n# Generic helper functions\\ndef _instruct_posting_batch(\\n    vault,\\n    posting_instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if posting_instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param posting_instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if posting_instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"repayment_period\": \"1\",\n                \"fulfillment_precision\": \"2\",\n                \"accrual_precision\": \"2\",\n                \"equivalent_rate\": \"0.09\",\n                \"check_overdue_hour\": \"0\",\n                \"check_overdue_minute\": \"1\",\n                \"check_overdue_second\": \"1\",\n                \"accrue_margin_second\": \"0\",\n                \"accrue_margin_hour\": \"0\",\n                \"accrue_margin_minute\": \"1\",\n                \"disbursement_account\": \"DISBURSEMENT_ACCOUNT\",\n                \"settlement_account\": \"SETTLEMENT_ACCOUNT\",\n                \"repayment_hour\": \"0\",\n                \"repayment_minute\": \"1\",\n                \"repayment_second\": \"1\",\n                \"margin_income_account\": \"MARGIN_INCOME_ACCOUNT\",\n                \"tawidh_fee\": \"2000\",\n                \"tawidh_fee_income_account\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"early_maturity_margin\": \"0.02\",\n                \"muqasah_payable_account\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"tazir_fee_income_account\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"tazir_period\": \"10\",\n                \"maximum_dpd\": \"90\"\n            },\n            \"smart_contract_version_id\": \"0\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8173778753438205586\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"3669403174602712157\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"1971845359901712850\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"1427506443378698978\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"1573793104284385895\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"2692415506532883352\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"5149571628372090515\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"047202a6-9730-45cf-a24d-a3c62b8ae124\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SUSPENSE_ACCOUNT\",\n                \"product_version_id\": \"8173778753438205586\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"DISBURSEMENT_ACCOUNT\",\n                \"product_version_id\": \"3669403174602712157\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SETTLEMENT_ACCOUNT\",\n                \"product_version_id\": \"1971845359901712850\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MARGIN_INCOME_ACCOUNT\",\n                \"product_version_id\": \"1427506443378698978\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"1573793104284385895\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"product_version_id\": \"2692415506532883352\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"5149571628372090515\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_0\",\n                \"smart_contract_version_id\": \"0\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"047202a6-9730-45cf-a24d-a3c62b8ae124\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-20T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"product_version_id\": \"0\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"principal\": \"8000000\",\n                    \"total_term\": \"12\",\n                    \"gold_financing_start_date\": \"2022-01-20\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-02-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"d9784fb7-c95e-4e01-b550-957ba64d6578\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"81222d01-0ff8-4a76-9a84-bd7e0dc07206\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-02-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-03-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"05781b82-ea0f-4ae6-8bb7-7c94c5f24862\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"adab7c53-6533-4689-b6e8-e98b5ea30ec7\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-03-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-04-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"4ed88775-aadd-4300-aac8-dac6323ccc59\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"9f8c9321-8536-4896-a5a3-e0384952f067\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-04-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-05-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"b76e1284-43f6-4f0d-9bcd-ff1bc5eebcb5\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"75e2fee3-dea5-43b5-8978-584a1f54d749\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-05-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-06-20T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"81870979-e72b-48ae-b8cc-30f0331c5224\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"6b339dbb-03d0-4d8f-ac85-b01e93c2a8b1\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"699611.81\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {},\n                \"value_timestamp\": \"2022-06-20T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-06-30T00:03:02+00:00\",\n            \"create_posting_instruction_batch\": {\n                \"client_id\": \"AsyncCreatePostingInstructionBatch\",\n                \"client_batch_id\": \"2d5951d7-7c80-47c0-93e9-d60a5445c87c\",\n                \"posting_instructions\": [\n                    {\n                        \"client_transaction_id\": \"71b1a56c-1cde-4220-a87d-eb01069e756f\",\n                        \"instruction_details\": {\n                            \"event\":\"INBOUND_TRANSFER\"\n                        },\n                        \"override\": {},\n                        \"inbound_hard_settlement\": {\n                            \"amount\": \"4860565.11\",\n                            \"denomination\": \"IDR\",\n                            \"target_account\": {\n                                \"account_id\": \"GOLD_FINANCING_ACCOUNT\"\n                            },\n                            \"internal_account_id\": \"SUSPENSE_ACCOUNT\",\n                            \"advice\": false\n                        }\n                    }\n                ],\n                \"batch_details\": {\n                    \"early_maturity_repayment\": \"True\"\n                },\n                \"value_timestamp\": \"2022-06-30T00:03:02+00:00\"\n            }\n        },\n        {\n            \"timestamp\": \"2022-06-30T01:00:00+00:00\",\n            \"update_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"status\": \"ACCOUNT_STATUS_PENDING_CLOSURE\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				},
				{
					"name": "Gold Financing - Demo Deliquent",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var moment = require('moment');",
									"var streamData = pm.response.text().split(\"\\n\");",
									"var jsonData = streamData.map(stringItem => stringItem != \"\" ? JSON.parse(stringItem) : null);",
									"",
									"while (jsonData.length >= 0 && jsonData[jsonData.length - 1] == null) {",
									"    jsonData.pop();",
									"}",
									"",
									"var daily_postings = [];",
									"var addresses = [];",
									"var accounts = [];",
									"",
									"jsonData.forEach(element => {",
									"",
									"    for (var account in element.result.balances) {",
									"        var acc_index = accounts.findIndex(val => {",
									"            return val.account_id == account;",
									"        });",
									"",
									"        if (acc_index < 0) {",
									"            acc_index = accounts.push({",
									"                \"account_id\": account,",
									"                \"balances\": [],",
									"                \"exceptions\": []",
									"            }) - 1;",
									"        }",
									"",
									"        var index = accounts[acc_index].balances.length;",
									"        accounts[acc_index].balances[index] = {};",
									"        accounts[acc_index].balances[index].key = acc_index * 10000 + index;",
									"        accounts[acc_index].balances[index].exception = false;",
									"        accounts[acc_index].balances[index].events = [];",
									"",
									"        element.result.balances[account].balances.forEach(balance => {",
									"            accounts[acc_index].balances[index][balance.account_address] = parseFloat(balance.amount);",
									"            if (!addresses.includes(balance.account_address)) {",
									"                addresses[addresses.length] = balance.account_address;",
									"            }",
									"        });",
									"",
									"        accounts[acc_index].balances[index].instructions = [];",
									"        element.result.posting_instruction_batches.forEach(pib => {",
									"            pib.posting_instructions.forEach(pi => {",
									"                var i = accounts[acc_index].balances[index].instructions.length;",
									"                var j = accounts[acc_index].balances[index].events.length;",
									"                accounts[acc_index].balances[index].instructions[i] = {};",
									"                accounts[acc_index].balances[index].instructions[i].description = pi.client_transaction_id;",
									"                accounts[acc_index].balances[index].instructions[i].commited = pi.committed_postings;",
									"",
									"                var event = pi.instruction_details.event;",
									"                if (event == undefined) {",
									"                    event = \"INTERNAL_POSTING\";",
									"                    var event_type = pi.instruction_details.event_type;",
									"                    if (event_type != undefined) {",
									"                        event = event_type;",
									"                    }",
									"                    if (event == \"INTERNAL_POSTING\") {",
									"                        var batch_details_event = pib.batch_details.event;",
									"                        if (batch_details_event != undefined) {",
									"                            event = batch_details_event;",
									"                        }",
									"                    }",
									"                }",
									"                event += ' '",
									"                if(event == \"INTERNAL_POSTING CASH_ADVANCE\"){",
									"                    event = \"INTERNAL_POSTING\"",
									"                }",
									"                var event_index = accounts[acc_index].balances[index].events.findIndex(val => {",
									"                    return val == event;",
									"                });",
									"                if (event_index < 0)",
									"                    accounts[acc_index].balances[index].events[j] = event;                ",
									"                utc_date = pib.value_timestamp.substring(0, 19);",
									"                accounts[acc_index].balances[index].date = utc_date;",
									"            });",
									"        });",
									"",
									"    };",
									"",
									"    if (element.result.logs.length > 0) {",
									"        if (element.result.logs[0].startsWith(\"rejected posting instruction batch\")) {",
									"            if (element.result.logs.length > 1) {",
									"                if (element.result.logs[1].startsWith(\"account \\\"\")) {",
									"                    var end_index = element.result.logs[1].indexOf('\"', 9);",
									"                    if (end_index > 0) {",
									"                        var acc_id = element.result.logs[1].substring(9, end_index);",
									"                        var acc_index = accounts.findIndex(val => {",
									"                            return val.account_id == acc_id;",
									"                        });",
									"                        if (acc_index < 0) {",
									"                            acc_index = accounts.push({",
									"                                \"account_id\": acc_id,",
									"                                \"balances\": [],",
									"                                \"exceptions\": []",
									"                            }) - 1;",
									"                        }",
									"                        var index = accounts[acc_index].balances.length;",
									"                        accounts[acc_index].balances[index] = {};",
									"                        accounts[acc_index].balances[index].key = 9999999;",
									"                        accounts[acc_index].balances[index].exception = true;",
									"                        utc_date =  element.result.timestamp.substring(0, 19);",
									"                        accounts[acc_index].balances[index].date = utc_date;",
									"                        accounts[acc_index].balances[index].exception_msg = element.result.logs[0] + \"\\n\" + element.result.logs[1];",
									"                    }",
									"                }",
									"            }",
									"        }",
									"    };",
									"",
									"});",
									"accounts.sort((a, b) => {",
									"    return (a.account_id > b.account_id) ? -1 : 1;",
									"});",
									"",
									"// const index = addresses.indexOf('INTERNAL_CONTRA');",
									"// if (index > -1) {",
									"//   addresses.splice(index, 1);",
									"// }",
									"",
									"var default_account_address = [\"DEFAULT\"]",
									"// addresses = [\"PRINCIPAL\", \"INTEREST_DUE\", \"PRINCIPAL_DUE\", \"OVERPAYMENT\", \"EMI_PRINCIPAL_EXCESS\", \"INTEREST_OVERDUE\",\"PRINCIPAL_OVERDUE\", \"PENALTIES\", \"EMI\", \"ACCRUED_INTEREST\"]",
									"",
									"const vizData = {",
									"    balances: JSON.stringify(daily_postings),",
									"    buckets: JSON.stringify(addresses),",
									"    accounts: JSON.stringify(accounts),",
									"    default_account_address: JSON.stringify(default_account_address),",
									"};",
									"// ------------",
									"// - Template -",
									"// ------------",
									"// Configure the template",
									"var template = `",
									"   <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\" >",
									"           ",
									"    </script>",
									"    <style type=\"text/css\">",
									"            .tftable {font-size:14px;color:#333333;width:100%;border-width: 0px;border-color: #d6e0f0;border-collapse: collapse;}",
									"            .tftable th {font-size:12px;color:#ffffff;background-color:#69a0be;border-width: 1px;padding: 8px;border-style: solid;border-color: #261d9d;text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable th.centered {background-color:#1068b1;color:#ffffff;text-align:center;font-size:14px;}",
									"            .tftable th.account_table_title {font-size:18px;color:#ffffff;background-color:#1068b1;border-width: 0px;padding: 8px;border-style: none;border-color: #d6e6f0;text-align:left; width: 1px; white-space: nowrap;border-radius:10px 10px 10px 10px;}",
									"            .tftable tr {background-color:#d6e7f0;border-style:none;}",
									"            .tftable td {font-size:14px;border-width: 1px;padding: 8px;border-style: solid;border-color: #d6e9f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable tr:hover {background-color:#d6e9f0;}",
									"            .tftable .hidden_row { display: none;} ",
									"            .tftable .inner th {font-size:14px;background-color:#3573a5;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e4f0;text-align:center; width: 100%; white-space: nowrap;}",
									"            .tftable .inner td {font-size:12px;border-width: 1px;padding: 4px;border-style: solid;border-color: #d6e5f0; text-align:center; width: 1px; white-space: nowrap;}",
									"            .tftable .inner td.descr  {text-align:left !important; }",
									"            .tftable tr.odd {background-color:#ffffff;}",
									"            .tftable tr.even {background-color:#ffffff;}",
									"            .tftable .inner tr.odd {background-color:#c2d8ed;}",
									"            .tftable .inner tr.even {background-color:#c2e5ed;}",
									"            .tftable td.exception {color: #1b02ff; white-space: pre-line;text-align:center;font-size:12px}",
									"            .tftable td.event {white-space: pre-line;text-align:left;font-size:12px}",
									"            .tftable th.stick {background: #6995be; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);}",
									"",
									"        </style>",
									"",
									"        </style>",
									"        <div id=\"content\"></div>",
									"",
									"        <script>",
									"",
									"            const balances = {{{balances}}};",
									"            var addresses = {{{default_account_address}}};",
									"            const accounts = {{{accounts}}};",
									"            var tblHTML = \"\";",
									"",
									"            accounts.forEach(account => {",
									"                if(account.account_id.includes(\"GOLD_FINANCING_ACCOUNT\") )",
									"                     addresses = {{{buckets}}};",
									"                tblHTML = tblHTML + '<table class=\"tftable outer\" border=\"1\">';",
									"                tblHTML = tblHTML + '<tr onclick=\"showHideRow(\\\\\\'' + account.account_id.replace(/ /g, '_') + '\\\\\\');\">';",
									"                tblHTML = tblHTML + '<th class=\"account_table_title\">';",
									"                tblHTML = tblHTML + account.account_id ;",
									"                tblHTML = tblHTML + \"</th>\";",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + '<tr id=\"'  + account.account_id.replace(/ /g, '_') + '\" class=\"hidden_row\"><td>';",
									"                tblHTML = tblHTML + '<table class=\"tftable\" border=\"1\">';",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">DATE</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" rowspan=\"2\">EVENT</th>';",
									"                tblHTML = tblHTML + '<th class=\"centered\" colspan=\"' + addresses.length + '\">BALANCE ADDRESSES</th>';",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                tblHTML = tblHTML + \"<tr>\";",
									"                addresses.forEach(adr => {",
									"                    tblHTML = tblHTML + '<th class=\"stick\">' + adr + \"</th>\";",
									"                });",
									"                tblHTML = tblHTML + \"</tr>\";",
									"                var is_row_even = true;",
									"                var current_date = \"\";",
									"                account.balances.forEach(bal => {",
									"                    var display_date = (current_date == bal[\"date\"]) ? \"\" : bal[\"date\"];",
									"                    if (current_date != bal[\"date\"]) {",
									"                        if (current_date != \"\")",
									"                            is_row_even = !is_row_even; ",
									"                        current_date = bal[\"date\"];",
									"                    } ",
									"                    var tr_class = '\"odd\"';",
									"                    if (is_row_even)",
									"                        tr_class = '\"even\"';",
									"                    tblHTML = tblHTML + '<tr class=' + tr_class + ' onclick=\"showHideRow(\\\\\\'R' + bal.key + '\\\\\\');\">';",
									"                    ",
									"                    tblHTML = tblHTML + \"<td>\" + display_date + \"</td>\";",
									"                    ",
									"",
									"                    if (bal.exception) {",
									"                        tblHTML = tblHTML + '<td class=\"exception\" colspan=\"' + (addresses.length + 1) + '\">' + bal.exception_msg + \"</td>\";",
									"                    } else {",
									"                        tblHTML = tblHTML + '<td class=\"event\" >';",
									"                        if (bal.events[0].includes(\"ACCRUE_INTEREST\")){",
									"                            tblHTML = tblHTML + bal.events[0];",
									"                        } else {",
									"                            tblHTML = tblHTML + \"<b> \" + bal.events[0] + \" </b>\";",
									"                        }",
									"                        tblHTML = tblHTML + \"</td>\";",
									"                        addresses.forEach(adr => {",
									"                            var value = 0.00;",
									"                            if (adr in bal)",
									"                                value = bal[adr];",
									"                            tblHTML = tblHTML + \"<td>\" + value + \"</td>\";",
									"                        });",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        tblHTML = tblHTML + '<tr id=\"R' + bal.key + '\" class=\"hidden_row\">';",
									"                        tblHTML = tblHTML + '<td colspan=4>';",
									"                        tblHTML = tblHTML + '<table class=\"inner\">';",
									"                        tblHTML = tblHTML + \"<tr>\";",
									"                        tblHTML = tblHTML + \"<th>Client Transaction ID</th>\";",
									"                        tblHTML = tblHTML + \"<th>Debit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Credit Account</th>\";",
									"                        tblHTML = tblHTML + \"<th>Amount</th>\";",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                        var is_even = false;",
									"                        bal.instructions.forEach(instr => {",
									"                            var first_row = true;",
									"                            is_even = !is_even;",
									"                            instr.commited.forEach(post => {",
									"                                if (is_even)",
									"                                    tblHTML = tblHTML + '<tr class=\"even\">';",
									"                                else",
									"                                    tblHTML = tblHTML + '<tr class=\"odd\">';",
									"                                tblHTML = tblHTML + '<td class=\"descr\">';",
									"                                if (first_row) tblHTML = tblHTML + instr.description;",
									"                                first_row = false;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (!post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                if (post.credit) {",
									"                                    tblHTML = tblHTML + post.account_id + '/' + post.account_address;",
									"                                } ",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"<td>\";",
									"                                tblHTML = tblHTML + post.amount;",
									"                                tblHTML = tblHTML + \"</td>\";",
									"                                tblHTML = tblHTML + \"</tr>\";    ",
									"                            });",
									"                                ",
									"                        });",
									"                        tblHTML = tblHTML + '</table>';",
									"                        tblHTML = tblHTML + '</td>';",
									"                        tblHTML = tblHTML + \"</tr>\";",
									"                    }",
									"                });",
									"                tblHTML = tblHTML + \"</table>\";",
									"                tblHTML = tblHTML + \"</td></tr>\";",
									"                tblHTML = tblHTML + \"</table>\";",
									"                addresses = {{{default_account_address}}};",
									"            });",
									"            ",
									"            console.log(tblHTML);",
									"            document.getElementById(\"content\").innerHTML = tblHTML;",
									"             function showHideRow(row) { ",
									"                $(\"#\" + row).toggle(); ",
									"            } ",
									"        </script>`;",
									"",
									"// -------------------------",
									"// - Bind data to template -",
									"// -------------------------",
									"// Set the visualizer template",
									"pm.visualizer.set(template, vizData);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{sa_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"start_timestamp\": \"2022-01-01T00:00:00+00:00\",\n    \"end_timestamp\": \"2022-05-10T00:00:00+00:00\",\n    \"smart_contracts\": [\n        {\n            \"code\": \"# Copyright @ 2022 Thought Machine Group Limited. All rights reserved.\\napi = \\\"3.12.0\\\"\\nversion = \\\"0.0.8\\\"\\ndisplay_name = \\\"Gold Financing\\\"\\nsummary = \\\"A financing product based on akad Murabaha from BCA Syariah \\\"\\n\\\"which aims for Logam Mulia (Gold) ownership using Sharia principles\\\"\\ntside = Tside.ASSET\\n\\n# Time zone offset constants\\nWIB_UTC_OFFSET = 0\\n# this can be amended to whichever other currencies as needed\\nsupported_denominations = [\\\"IDR\\\"]\\n\\nnotification_types = [\\n    \\\"GOLD_FINANCING_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n    \\\"GOLD_FINANCING_DELIQUENT\\\",\\n]\\n\\n# Schedule events\\nACCRUE_MARGIN_AND_FEES = \\\"ACCRUE_MARGIN_AND_FEES\\\"\\nREPAYMENT_DAY_SCHEDULE = \\\"REPAYMENT_DAY_SCHEDULE\\\"\\nCHECK_OVERDUE = \\\"CHECK_OVERDUE\\\"\\n\\n# Posting events\\nREPAYMENT_EVENT = \\\"REPAYMENT\\\"\\nSETTLEMENT_EVENT = \\\"SETTLEMENT\\\"\\n\\nevent_types_groups = [\\n    EventTypesGroup(\\n        name=\\\"MARGIN\\\",\\n        event_types_order=[ACCRUE_MARGIN_AND_FEES, REPAYMENT_DAY_SCHEDULE, CHECK_OVERDUE],\\n    ),\\n]\\nevent_types = [\\n    EventType(\\n        name=ACCRUE_MARGIN_AND_FEES,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_ACCRUE_MARGIN_AND_FEES_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=REPAYMENT_DAY_SCHEDULE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_REPAYMENT_DAY_SCHEDULE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n    EventType(\\n        name=CHECK_OVERDUE,\\n        scheduler_tag_ids=[\\\"GOLD_FINANCING_CHECK_OVERDUE_AST\\\", \\\"GOLD_FINANCING_TC_AST\\\"],\\n    ),\\n]\\n\\n# Product Params\\nDENOMINATION = \\\"denomination\\\"\\nEQUIVALENT_RATE = \\\"equivalent_rate\\\"\\nEARLY_MATURITY_MARGIN = \\\"early_maturity_margin\\\"\\nREPAYMENT_PERIOD = \\\"repayment_period\\\"\\nACCRUAL_PRECISION = \\\"accrual_precision\\\"\\nFULFILLMENT_PRECISION = \\\"fulfillment_precision\\\"\\n\\n# Fees\\nTAWIDH_FEE = \\\"tawidh_fee\\\"\\n\\n# Periods\\nTAZIR_PERIOD = \\\"tazir_period\\\"\\nMAXIMUM_DPD = \\\"maximum_dpd\\\"\\n\\n# Schedule Params\\nACCRUE_MARGIN_HOUR = \\\"accrue_margin_hour\\\"\\nACCRUE_MARGIN_MINUTE = \\\"accrue_margin_minute\\\"\\nACCRUE_MARGIN_SECOND = \\\"accrue_margin_second\\\"\\nCHECK_OVERDUE_HOUR = \\\"check_overdue_hour\\\"\\nCHECK_OVERDUE_MINUTE = \\\"check_overdue_minute\\\"\\nCHECK_OVERDUE_SECOND = \\\"check_overdue_second\\\"\\nREPAYMENT_HOUR = \\\"repayment_hour\\\"\\nREPAYMENT_MINUTE = \\\"repayment_minute\\\"\\nREPAYMENT_SECOND = \\\"repayment_second\\\"\\n\\n# Instance Params\\nGOLD_FINANCING_PRINCIPAL = \\\"principal\\\"\\nTOTAL_TERM = \\\"total_term\\\"\\nFIRST_REPAYMENT_DATE = \\\"first_repayment_date\\\"\\nGOLD_FINANCING_START_DATE = \\\"gold_financing_start_date\\\"\\n\\nINSTANCE_PARAMS = [\\n    GOLD_FINANCING_PRINCIPAL,\\n    TOTAL_TERM,\\n    FIRST_REPAYMENT_DATE,\\n    GOLD_FINANCING_START_DATE,\\n]\\n\\n# Derived Params\\nTOTAL_OUTSTANDING = \\\"total_outstanding\\\"\\nGOLD_FINANCING_REMAINING_PRINCIPAL = \\\"gold_financing_remaining_principal\\\"\\nOUTSTANDING_PAYMENTS = \\\"outstanding_payments\\\"\\nREMAINING_TERM = \\\"remaining_term\\\"\\nEXPECTED_EMI = \\\"expected_emi\\\"\\nNEXT_REPAYMENT_DATE = \\\"next_repayment_date\\\"\\nNEXT_OVERDUE_DATE = \\\"next_overdue_date\\\"\\nEARLY_MATURITY_REPAYMENT_AMOUNT = \\\"early_maturity_repayment_amount\\\"\\n\\n# Internal Accounts\\nSUSPENSE_ACCOUNT = \\\"supense_account\\\"\\nDISBURSEMENT_ACCOUNT = \\\"disbursement_account\\\"\\nSETTLEMENT_ACCOUNT = \\\"settlement_account\\\"\\nMARGIN_INCOME_ACCOUNT = \\\"margin_income_account\\\"\\nTAWIDH_FEE_INCOME_ACCOUNT = \\\"tawidh_fee_income_account\\\"\\nMUQASAH_PAYABLE_ACCOUNT = \\\"muqasah_payable_account\\\"\\nTAZIR_FEE_INCOME_ACCOUNT = \\\"tazir_fee_income_account\\\"\\n\\n\\n# Financing Addresses\\nOVERPAYMENT = \\\"OVERPAYMENT\\\"\\nEMI_ADDRESS = \\\"EMI\\\"\\nPRINCIPAL_DUE = \\\"PRINCIPAL_DUE\\\"\\nMARGIN_DUE = \\\"MARGIN_DUE\\\"\\nACCRUED_MARGIN = \\\"ACCRUED_MARGIN\\\"\\nPRINCIPAL = \\\"PRINCIPAL\\\"\\nMARGIN = \\\"MARGIN\\\"\\nPRINCIPAL_OVERDUE = \\\"PRINCIPAL_OVERDUE\\\"\\nMARGIN_OVERDUE = \\\"MARGIN_OVERDUE\\\"\\nINTERNAL_CONTRA = \\\"INTERNAL_CONTRA\\\"\\nTAWIDH_ADDRESS = \\\"TAWIDH\\\"\\nTAZIR_ADDRESS = \\\"TAZIR\\\"\\n\\n# Days calculation\\nDAYS_IN_A_WEEK = 7\\nDAYS_IN_A_MONTH = 30\\nDAYS_IN_A_YEAR = 360\\nWEEKS_IN_YEAR = 52\\nMONTHS_IN_A_YEAR = 12\\n\\n# Repayment Order\\nOVERDUE_ADDRESSES = [PRINCIPAL_OVERDUE, MARGIN_OVERDUE]\\nMARGIN_ADDRESSES = [MARGIN_DUE, MARGIN_OVERDUE]\\nDUE_ADDRESSES = [PRINCIPAL_DUE, MARGIN_DUE]\\nFEES_ADDRESSES = [TAWIDH_ADDRESS, TAZIR_ADDRESS]\\n\\nOVERDUE_ORDER = {\\n    PRINCIPAL_OVERDUE: 0,\\n    MARGIN_OVERDUE: 1,\\n}\\n\\nREPAYMENT_DUES_ORDER = [FEES_ADDRESSES] + [DUE_ADDRESSES]\\n\\nOVERDUE_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    PRINCIPAL_DUE,\\n    MARGIN_OVERDUE,\\n    PRINCIPAL_OVERDUE,\\n]\\n\\nMARGIN_ADDRESS_TYPES = [\\n    MARGIN_DUE,\\n    MARGIN_OVERDUE,\\n]\\n\\n# Parameter Shape\\nRateShape = NumberShape(kind=NumberKind.PERCENTAGE, min_value=0, max_value=1, step=0.0001)\\nMoneyShape = NumberShape(kind=NumberKind.MONEY, min_value=0, step=0.01)\\n\\nparameters = [\\n    # Instance Parameters\\n    Parameter(\\n        name=TOTAL_TERM,\\n        shape=NumberShape(min_value=Decimal(12), max_value=Decimal(60), step=Decimal(1)),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed length of the gold financing (in months).\\\",\\n        display_name=\\\"Loan term (months)\\\",\\n        default_value=Decimal(12),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_PRINCIPAL,\\n        shape=NumberShape(\\n            min_value=Decimal(1),\\n            max_value=Decimal(300000000),\\n            step=Decimal(1),\\n            kind=NumberKind.MONEY,\\n        ),\\n        level=Level.INSTANCE,\\n        description=\\\"The agreed amount the customer will borrow from the bank.\\\",\\n        display_name=\\\"Loan principal\\\",\\n        default_value=Decimal(1),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=FIRST_REPAYMENT_DATE,\\n        shape=OptionalShape(DateShape(min_date=datetime.min, max_date=datetime.max)),\\n        level=Level.INSTANCE,\\n        description=\\\"The selected date which customer will make first repayment.\\\"\\n        \\\" The next monthly repayment day will be derived based on first repayment date.\\\",\\n        display_name=\\\"First Repayment Date\\\",\\n        default_value=OptionalValue(datetime.min),\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_START_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        description=\\\"Start of the gold financing contract terms, either after account opening \\\"\\n        \\\"or top up.\\\",\\n        display_name=\\\"Start date of the Gold Finance\\\",\\n        default_value=datetime.min,\\n        update_permission=UpdatePermission.FIXED,\\n    ),\\n    # Derived Parameters\\n    Parameter(\\n        name=TOTAL_OUTSTANDING,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total balance on this account (including fees).\\\",\\n        display_name=\\\"Total outstanding\\\",\\n    ),\\n    Parameter(\\n        name=GOLD_FINANCING_REMAINING_PRINCIPAL,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Total remaining principal on this account.\\\",\\n        display_name=\\\"Remaining Principal\\\",\\n    ),\\n    Parameter(\\n        name=OUTSTANDING_PAYMENTS,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Unpaid dues, overdues and penalties\\\",\\n        display_name=\\\"Outstanding payments\\\",\\n    ),\\n    Parameter(\\n        name=REMAINING_TERM,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Remaining total term of the gold financing in months\\\",\\n        display_name=\\\"Remaining term in months\\\",\\n    ),\\n    Parameter(\\n        name=EXPECTED_EMI,\\n        shape=NumberShape(),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected EMI (Equated Monthly Installment)\\\",\\n        display_name=\\\"Expected EMI\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_REPAYMENT_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Next scheduled repayment date\\\",\\n        display_name=\\\"Next Repayment date\\\",\\n    ),\\n    Parameter(\\n        name=NEXT_OVERDUE_DATE,\\n        shape=DateShape(min_date=datetime.min, max_date=datetime.max),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"The date on which current due principal and margin will become overdue.\\\",\\n        display_name=\\\"Overdue date\\\",\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_REPAYMENT_AMOUNT,\\n        shape=NumberShape(kind=NumberKind.MONEY),\\n        level=Level.INSTANCE,\\n        derived=True,\\n        description=\\\"Expected amount to be paid for early maturity repayment\\\",\\n        display_name=\\\"Early Maturity Repayment Amount\\\",\\n    ),\\n    # Template Parameters\\n    Parameter(\\n        name=DENOMINATION,\\n        shape=DenominationShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Currency in which the product operates.\\\",\\n        display_name=\\\"Denomination.\\\",\\n        default_value=\\\"IDR\\\",\\n    ),\\n    Parameter(\\n        name=EQUIVALENT_RATE,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin rate used to calculate margin amount.\\\",\\n        display_name=\\\"Equivalent Rate \\\",\\n        default_value=Decimal(\\\"0.09\\\"),\\n    ),\\n    Parameter(\\n        name=EARLY_MATURITY_MARGIN,\\n        shape=RateShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Margin percentage to calculate margin need to be paid by customer \\\"\\n        \\\"during early mature process.\\\",\\n        display_name=\\\"Early Maturity Margin Rate \\\",\\n        default_value=Decimal(\\\"0.02\\\"),\\n    ),\\n    Parameter(\\n        name=REPAYMENT_PERIOD,\\n        shape=NumberShape(max_value=31, min_value=1, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days to repay due amount before incurring penalties.\\\",\\n        display_name=\\\"Repayment period (days)\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=ACCRUE_MARGIN_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which margin is accrued.\\\",\\n        display_name=\\\"Accrue margin second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=CHECK_OVERDUE_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which overdue is checked.\\\",\\n        display_name=\\\"Check overdue second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_HOUR,\\n        shape=NumberShape(min_value=0, max_value=23, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The hour of the day at which due amount is calculated.\\\",\\n        display_name=\\\"Repayment hour\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_MINUTE,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The minute of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment minute\\\",\\n        default_value=1,\\n    ),\\n    Parameter(\\n        name=REPAYMENT_SECOND,\\n        shape=NumberShape(min_value=0, max_value=59, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The second of the day at which which due amount is calculated.\\\",\\n        display_name=\\\"Repayment second\\\",\\n        default_value=0,\\n    ),\\n    Parameter(\\n        name=ACCRUAL_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=15, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin accruals.\\\",\\n        display_name=\\\"Margin accrual precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=FULFILLMENT_PRECISION,\\n        shape=NumberShape(kind=NumberKind.PLAIN, min_value=0, max_value=4, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"Precision needed for margin fulfillment.\\\",\\n        display_name=\\\"Margin fulfillment precision\\\",\\n        default_value=Decimal(2),\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE,\\n        level=Level.TEMPLATE,\\n        description=\\\"The amount of daily ta'widh will be charged at overdue\\\",\\n        display_name=\\\"Ta'widh fee\\\",\\n        shape=MoneyShape,\\n        default_value=Decimal(\\\"2000\\\"),\\n    ),\\n    Parameter(\\n        name=TAZIR_PERIOD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir will accrue since the overdue\\\",\\n        display_name=\\\"Tazir Period\\\",\\n        default_value=10,\\n    ),\\n    Parameter(\\n        name=MAXIMUM_DPD,\\n        shape=NumberShape(min_value=0, step=1),\\n        level=Level.TEMPLATE,\\n        description=\\\"The number of days which tazir and tawidh will not be accrued\\\"\\n        \\\" and send notification to mark the account as deliquent\\\",\\n        display_name=\\\"Maximum Days Past Due\\\",\\n        default_value=90,\\n    ),\\n    # Internal Accounts\\n    Parameter(\\n        name=DISBURSEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"The account to which the principal borrowed amount will be transferred.\\\",\\n        display_name=\\\"Disbursement account\\\",\\n        default_value=DISBURSEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=SETTLEMENT_ACCOUNT,\\n        shape=AccountIdShape,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for settlement balance.\\\",\\n        display_name=\\\"Settlement account\\\",\\n        default_value=SETTLEMENT_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MARGIN_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for margin income balance.\\\",\\n        display_name=\\\"Margin income account\\\",\\n        shape=AccountIdShape,\\n        default_value=MARGIN_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAWIDH_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'widh fee income balance.\\\",\\n        display_name=\\\"Ta'widh fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAWIDH_FEE_INCOME_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=MUQASAH_PAYABLE_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for muqasah payment.\\\",\\n        display_name=\\\"Muqasah payable account\\\",\\n        shape=AccountIdShape,\\n        default_value=MUQASAH_PAYABLE_ACCOUNT,\\n    ),\\n    Parameter(\\n        name=TAZIR_FEE_INCOME_ACCOUNT,\\n        level=Level.TEMPLATE,\\n        description=\\\"Internal account for ta'zir fee income balance.\\\",\\n        display_name=\\\"Ta'zir fee income account\\\",\\n        shape=AccountIdShape,\\n        default_value=TAZIR_FEE_INCOME_ACCOUNT,\\n    ),\\n]\\n\\ncontract_module_imports = [\\n    ContractModule(\\n        alias=\\\"utils\\\",\\n        expected_interface=[\\n            SharedFunction(name=\\\"get_balance_sum\\\"),\\n            SharedFunction(name=\\\"create_schedule_dict_from_datetime\\\"),\\n            SharedFunction(name=\\\"get_parameter\\\"),\\n            SharedFunction(name=\\\"round_decimal\\\"),\\n        ],\\n    )\\n]\\n\\n# Vault hooks\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef execution_schedules():\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=GOLD_FINANCING_START_DATE\\n    )\\n    daily_accrual_schedule = _get_accrue_margin_and_fees_schedule(\\n        vault, gold_financing_start_date.date()\\n    )\\n    monthly_schedule_dict = _get_initial_monthly_schedule(vault)\\n\\n    repayment_day_dict = monthly_schedule_dict.get(REPAYMENT_DAY_SCHEDULE)\\n    check_overdue_dict = monthly_schedule_dict.get(CHECK_OVERDUE)\\n\\n    repayment_day_schedule = {\\n        \\\"day\\\": repayment_day_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": repayment_day_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": repayment_day_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": repayment_day_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    # Check overdue schedule would be runs at the same month as repayment day\\n    check_overdue_schedule = {\\n        \\\"day\\\": check_overdue_dict.get(\\\"day\\\"),\\n        \\\"hour\\\": check_overdue_dict.get(\\\"hour\\\"),\\n        \\\"minute\\\": check_overdue_dict.get(\\\"minute\\\"),\\n        \\\"second\\\": check_overdue_dict.get(\\\"second\\\"),\\n        \\\"month\\\": repayment_day_dict.get(\\\"month\\\"),\\n        \\\"start_date\\\": str(gold_financing_start_date.date()),\\n    }\\n\\n    schedules = [\\n        (ACCRUE_MARGIN_AND_FEES, daily_accrual_schedule),\\n        (REPAYMENT_DAY_SCHEDULE, repayment_day_schedule),\\n        (CHECK_OVERDUE, check_overdue_schedule),\\n    ]\\n\\n    return schedules\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef derived_parameters(effective_date):\\n    total_outstanding = _get_all_outstanding(vault)\\n    next_repayment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    total_term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, TOTAL_TERM))\\n    next_overdue_date = next_repayment_date + timedelta(days=int(repayment_period))\\n    sum_outstanding_dues = _sum_outstanding_dues(vault)\\n    outstanding_actual_principal = _get_outstanding_actual_principal(vault)\\n    return {\\n        TOTAL_OUTSTANDING: total_outstanding,\\n        GOLD_FINANCING_REMAINING_PRINCIPAL: outstanding_actual_principal,\\n        OUTSTANDING_PAYMENTS: sum_outstanding_dues,\\n        NEXT_REPAYMENT_DATE: next_repayment_date,\\n        NEXT_OVERDUE_DATE: next_overdue_date,\\n        REMAINING_TERM: _get_expected_remaining_term(vault, effective_date, total_term),\\n        EXPECTED_EMI: _get_expected_emi(vault, effective_date),\\n        EARLY_MATURITY_REPAYMENT_AMOUNT: _calculate_early_maturity_repayment_amount(\\n            vault, effective_date\\n        ),\\n    }\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True)\\ndef post_activate_code():\\n\\n    account_creation_date = vault.get_account_creation_date()\\n    principal = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL))\\n    disbursement_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DISBURSEMENT_ACCOUNT)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n\\n    monthly_instalment = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, eq_rate, term),\\n        precision,\\n    )\\n    margin_receivable_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_instalment * term) - principal,\\n        precision,\\n    )\\n\\n    posting_ins = []\\n    posting_ins.extend(\\n        vault.make_internal_transfer_instructions(\\n            amount=principal,\\n            denomination=denomination,\\n            client_transaction_id=vault.get_hook_execution_id() + \\\"_PRINCIPAL_DISBURSMENT\\\",\\n            from_account_id=vault.account_id,\\n            from_account_address=PRINCIPAL,\\n            to_account_id=disbursement_account,\\n            to_account_address=DEFAULT_ADDRESS,\\n            instruction_details={\\n                \\\"description\\\": f\\\"Disbursement of {principal} of gold financing principal\\\",\\n                \\\"event\\\": \\\"PRINCIPAL_DISBURSEMENT\\\",\\n            },\\n            asset=DEFAULT_ASSET,\\n            override_all_restrictions=True,\\n        )\\n    )\\n\\n    if margin_receivable_amount > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_receivable_amount,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_MARGIN_RECEIVABLE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Disbursement of {margin_receivable_amount} of gold financing \\\"\\n                    \\\"margin receivable\\\",\\n                    \\\"event\\\": \\\"MARGIN_RECEIVABLE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if monthly_instalment > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=monthly_instalment,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_STORE_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Store monthly installment at \\\"\\n                    f\\\"{denomination}{monthly_instalment} \\\"\\n                    f\\\"of gold financing to {EMI_ADDRESS}\\\",\\n                    \\\"event\\\": \\\"STORE_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    vault.instruct_posting_batch(\\n        posting_instructions=posting_ins,\\n        effective_date=account_creation_date,\\n        client_batch_id=f\\\"BATCH_{vault.get_hook_execution_id()}_INITIAL_GOLD_FINANCING_DISBURSMENT\\\",\\n    )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"ACCRUE_MARGIN_AND_FEES\\\",\\n    parameters=True,\\n    balances=\\\"2 months\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\", \\\"CHECK_OVERDUE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"REPAYMENT_DAY_SCHEDULE\\\",\\n    parameters=True,\\n    balances=\\\"2 days live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    event_type=\\\"CHECK_OVERDUE\\\",\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n    last_execution_time=[\\\"REPAYMENT_DAY_SCHEDULE\\\"],\\n)\\ndef scheduled_code(event_type: str, effective_date: datetime):\\n    posting_instructions = []\\n    new_schedule = None\\n    if event_type == ACCRUE_MARGIN_AND_FEES:\\n        posting_instructions.extend(_handle_accrue_margin_and_fees(vault, effective_date))\\n    elif event_type == REPAYMENT_DAY_SCHEDULE:\\n        posting_instructions.extend(_handle_repayment_due(vault, effective_date))\\n        new_schedule = _get_next_repayment_day_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    elif event_type == CHECK_OVERDUE:\\n        posting_instructions.extend(_handle_overdue(vault, effective_date))\\n        new_schedule = _get_next_check_overdue_schedule(vault, effective_date)\\n        vault.update_event_type(\\n            event_type=event_type, schedule=_create_event_type_schedule_from_dict(new_schedule)\\n        )\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, event_type)\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef pre_posting_code(postings, effective_date):\\n    if len(postings) > 1:\\n        raise Rejected(\\n            \\\"Multiple postings in batch not supported\\\",\\n            reason_code=RejectedReason.CLIENT_CUSTOM_REASON,\\n        )\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    for posting in postings:\\n        if posting.denomination != denomination:\\n            raise Rejected(\\n                \\\"Cannot make transactions in given denomination; \\\"\\n                f\\\"transactions must be in {denomination}\\\",\\n                reason_code=RejectedReason.WRONG_DENOMINATION,\\n            )\\n        proposed_amount = _get_posting_amount(posting)\\n        if proposed_amount <= 0:\\n            if vault.modules[\\\"utils\\\"].str_to_bool(\\n                postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n            ):\\n                early_maturity_repayment_amount = _calculate_early_maturity_repayment_amount(\\n                    vault, effective_date\\n                )\\n                if abs(proposed_amount) != early_maturity_repayment_amount:\\n                    raise Rejected(\\n                        \\\"Does not match the early repayment amount of \\\"\\n                        f\\\"{early_maturity_repayment_amount}\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n            else:\\n                outstanding = _get_all_outstanding(vault)\\n                if abs(proposed_amount) > outstanding:\\n                    raise Rejected(\\n                        \\\"Cannot pay more than is owed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n                maximum_payment = _sum_outstanding_dues(vault)\\n                if abs(proposed_amount) > maximum_payment:\\n                    raise Rejected(\\n                        \\\"Overpayment transaction is not allowed\\\",\\n                        reason_code=RejectedReason.AGAINST_TNC,\\n                    )\\n\\n        elif not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"fee\\\", \\\"false\\\")\\n        ) and not vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"interest_adjustment\\\", \\\"false\\\")\\n        ):\\n            raise Rejected(\\n                \\\"Debiting not allowed from this account\\\",\\n                reason_code=RejectedReason.AGAINST_TNC,\\n            )\\n\\n\\n@requires(modules=[\\\"utils\\\"], parameters=True, balances=\\\"latest live\\\")\\ndef post_posting_code(postings: PostingInstructionBatch, effective_date: datetime):\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_amount = _get_posting_batch_amount(postings, denomination)\\n    posting_instructions = []\\n    if posting_amount < 0:\\n        client_transaction_id = (\\n            f\\\"{postings[0].client_transaction_id}_{vault.get_hook_execution_id()}\\\"\\n        )\\n        if vault.modules[\\\"utils\\\"].str_to_bool(\\n            postings.batch_details.get(\\\"early_maturity_repayment\\\", \\\"false\\\")\\n        ):\\n            posting_instructions.extend(\\n                _process_early_maturity(\\n                    vault, effective_date, posting_amount, client_transaction_id\\n                )\\n            )\\n        else:\\n            posting_instructions.extend(\\n                _process_payment(vault, effective_date, posting_amount, client_transaction_id)\\n            )\\n\\n    if posting_instructions:\\n        _instruct_posting_batch(vault, posting_instructions, effective_date, REPAYMENT_EVENT)\\n\\n\\n@requires(parameters=True)\\ndef pre_parameter_change_code(parameters, effective_date):\\n    if any(param in INSTANCE_PARAMS for param in parameters):\\n        raise Rejected(\\n            \\\"Cannot update the parameter after account is created\\\",\\n            reason_code=RejectedReason.AGAINST_TNC,\\n        )\\n\\n\\n@requires(\\n    modules=[\\\"utils\\\"],\\n    parameters=True,\\n    balances=\\\"latest live\\\",\\n)\\ndef close_code(effective_date: datetime):\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n    # Check current outstanding balance\\n    outstanding_balance = _get_all_outstanding(vault)\\n    posting_ins = []\\n\\n    # Create settlement posting instrution if there is outstanding balance left in account\\n    cti_settlement = f\\\"{vault.get_hook_execution_id()}_{SETTLEMENT_EVENT}\\\"\\n    if outstanding_balance > 0:\\n        settlemnet_account = vault.modules[\\\"utils\\\"].get_parameter(vault, SETTLEMENT_ACCOUNT)\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_balance,\\n                denomination=denomination,\\n                client_transaction_id=cti_settlement,\\n                to_account_id=vault.account_id,\\n                to_account_address=DEFAULT_ADDRESS,\\n                from_account_id=settlemnet_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                asset=DEFAULT_ASSET,\\n                instruction_details={\\n                    \\\"event\\\": SETTLEMENT_EVENT,\\n                    \\\"description\\\": \\\"Settle all outstanding balance before close the account\\\"\\n                    f\\\" at {denomination}{outstanding_balance}\\\",\\n                },\\n                override_all_restrictions=True,\\n            )\\n        )\\n        # Create repayment order for settlement\\n        posting_ins.extend(\\n            _process_payment(vault, effective_date, outstanding_balance, cti_settlement)\\n        )\\n\\n        # Pay Outstanding Principal and Margin\\n        outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL])\\n        outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN])\\n        margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, name=MARGIN_INCOME_ACCOUNT\\n        )\\n        # repay outstanding principal\\n        if outstanding_principal > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_principal,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=PRINCIPAL,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                        f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"SETTLEMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n        # record margin as income\\n        if outstanding_margin > 0:\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"REPAY_{MARGIN}_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=margin_income_account,\\n                    to_account_address=DEFAULT_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"SETTLEMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n            posting_ins.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=outstanding_margin,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{MARGIN}_INCOME_{cti_settlement}\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=DEFAULT_ADDRESS,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=MARGIN,\\n                    instruction_details={\\n                        \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                        f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                        \\\"event\\\": \\\"SETTLEMENT\\\",\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n    \\n    # clear EMI\\n    if emi > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {EMI_ADDRESS}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING_EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        posting_ins.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{cti_settlement}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {ACCRUED_MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{ACCRUED_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if len(posting_ins) > 0:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_ins,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"CLOSE_ACCOUNT-{vault.get_hook_execution_id()}\\\",\\n        )\\n\\n\\n# Helper Functions\\ndef _handle_accrue_margin_and_fees(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate daily margin and fees accrual posting instructions at\\n    the effective datetime\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle daily margin and fees accrual\\n    \\\"\\\"\\\"\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    margin_accrual_date = _get_balance_date_for_margin_accrual(vault)\\n\\n    outstanding_principal = _get_outstanding_actual_principal(vault, margin_accrual_date)\\n\\n    outstanding_accrue = _get_accrued_margin(vault, effective_date)\\n\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    margin_data = _get_daily_margin_accrual(\\n        vault,\\n        outstanding_principal,\\n        outstanding_accrue,\\n        margin_rate,\\n        effective_date,\\n    )\\n\\n    margin_to_accrue = margin_data[\\\"margin_to_accrue\\\"]\\n\\n    posting_instructions = []\\n    if margin_to_accrue > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_accrue,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_MARGIN_ACCRUAL\\\"\\n                f\\\"_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=ACCRUED_MARGIN,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Daily margin accrued at \\\"\\n                    f\\\"{(margin_rate/DAYS_IN_A_YEAR) * 100:0.6f}\\\",\\n                    \\\"event_type\\\": ACCRUE_MARGIN_AND_FEES,\\n                    \\\"daily_margin_rate\\\": f\\\"{(margin_rate/DAYS_IN_A_YEAR)}\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # Check late repayment fee will get all the overdue addresses and apply\\n    # fee for every overdue installment\\n    posting_instructions.extend(_check_late_repayment_fee(vault, effective_date))\\n\\n    return posting_instructions\\n\\n\\ndef _handle_repayment_due(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Calculate monthly repayment installment which consist of principal due\\n    and margin due\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to handle repayment day\\n    \\\"\\\"\\\"\\n    margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n\\n    monthly_due_amounts = _calculate_monthly_payment_margin_and_principal(\\n        vault, margin_rate, effective_date\\n    )\\n    posting_instructions = _get_transfer_due_instructions(\\n        vault=vault,\\n        effective_date=effective_date,\\n        monthly_due_amounts=monthly_due_amounts,\\n        event_type=\\\"CALCULATE_AND_TRANSFER_DUE_AMOUNT\\\",\\n    )\\n\\n    _send_repayment_notification(vault, effective_date, monthly_due_amounts)\\n\\n    return posting_instructions\\n\\n\\ndef _handle_overdue(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Move unpaid due amount to overdue, charge penalty fee\\n    and schedule for delinquency check after grace period\\n    :param vault: parameters, balances\\n    :param effective_date: datetime\\n    :return: list of posting instructions to handle overdue\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=1)\\n    posting_instructions = []\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, PRINCIPAL_DUE, PRINCIPAL_OVERDUE, effective_date)\\n    )\\n    posting_instructions.extend(\\n        _get_overdue_postings(vault, MARGIN_DUE, MARGIN_OVERDUE, effective_date)\\n    )\\n    additional_fee = 0\\n    if len(posting_instructions) > 0:\\n        # Add late repayment fee at the first time it's become overdue for 1 installment only\\n        tazir_fee = 0\\n        if _is_apply_tazir_for_overdue(vault, effective_date):\\n            due_balance = vault.modules[\\\"utils\\\"].get_balance_sum(vault, DUE_ADDRESSES)\\n            precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n            eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n            tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                (due_balance * eq_rate / DAYS_IN_A_YEAR), precision\\n            )\\n        post_ins, additional_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, 1, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, additional_fee)\\n\\n    return posting_instructions\\n\\n\\n# Part of repayment day schedule\\ndef _get_transfer_due_instructions(\\n    vault,\\n    effective_date: datetime,\\n    monthly_due_amounts: Dict[str, Decimal],\\n    event_type: str,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Return a list of PostingInstructions to transfer\\n    funds based on the monthly due amounts.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param monthly_due_amount: Dict[str, Decimal]\\n    :param event_type: str\\n    :return list of posting instructions to transfer due and EMI balance\\n    \\\"\\\"\\\"\\n    effective_date = effective_date + timedelta(microseconds=2)\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, DENOMINATION)\\n\\n    emi = monthly_due_amounts.get(\\\"emi\\\", Decimal(\\\"0\\\"))\\n    principal_due = monthly_due_amounts.get(\\\"principal_due\\\", Decimal(\\\"0\\\"))\\n    margin_due = monthly_due_amounts.get(\\\"margin_due\\\", Decimal(\\\"0\\\"))\\n\\n    stored_emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n\\n    posting_instructions = []\\n    if emi > 0 and emi != stored_emi:\\n        if stored_emi > 0:\\n            posting_instructions.extend(\\n                vault.make_internal_transfer_instructions(\\n                    amount=stored_emi,\\n                    denomination=denomination,\\n                    client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_STORED_EMI\\\",\\n                    from_account_id=vault.account_id,\\n                    from_account_address=INTERNAL_CONTRA,\\n                    to_account_id=vault.account_id,\\n                    to_account_address=EMI_ADDRESS,\\n                    instruction_details={\\n                        \\\"description\\\": \\\"Clearing stored EMI amount\\\",\\n                        \\\"event\\\": event_type,\\n                    },\\n                    asset=DEFAULT_ASSET,\\n                    override_all_restrictions=True,\\n                )\\n            )\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_UPDATE_STORED_EMI\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=EMI_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                instruction_details={\\n                    \\\"description\\\": \\\"Updating stored EMI amount\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if principal_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=principal_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_PAYMENT_PERIOD_PRINCIPAL_DUE\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=PRINCIPAL_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly principal added to due address: {principal_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    if margin_due > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id()\\n                + \\\"_APPLY_ACCRUED_MARGIN_CUSTOMER\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=MARGIN_DUE,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Monthly margin added to due address: {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_due,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{vault.get_hook_execution_id()}_CLEAR_ACCRUED_MARGIN\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clear accrued margin of : {margin_due}\\\",\\n                    \\\"event\\\": event_type,\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return posting_instructions\\n\\n\\ndef _send_repayment_notification(vault, effective_date: datetime, monthly_due: Dict[str, Decimal]):\\n    \\\"\\\"\\\"\\n    Instruct a repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param monthly_due: Dict[str, Decimal], monthly due values\\n    :return: None\\n    \\\"\\\"\\\"\\n    repayment_amount = monthly_due.get(\\\"principal_due\\\", Decimal(\\\"0\\\")) + monthly_due.get(\\n        \\\"margin_due\\\", Decimal(\\\"0\\\")\\n    )\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    overdue_date = effective_date + timedelta(days=int(repayment_period))\\n\\n    vault.instruct_notification(\\n        notification_type=\\\"GOLD_FINANCING_REPAYMENT\\\",\\n        notification_details={\\n            \\\"account_id\\\": vault.account_id,\\n            \\\"repayment_amount\\\": str(repayment_amount),\\n            \\\"overdue_date\\\": str(overdue_date.date()),\\n        },\\n    )\\n\\n\\ndef _process_payment(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower, paying off the balance in different addresses\\n    in the correct order\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str\\n    :return: List[PostingInstruction]\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    balances = vault.get_balance_timeseries().latest()\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    repayment_amount_remaining = abs(repayment_amount)\\n    sorted_repayment_addresses = _get_sorted_repayment_addresses(denomination, balances)\\n    repayment_instructions = []\\n    for repayment_order in sorted_repayment_addresses:\\n        sum_repayment_order = vault.modules[\\\"utils\\\"].get_balance_sum(vault, repayment_order)\\n        rounded_address_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n            sum_repayment_order, fulfillment_precision\\n        )\\n        if rounded_address_balance and repayment_amount_remaining > 0:\\n\\n            repayment_amount = min(repayment_amount_remaining, rounded_address_balance)\\n            repayment_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                repayment_amount, fulfillment_precision\\n            )\\n\\n            remaining_amount = 0\\n            for debt_address in repayment_order:\\n                debt_balance = _get_effective_balance_by_address(vault, debt_address)\\n                rounded_debt_balance = vault.modules[\\\"utils\\\"].round_decimal(\\n                    debt_balance, fulfillment_precision\\n                )\\n\\n                proportion_amount = vault.modules[\\\"utils\\\"].round_decimal(\\n                    (repayment_amount / rounded_address_balance) * rounded_debt_balance,\\n                    fulfillment_precision,\\n                )\\n                posting_amount = remaining_amount if remaining_amount > 0 else proportion_amount\\n\\n                if proportion_amount > 0:\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"REPAY_{debt_address}_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=DEFAULT_ADDRESS,\\n                            to_account_id=vault.account_id,\\n                            to_account_address=debt_address,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": \\\"REPAYMENT\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n                if (\\n                    _get_parameters_from_finance_address(debt_address)[\\\"address_type\\\"]\\n                    in MARGIN_ADDRESS_TYPES\\n                ):\\n                    repayment_instructions.extend(\\n                        vault.make_internal_transfer_instructions(\\n                            amount=posting_amount,\\n                            denomination=denomination,\\n                            client_transaction_id=f\\\"{debt_address}_INCOME_{client_transaction_id}\\\",\\n                            from_account_id=vault.account_id,\\n                            from_account_address=INTERNAL_CONTRA,\\n                            to_account_id=margin_income_account,\\n                            to_account_address=DEFAULT_ADDRESS,\\n                            instruction_details={\\n                                \\\"description\\\": f\\\"Paying off {posting_amount} from {debt_address}, \\\"\\n                                f\\\"which was at {rounded_debt_balance} - {effective_date}\\\",\\n                                \\\"event\\\": f\\\"{debt_address}_INCOME\\\",\\n                            },\\n                            asset=DEFAULT_ASSET,\\n                            override_all_restrictions=True,\\n                        )\\n                    )\\n\\n                # The 2nd sequence of repayment order would has remaining amount\\n                # instead of calculate the portion due to rounding calculate and the balance\\n                # must be 0 at the end of payment process.\\n                remaining_amount = repayment_amount - posting_amount\\n                repayment_amount_remaining -= posting_amount\\n\\n    return repayment_instructions\\n\\n\\ndef _process_early_maturity(\\n    vault, effective_date: datetime, repayment_amount: Decimal, client_transaction_id: str\\n):\\n    \\\"\\\"\\\"\\n    Processes a payment received from the borrower for early maturity repayment,\\n    paying off the balance in different addresses\\n    in the correct order\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime , date and time of hook being run\\n    :param repayment_amount: Decimal\\n    :param client_transaction_id: str, base client_transaction_id to be extended with event\\n    information\\n    :return: None\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    repayment_instructions = []\\n\\n    repayment_instructions.extend(\\n        _process_payment(vault, effective_date, repayment_amount, client_transaction_id)\\n    )\\n    # get balances\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, [PRINCIPAL], effective_date\\n    )\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], effective_date)\\n    margin_to_paid = _calculate_early_maturity_margin_to_be_paid(vault, effective_date)\\n    accrued_margin = _get_accrued_margin(vault)\\n    emi = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS], effective_date)\\n    muqasah_amount = _calculate_muqasah_amount(vault, effective_date)\\n\\n    # get internal account\\n    muqasah_payable_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=MUQASAH_PAYABLE_ACCOUNT\\n    )\\n    margin_income_account = vault.modules[\\\"utils\\\"].get_parameter(vault, name=MARGIN_INCOME_ACCOUNT)\\n\\n    # repay outstanding principal\\n    if outstanding_principal > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_principal,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"REPAY_{PRINCIPAL}_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=PRINCIPAL,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_principal} from {PRINCIPAL}, \\\"\\n                    f\\\"which was at {outstanding_principal} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # record margin as income\\n    if outstanding_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=outstanding_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{INTERNAL_CONTRA}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=margin_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {outstanding_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {outstanding_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=margin_to_paid,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MARGIN}_INCOME_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {margin_to_paid} from {MARGIN}, \\\"\\n                    f\\\"which was at {margin_to_paid} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"REPAYMENT\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # clear EMI\\n    if emi > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=emi,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{EMI_ADDRESS}_CLEAR_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=EMI_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Clearing {emi} from {MARGIN}, \\\"\\n                    f\\\"which was at {emi} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"CLEARING EMI\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # reverse accrue margin to contra\\n    if accrued_margin > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=accrued_margin,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{ACCRUED_MARGIN}_REVERSE_{client_transaction_id}\\\",\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=ACCRUED_MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Paying off {accrued_margin} from {MARGIN}, \\\"\\n                    f\\\"which was at {accrued_margin} - {effective_date}\\\",\\n                    \\\"event\\\": \\\"{ACCRUE_MARGIN}_REVERSE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    # discount on margin\\n    if muqasah_amount > 0:\\n        repayment_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=muqasah_amount,\\n                denomination=denomination,\\n                client_transaction_id=f\\\"{MUQASAH_PAYABLE_ACCOUNT}_WRITEOFF_{client_transaction_id}\\\",\\n                from_account_id=muqasah_payable_account,\\n                from_account_address=DEFAULT_ADDRESS,\\n                to_account_id=vault.account_id,\\n                to_account_address=MARGIN,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Writing off {muqasah_amount} from {MUQASAH_PAYABLE_ACCOUNT}, \\\"\\n                    f\\\"which was at {muqasah_amount} - {effective_date}\\\",\\n                    \\\"event\\\": f\\\"{MARGIN}_WRITEOFF\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    return repayment_instructions\\n\\n\\ndef _get_next_repayment_day_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next repayment day schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of REPAYMENT_SCHEDULE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(repayment_schedule_date)\\n\\n\\ndef _get_initial_monthly_schedule(vault) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the initial repayment day and check overdue schedule\\n\\n    :param vault: Vault object\\n    :return: tuple, representation of initial REPAYMENT_SCHEDULE and CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    first_overdue_date = _get_overdue_schedule(vault, first_repayment_date)\\n\\n    first_repayment_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_repayment_date\\n    )\\n    first_overdue_schedule = vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(\\n        first_overdue_date\\n    )\\n\\n    return {\\n        REPAYMENT_DAY_SCHEDULE: first_repayment_schedule,\\n        CHECK_OVERDUE: first_overdue_schedule,\\n    }\\n\\n\\n# Overdue helper functions\\ndef _get_overdue_postings(\\n    vault, due_address: str, overdue_address: str, effective_date: datetime\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Instruct posting instructions to move balance between due and overdue address\\n    :param vault: Vault object\\n    :param due_address: str, due address balance name\\n    :param overdue_address: str, overdue address balance name\\n    :param effective_date: datetime\\n    :return list of posting instructions which moves due to overdue\\n    \\\"\\\"\\\"\\n    amount_to_transfer = _get_effective_balance_by_address(vault, due_address)\\n\\n    if amount_to_transfer == 0:\\n        return []\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n\\n    current_month_index = _get_current_term_index(vault, effective_date)\\n\\n    return vault.make_internal_transfer_instructions(\\n        amount=amount_to_transfer,\\n        denomination=denomination,\\n        client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + overdue_address,\\n        from_account_id=vault.account_id,\\n        from_account_address=f\\\"{overdue_address}_{current_month_index}\\\",\\n        to_account_id=vault.account_id,\\n        to_account_address=due_address,\\n        instruction_details={\\n            \\\"description\\\": f\\\"Mark outstanding due amount of \\\"\\n            f\\\"{amount_to_transfer} as {overdue_address}_{current_month_index}.\\\",\\n            \\\"event\\\": \\\"MOVE_BALANCE_INTO_\\\" + overdue_address,\\n        },\\n        asset=DEFAULT_ASSET,\\n        override_all_restrictions=True,\\n    )\\n\\n\\ndef _check_late_repayment_fee(vault, effective_date: datetime) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Check if there are overdue balance in the account, then it will instruct\\n    posting to accruing the daily late repaymet fee\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return list of posting instructions to apply daily late repayment fee\\n    \\\"\\\"\\\"\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    eq_rate = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tazir_period = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAZIR_PERIOD))\\n    maximum_dpd = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=MAXIMUM_DPD))\\n    overdue_addresses = _get_sorted_overdue_addresses(denomination, balances)\\n    tawidh_number = 0\\n    tazir_fee = 0\\n    posting_instructions = []\\n\\n    if len(overdue_addresses) > 0:\\n        # Check the latest overdue bucket balance for applying tazir fee\\n        check_overdue_last_execution = vault.get_last_execution_time(event_type=CHECK_OVERDUE)\\n        latest_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_addresses[0])\\n        if check_overdue_last_execution and latest_overdue_bucket > 0:\\n            is_accrue_tazir = _is_apply_tazir_for_overdue(vault, check_overdue_last_execution)\\n            dpd_number = _calculate_days_past_due(vault, overdue_addresses[0], effective_date)\\n            if dpd_number == maximum_dpd:\\n                # If the account has days past due equal to 90 days, then it will\\n                # send notification to mark the account as deliquent\\n                _send_deliquent_notification(vault, effective_date)\\n            if is_accrue_tazir and dpd_number <= tazir_period:\\n                emi_amount = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [EMI_ADDRESS])\\n                tazir_fee = vault.modules[\\\"utils\\\"].round_decimal(\\n                    ((eq_rate / DAYS_IN_A_YEAR) * emi_amount), precision\\n                )\\n\\n        # Apply ta'widh fee for each overdue installment\\n        for overdue_bucket in overdue_addresses:\\n            sum_overdue_bucket = vault.modules[\\\"utils\\\"].get_balance_sum(vault, overdue_bucket)\\n            if sum_overdue_bucket > 0:\\n                tawidh_number += 1\\n\\n    total_fee = 0\\n    if tawidh_number > 0 or tazir_fee > 0:\\n        post_ins, total_fee = _get_late_repayment_fee_postings(\\n            vault, effective_date, tawidh_number, tazir_fee\\n        )\\n        posting_instructions.extend(post_ins)\\n\\n    _send_overdue_repayment_notification(vault, effective_date, total_fee)\\n\\n    return posting_instructions\\n\\n\\ndef _get_late_repayment_fee_postings(\\n    vault, effective_date: datetime, tawidh_number: int, tazir_fee: Decimal\\n) -> Tuple[List[PostingInstruction], Decimal]:\\n    \\\"\\\"\\\"\\n    Get daily late repayment fee posting as it's overdue\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :param tawidh_number: int, the number of tawidh fee will be applied\\n    :param tazir_fee: Decimal, the amount of tazir fee will be applied\\n    :return list of posting instructions to apply late repayment fee\\n    and total fee amount being charged\\n    \\\"\\\"\\\"\\n\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    posting_instructions = []\\n    tawidh_fee = Decimal(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TAWIDH_FEE))\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION))\\n    tawidh_fee = vault.modules[\\\"utils\\\"].round_decimal((tawidh_fee * tawidh_number), precision)\\n    tawidh_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAWIDH_FEE_INCOME_ACCOUNT\\n    )\\n    tazir_fee_income_account = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=TAZIR_FEE_INCOME_ACCOUNT\\n    )\\n    if tawidh_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tawidh_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAWIDH_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAWIDH_ADDRESS,\\n                to_account_id=tawidh_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'widh fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAWIDH_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n    if tazir_fee > 0:\\n        posting_instructions.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=tazir_fee,\\n                denomination=denomination,\\n                client_transaction_id=vault.get_hook_execution_id() + \\\"_\\\" + TAZIR_ADDRESS,\\n                from_account_id=vault.account_id,\\n                from_account_address=TAZIR_ADDRESS,\\n                to_account_id=tazir_fee_income_account,\\n                to_account_address=DEFAULT_ADDRESS,\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Apply ta'zir fee for the overdue at {effective_date.date()}.\\\",\\n                    \\\"event\\\": \\\"APPLY_TAZIR_FEE\\\",\\n                },\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n            )\\n        )\\n\\n    total_fee = tawidh_fee + tazir_fee\\n    return posting_instructions, total_fee\\n\\n\\ndef _is_apply_tazir_for_overdue(vault, effective_date: datetime) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the previous month has no overdue or the overdue installment has been\\n    already repay\\n\\n    :param vault: Vault object,\\n    :param effective_date: datetime,\\n    :return boolean to indicates applying tazir\\n    \\\"\\\"\\\"\\n\\n    previous_installment_no = str(_get_current_term_index(vault, effective_date) - 1)\\n    if int(previous_installment_no) < 1:\\n        return True\\n    overdue_bucket = [\\n        PRINCIPAL_OVERDUE + \\\"_\\\" + previous_installment_no,\\n        MARGIN_OVERDUE + \\\"_\\\" + previous_installment_no,\\n    ]\\n\\n    current_overdue_balance = vault.modules[\\\"utils\\\"].get_balance_sum(\\n        vault, overdue_bucket, effective_date\\n    )\\n\\n    if current_overdue_balance == 0:\\n        return True\\n\\n    return False\\n\\n\\ndef _get_next_check_overdue_schedule(\\n    vault,\\n    effective_date: datetime,\\n) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Sets up dictionary for the next check overdue schedule\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, date and time of hook being run\\n    :return: dict, representation of CHECK_OVERDUE schedule\\n    \\\"\\\"\\\"\\n\\n    repayment_schedule_date = _calculate_next_repayment_date(\\n        vault,\\n        effective_date,\\n    )\\n    next_overdue_schedule = _get_overdue_schedule(vault, repayment_schedule_date)\\n\\n    return vault.modules[\\\"utils\\\"].create_schedule_dict_from_datetime(next_overdue_schedule)\\n\\n\\ndef _send_overdue_repayment_notification(vault, effective_date: datetime, additional_fee: Decimal):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    :param additional_fee: Decimal, additional fee added to outstanding due\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_OVERDUE_REPAYMENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"repayment_amount\\\": str(outstanding_dues + additional_fee),\\n                \\\"overdue_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _send_deliquent_notification(vault, effective_date: datetime):\\n    \\\"\\\"\\\"\\n     Instruct an overdue repayment notification.\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime, effective date of scheduled event\\n    \\\"\\\"\\\"\\n    outstanding_dues = _sum_outstanding_dues(vault, effective_date)\\n    if abs(outstanding_dues) > 0:\\n        vault.instruct_notification(\\n            notification_type=\\\"GOLD_FINANCING_DELIQUENT\\\",\\n            notification_details={\\n                \\\"account_id\\\": vault.account_id,\\n                \\\"deliquent_date\\\": str(effective_date.date()),\\n            },\\n        )\\n\\n\\ndef _get_current_term_index(vault, effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    The value returned is the index of current month that effective date is currently\\n    in on the scale form 1 to loan tenor. Hence it is equal to the number of passed repayment due\\n    days\\n    \\\"\\\"\\\"\\n    tenor = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, tenor)\\n\\n    return tenor - remaining_term\\n\\n\\n# Calculate helper functions\\ndef _calculate_monthly_instalment(\\n    outstanding_principal: Decimal, margin_rate: Decimal, total_term: int\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly installment amount at outstanding principal\\n\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :param total_term: int\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return (outstanding_principal * margin_rate / 12) / (\\n        1 - ((1 + (margin_rate / 12)) ** (-total_term))\\n    )\\n\\n\\ndef _calculate_monthly_margin(\\n    vault,\\n    precision: int,\\n    outstanding_principal: Decimal,\\n    margin_rate: Decimal,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Calculate monthly margin amount at outstanding principal\\n\\n    :param vault: Vault object\\n    :param precision: int\\n    :param outstanding_principal: Decimal\\n    :param margin_rate: Decimal\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * margin_rate / 12), precision\\n    )\\n\\n\\ndef _calculate_next_repayment_date(vault, effective_date: datetime) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, GOLD_FINANCING_START_DATE\\n    )\\n\\n    last_execution_time = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n\\n    # Localizing effective date to WIB timezone for calculation of next repayment date\\n    localized_effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    repayment_day = gold_financing_start_date.day\\n\\n    if first_repayment_date:\\n        next_payment_date = first_repayment_date + timedelta(\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        if next_payment_date > localized_effective_date:\\n            return next_payment_date\\n        else:\\n            repayment_day = first_repayment_date.day\\n\\n    earliest_event_start_date = gold_financing_start_date + timedelta(days=1)\\n\\n    if last_execution_time:\\n        # Localizing repayment schedule last execution time\\n        # to WIB timezone for calculation of next repayment date\\n        localized_last_execution_time = last_execution_time + timedelta(hours=WIB_UTC_OFFSET)\\n        while localized_last_execution_time <= localized_effective_date:\\n            localized_last_execution_time += timedelta(months=1)\\n\\n        next_payment_date = localized_last_execution_time + timedelta(\\n            day=repayment_day,\\n            hour=repayment_hour,\\n            minute=repayment_minute,\\n            second=repayment_second,\\n            microsecond=0,\\n        )\\n\\n        return next_payment_date\\n\\n    next_payment_date = localized_effective_date + timedelta(\\n        day=repayment_day,\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    if (\\n        next_payment_date <= localized_effective_date\\n        or next_payment_date <= earliest_event_start_date\\n    ):\\n        next_payment_date += timedelta(months=1)\\n\\n    return next_payment_date\\n\\n\\ndef _calculate_first_repayment_date(vault) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate first repayment schedule date at the effective date\\n\\n    :param vault: Vault object\\n    :return datetime\\n    \\\"\\\"\\\"\\n\\n    repayment_hour = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_HOUR)\\n    repayment_minute = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_MINUTE)\\n    repayment_second = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_SECOND)\\n\\n    first_repayment_date = vault.modules[\\\"utils\\\"].get_parameter(\\n        vault, name=FIRST_REPAYMENT_DATE, optional=True\\n    )\\n    if first_repayment_date is None:\\n        gold_financing_start_date = vault.modules[\\\"utils\\\"].get_parameter(\\n            vault, GOLD_FINANCING_START_DATE\\n        )\\n        first_repayment_date = gold_financing_start_date + timedelta(months=1)\\n\\n    first_repayment_date = first_repayment_date + timedelta(\\n        hour=repayment_hour,\\n        minute=repayment_minute,\\n        second=repayment_second,\\n        microsecond=0,\\n    )\\n\\n    return first_repayment_date\\n\\n\\ndef _calculate_early_maturity_margin_to_be_paid(\\n    vault,\\n    timestamp: datetime,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the amount of margin that must be paid during the early maturity repayment process\\n    The formula is :\\n        (Outstanding Principal * early maturity margin rate) + accrued margin\\n    The amount of margin that must be paid should be less than or equal the outstanding margin\\n    :param vault: Vault Object to get the parameter and balance of current the account\\n    :param timestamp: timestamp of the balance to check\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    early_maturity_margin_percentage = Decimal(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, EARLY_MATURITY_MARGIN)\\n    )\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    expected_margin_to_be_paid = vault.modules[\\\"utils\\\"].round_decimal(\\n        (outstanding_principal * early_maturity_margin_percentage) + accrued_margin,\\n        fulfillment_precision,\\n    )\\n\\n    return min(expected_margin_to_be_paid, outstanding_margin)\\n\\n\\ndef _calculate_early_maturity_repayment_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Returns the value of the payment that must be made to make early maturity posting\\n    The Formula is :\\n        Outstanding Principal + Margin amount to be Paid + All outstanding Due\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_principal = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n    all_outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal + margin_amount_to_be_paid + all_outstanding_due,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _calculate_muqasah_amount(vault, timestamp: datetime) -> Decimal:\\n    \\\"\\\"\\\"\\n    Return the discount amount (Muqasah) that applies to early maturity repayment\\n    The Formula is :\\n        outstanding_margin - Margin amount to be Paid\\n\\n    :param vault: Vault Object\\n    :param timestamp: datetime\\n    :return Decimal\\n    \\\"\\\"\\\"\\n\\n    outstanding_margin = vault.modules[\\\"utils\\\"].get_balance_sum(vault, [MARGIN], timestamp)\\n\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    margin_amount_to_be_paid = _calculate_early_maturity_margin_to_be_paid(vault, timestamp)\\n\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_margin - margin_amount_to_be_paid,\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _create_margin_remainder_posting(\\n    vault,\\n    margin_address: str,\\n    actual_balance: Decimal,\\n    rounded_balance: Decimal,\\n    event_type: str,\\n    denomination: str,\\n    include_address_in_client_transaction_id: bool = False,\\n) -> List[PostingInstruction]:\\n    \\\"\\\"\\\"\\n    Creates and returns posting instructions for handling remainder on MARGIN address due to\\n    any difference in accrual and fulfilment precision.\\n    If positive, margin was rounded down and exra margin was charged to customer.\\n    If negative, margin was rounded up and extra margin was returned to customer.\\n\\n    :param vault: Vault object\\n    :param margin_address: str, margin address on which to handle remainder\\n    :param actual_balance: Decimal, margin balance amount prior to application\\n    :param rounded_balance: Decimal, rounded margin amount that was applied\\n    :param event_type: str, event which triggered the margin application\\n    :param denomination: str, denomination used for account\\n    :param include_address_in_client_transaction_id: bool, if True then we include the address\\n    when constructing the client transaction id, to ensure uniqueness.\\n    :return: list of posting instructions to handle margin remainder\\n    \\\"\\\"\\\"\\n    hook_execution_id = vault.get_hook_execution_id()\\n    margin_remainder = actual_balance - rounded_balance\\n    margin_remainder_postings = []\\n    if include_address_in_client_transaction_id:\\n        client_transaction_id = (\\n            f\\\"{event_type}_{margin_address}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n        )\\n    else:\\n        client_transaction_id = f\\\"{event_type}_REMAINDER_{hook_execution_id}_{denomination}\\\"\\n    if margin_remainder < 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=margin_address,\\n                to_account_id=vault.account_id,\\n                to_account_address=INTERNAL_CONTRA,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin charged to customer from negative remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded up\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n    elif margin_remainder > 0:\\n        margin_remainder_postings.extend(\\n            vault.make_internal_transfer_instructions(\\n                amount=abs(margin_remainder),\\n                denomination=denomination,\\n                from_account_id=vault.account_id,\\n                from_account_address=INTERNAL_CONTRA,\\n                to_account_id=vault.account_id,\\n                to_account_address=margin_address,\\n                asset=DEFAULT_ASSET,\\n                override_all_restrictions=True,\\n                client_transaction_id=f\\\"{client_transaction_id}_CUSTOMER\\\",\\n                instruction_details={\\n                    \\\"description\\\": f\\\"Extra margin returned to customer from positive remainder\\\"\\n                    f\\\" due to repayable amount for {margin_address} rounded down\\\",\\n                    \\\"event_type\\\": event_type,\\n                },\\n            )\\n        )\\n\\n    return margin_remainder_postings\\n\\n\\ndef _calculate_monthly_payment_margin_and_principal(\\n    vault,\\n    annual_margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Dict[str, Decimal]:\\n    \\\"\\\"\\\" \\\"\\n    Calculate emi, accrued margin, margin due and principal due\\n\\n    :param vault: Vault object\\n    :param annual_margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return Dict[str,Decimal]\\n    \\\"\\\"\\\"\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n\\n    actual_principal = _get_outstanding_actual_principal(vault)\\n\\n    principal = vault.modules[\\\"utils\\\"].get_parameter(vault, name=GOLD_FINANCING_PRINCIPAL)\\n    total_term = vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM)\\n\\n    margin_due = _calculate_monthly_margin(\\n        vault, fulfillment_precision, actual_principal, annual_margin_rate\\n    )\\n\\n    accrued_margin = _get_accrued_margin(vault)\\n\\n    emi = vault.modules[\\\"utils\\\"].round_decimal(\\n        _calculate_monthly_instalment(principal, annual_margin_rate, total_term),\\n        fulfillment_precision,\\n    )\\n    principal_due = emi - margin_due\\n\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, total_term)\\n    if remaining_term <= 1:\\n        principal_due = actual_principal\\n        margin_due = _get_effective_balance_by_address(vault, MARGIN)\\n\\n    return {\\n        \\\"emi\\\": emi,\\n        \\\"margin_due\\\": margin_due,\\n        \\\"accrued_margin\\\": accrued_margin,\\n        \\\"principal_due\\\": principal_due,\\n    }\\n\\n\\ndef _calculate_days_past_due(vault, overdue_address: List[str], effective_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculate the number of days past since the overdue\\n\\n    :param vault: Vault object\\n    :param overdue_address: List[str], list of overdue address pair\\n    :param effective_date: datetime\\n    :return the number of days past since overdue\\n    \\\"\\\"\\\"\\n\\n    installment_number = int(overdue_address[0].split(\\\"_\\\")[-1])\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date = effective_date + timedelta(hours=WIB_UTC_OFFSET)\\n    diff_month = installment_number - 1\\n    installment_overdue_date = first_repayment_date + timedelta(months=diff_month)\\n\\n    dpd = (effective_date - installment_overdue_date).days + 1\\n\\n    return dpd\\n\\n\\n# Posting retrieval helper functions\\ndef _get_posting_amount(posting: PostingInstruction, include_pending_out: bool = True) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction\\n\\n    :param posting: PostingInstruction\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, posting.denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\ndef _get_posting_batch_amount(\\n    posting: PostingInstructionBatch, denomination: str, include_pending_out: bool = False\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Get net posting amount from posting instruction batch\\n\\n    :param posting: PostingInstructionBatch\\n    :param denomination: str\\n    :param include_pending_out: bool\\n    :return Decimal\\n    \\\"\\\"\\\"\\n    posting_amount = posting.balances()[\\n        (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.COMMITTED)\\n    ].net\\n    if include_pending_out:\\n        posting_amount += posting.balances()[\\n            (DEFAULT_ADDRESS, DEFAULT_ASSET, denomination, Phase.PENDING_OUT)\\n        ].net\\n\\n    return Decimal(posting_amount)\\n\\n\\n# Margin helper functions\\ndef _get_daily_margin_accrual(\\n    vault,\\n    outstanding_principal: Decimal,\\n    outstanding_accrue: Decimal,\\n    margin_rate: Decimal,\\n    effective_date: datetime,\\n) -> Tuple[str, Dict[str, str]]:\\n\\n    \\\"\\\"\\\"\\n    Get the amount of daily margin accrual will calculate the\\n    corresponding margin at the effective date\\n\\n    :param outstanding_principal: Decimal\\n    :param outstanding_accrue: Decimal\\n    :param margin_rate: Decimal\\n    :param effective_date: datetime\\n    :return: Tuple[str, Dict[str, str]], representation of\\n    margin to accrue, total days, and next repayment date\\n    \\\"\\\"\\\"\\n    precision = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=ACCRUAL_PRECISION))\\n    term = int(vault.modules[\\\"utils\\\"].get_parameter(vault, name=TOTAL_TERM))\\n    outstanding_margin = _get_effective_balance_by_address(vault, MARGIN, effective_date)\\n    next_payment_date = _calculate_next_repayment_date(vault, effective_date)\\n\\n    monthly_margin = vault.modules[\\\"utils\\\"].round_decimal(\\n        outstanding_principal * margin_rate * Decimal(DAYS_IN_A_MONTH / DAYS_IN_A_YEAR), precision\\n    )\\n    remaining_term = _get_expected_remaining_term(vault, effective_date, term)\\n    total_days = (next_payment_date - effective_date).days + 1\\n\\n    # Adjustment on the last margin accrual at a day before maturity\\n    if outstanding_margin < outstanding_accrue:\\n        return {\\n            \\\"margin_to_accrue\\\": outstanding_margin,\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n    if remaining_term <= 1 and total_days <= 1:\\n        return {\\n            \\\"margin_to_accrue\\\": vault.modules[\\\"utils\\\"].round_decimal(\\n                outstanding_margin - outstanding_accrue, precision\\n            ),\\n            \\\"total_days\\\": total_days,\\n            \\\"next_repayment_date\\\": next_payment_date,\\n        }\\n\\n    margin_accrual = vault.modules[\\\"utils\\\"].round_decimal(\\n        (monthly_margin - outstanding_accrue) / total_days, precision\\n    )\\n\\n    if margin_accrual < 0:\\n        margin_accrual = 0\\n\\n    return {\\n        \\\"margin_to_accrue\\\": margin_accrual,\\n        \\\"total_days\\\": total_days,\\n        \\\"next_repayment_date\\\": next_payment_date,\\n    }\\n\\n\\ndef _get_accrued_margin(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [ACCRUED_MARGIN], timestamp)\\n\\n\\ndef _get_accrue_margin_and_fees_schedule(\\n    vault, gold_financing_start_date: datetime\\n) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get daily margin and fees accrual schedule dict\\n\\n    :param vault: Vault object\\n    :param gold_financing_start_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    gold_financing_start_date_plus_day = gold_financing_start_date + timedelta(days=1)\\n\\n    accrue_margin_schedule = {\\n        \\\"hour\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_HOUR)),\\n        \\\"minute\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_MINUTE)),\\n        \\\"second\\\": str(vault.modules[\\\"utils\\\"].get_parameter(vault, ACCRUE_MARGIN_SECOND)),\\n        \\\"start_date\\\": str(gold_financing_start_date_plus_day),\\n    }\\n\\n    return accrue_margin_schedule\\n\\n\\n# Time calculation and schedule helper functions\\ndef _get_expected_remaining_term(vault, effective_date: datetime, term: int) -> int:\\n    \\\"\\\"\\\"\\n    The remaining term according to the natural end date of the gold financing.\\n\\n    :param vault\\n    :param effective_date : datetime\\n    return: int\\n    \\\"\\\"\\\"\\n    first_repayment_date = _calculate_first_repayment_date(vault)\\n    effective_date += timedelta(hours=WIB_UTC_OFFSET)\\n\\n    if effective_date < first_repayment_date:\\n        remaining_term = timedelta(months=term)\\n    else:\\n        remaining_term = timedelta(first_repayment_date.date(), effective_date.date()) + timedelta(\\n            months=term\\n        )\\n\\n    if effective_date + remaining_term < effective_date + timedelta(months=1):\\n        return 0\\n    else:\\n        # negative days should reduce term by up to 1 month\\n        rounded_month = -1 if remaining_term.days < 0 else 0\\n        return remaining_term.years * 12 + remaining_term.months + rounded_month\\n\\n\\ndef _get_next_schedule_date(\\n    start_date: datetime, schedule_frequency: str, intended_day: int\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Calculate next valid date for schedule based on required frequency and day of month.\\n    Falls to last valid day of month if intended day is not in calculated month\\n    :param start_date: datetime, from which schedule frequency is calculated from\\n    :param bonus_distribution_frequency: str, Defaults to monthly.\\n    :param intended_day: int, day of month the scheduled date should fall on\\n    :return: datetime, next occurrence of schedule\\n    \\\"\\\"\\\"\\n\\n    if start_date + timedelta(day=intended_day) > start_date:\\n        next_schedule_date = start_date + timedelta(day=intended_day)\\n    else:\\n        next_schedule_date = start_date + timedelta(months=1, day=intended_day)\\n    return next_schedule_date\\n\\n\\ndef _create_event_type_schedule_from_dict(schedule_dict: dict[str, str]) -> EventTypeSchedule:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime parameters as function input\\n    :param schedule_dict: the dictionary representing schedule details.  Recognised key-value-pairs:\\n    - year: str, year for schedule to run\\n    - month: str, month for schedule to run\\n    - day: str, day of month for schedule to run\\n    - day_of_week: str, day of week for schedule to run\\n    - hour: str, hour of day for schedule to run\\n    - minute: str, minute of hour for schedule to run\\n    - second: str, second of minute for schedule to run\\n    :return: Corresponding EventTypeSchedule\\n    \\\"\\\"\\\"\\n    return EventTypeSchedule(\\n        year=schedule_dict.get(\\\"year\\\"),\\n        month=schedule_dict.get(\\\"month\\\"),\\n        day=schedule_dict.get(\\\"day\\\"),\\n        day_of_week=schedule_dict.get(\\\"day_of_week\\\"),\\n        hour=schedule_dict.get(\\\"hour\\\"),\\n        minute=schedule_dict.get(\\\"minute\\\"),\\n        second=schedule_dict.get(\\\"second\\\"),\\n    )\\n\\n\\ndef _get_overdue_schedule(vault, effective_date: datetime) -> Tuple[str, Dict[str, str]]:\\n    \\\"\\\"\\\"\\n    Get check overdue schedule dict\\n\\n    :param vault: Vault object\\n    :param effective_date: datetime\\n    :return Tuple[str, Dict[str,str]]\\n    \\\"\\\"\\\"\\n    repayment_period = vault.modules[\\\"utils\\\"].get_parameter(vault, REPAYMENT_PERIOD)\\n    repayment_period_end = effective_date + timedelta(days=int(repayment_period))\\n\\n    overdue_hour = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_HOUR))\\n    overdue_minute = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_MINUTE))\\n    overdue_second = int(vault.modules[\\\"utils\\\"].get_parameter(vault, CHECK_OVERDUE_SECOND))\\n\\n    check_overdue_datetime = repayment_period_end.replace(\\n        hour=overdue_hour,\\n        minute=overdue_minute,\\n        second=overdue_second,\\n    )\\n\\n    return check_overdue_datetime\\n\\n\\n# Balance helper functions\\ndef _get_expected_emi(vault, effective_date: datetime) -> Decimal:\\n    emi = _get_effective_balance_by_address(vault, EMI_ADDRESS)\\n    if emi == 0:\\n        margin_rate = vault.modules[\\\"utils\\\"].get_parameter(vault, name=EQUIVALENT_RATE)\\n        amount_due = _calculate_monthly_payment_margin_and_principal(\\n            vault, margin_rate, effective_date\\n        )\\n        emi = amount_due.get(\\\"emi\\\", Decimal(\\\"0\\\")) if amount_due is not None else Decimal(\\\"0\\\")\\n\\n    return emi\\n\\n\\ndef _get_all_outstanding(vault, timestamp: datetime = None) -> Decimal:\\n    fulfillment_precision = int(\\n        vault.modules[\\\"utils\\\"].get_parameter(vault, name=FULFILLMENT_PRECISION)\\n    )\\n    outstanding_due = _sum_outstanding_dues(vault, timestamp)\\n    return vault.modules[\\\"utils\\\"].round_decimal(\\n        (\\n            vault.modules[\\\"utils\\\"].get_balance_sum(\\n                vault,\\n                [PRINCIPAL, MARGIN],\\n                timestamp,\\n            )\\n            + outstanding_due\\n        ),\\n        fulfillment_precision,\\n    )\\n\\n\\ndef _sum_outstanding_dues(vault, timestamp: datetime = None) -> Decimal:\\n    balances = vault.get_balance_timeseries().latest()\\n    denomination = vault.modules[\\\"utils\\\"].get_parameter(vault, name=DENOMINATION)\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    overdue_address = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n    all_outstanding = overdue_address + FEES_ADDRESSES + DUE_ADDRESSES\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, all_outstanding, timestamp)\\n\\n\\ndef _get_balance_date_for_margin_accrual(vault) -> datetime:\\n    last_repayment_due_date = vault.get_last_execution_time(event_type=REPAYMENT_DAY_SCHEDULE)\\n    # If there hasn't been a repayment event, use balances from gold financing start date\\n    if last_repayment_due_date is None:\\n        last_repayment_due_date = vault.get_account_creation_date()\\n\\n    # Effective date of the transfer postings is 2 microseconds after repayment due event\\n    return last_repayment_due_date + timedelta(microseconds=1)\\n\\n\\ndef _get_effective_balance_by_address(vault, address: str, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [address], timestamp)\\n\\n\\ndef _get_outstanding_actual_principal(vault, timestamp: datetime = None) -> Decimal:\\n    return vault.modules[\\\"utils\\\"].get_balance_sum(vault, [PRINCIPAL], timestamp)\\n\\n\\ndef _get_sorted_repayment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to repayment hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older,\\n    the repayment hierarchy:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n    TAWIDH\\n    TAZIR\\n    DUE_PRINCIPAL\\n    DUE_MARGIN\\n    PRINCIPAL\\n    MARGIN\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    sorted_repayment_addresses = sorted_all_overdue_addresses + REPAYMENT_DUES_ORDER\\n    return sorted_repayment_addresses\\n\\n\\ndef _get_sorted_overdue_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n) -> List[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Returns all existing gold financing addresses, sorted according to overdue hierarchy:\\n\\n    Assuming installment 1 and installment 2 with installment 1 being older, overdue order:\\n    OVERDUE_PRINCIPAL_1\\n    OVERDUE_MARGIN_1\\n    OVERDUE_PRINCIPAL_2\\n    OVERDUE_MARGIN_2\\n\\n    Returns a list of dictionaries which contain the keys 'address' and 'financing_parameters'\\n    to see the structure of the financing_parameters value,\\n    see _get_parameters_from_finance_address().\\n    For penalty addresses financing_parameters value is None\\n    \\\"\\\"\\\"\\n\\n    all_addresses = _get_all_instalment_addresses(\\n        denomination,\\n        balances,\\n        OVERDUE_ADDRESS_TYPES,\\n    )\\n    all_overdue_addresses = all_addresses[PRINCIPAL_OVERDUE] + all_addresses[MARGIN_OVERDUE]\\n\\n    sorted_all_overdue_addresses = _sort_addresses_list(all_overdue_addresses, OVERDUE_ORDER)\\n\\n    return sorted_all_overdue_addresses\\n\\n\\ndef _get_all_instalment_addresses(\\n    denomination,\\n    balances: BalanceDefaultDict,\\n    address_types: List[str],\\n) -> Dict[str, List[str]]:\\n    \\\"\\\"\\\"\\n    Gets all financing addresses for address types listed in address_types.\\n    Valid address types: PRINCIPAL, INTEREST, DUE_PRINCIPAL, DUE_INTEREST, OVERDUE_PRINCIPAL,\\n                         OVERDUE_INTEREST\\n    \\\"\\\"\\\"\\n    addresses = {address_type: [] for address_type in address_types}\\n    for balance_dimension in balances.keys():\\n        address = balance_dimension[0]\\n        if (\\n            address\\n            not in [\\n                DEFAULT_ADDRESS,\\n                ACCRUED_MARGIN,\\n                INTERNAL_CONTRA,\\n            ]\\n            and balances[(address, DEFAULT_ASSET, denomination, Phase.COMMITTED)].net\\n        ):\\n            address_type = address[0 : len(address) - 2]\\n            if address_type in addresses:\\n                addresses[address_type].append(address)\\n    return addresses\\n\\n\\ndef _sort_addresses_list(addresses_list: List[str], repayment_order: Dict[str, int]) -> List[str]:\\n    \\\"\\\"\\\"\\n    Returns a list of sorted addresses, based on provided list and respecting address types in\\n    repayment_order.\\n\\n    Sorts by installment_no, then address type (order defined in repayment_order).\\n    \\\"\\\"\\\"\\n\\n    sorted_addresses_list = sorted(\\n        sorted(\\n            addresses_list,\\n            key=lambda address: repayment_order[\\n                _get_parameters_from_finance_address(address)[\\\"address_type\\\"]\\n            ],\\n        ),\\n        key=lambda address: _get_parameters_from_finance_address(address)[\\\"installment_no\\\"],\\n    )\\n\\n    address_list = [\\n        {\\n            \\\"address\\\": address,\\n            \\\"installment_no\\\": _get_parameters_from_finance_address(address).get(\\\"installment_no\\\"),\\n        }\\n        for address in sorted_addresses_list\\n    ]\\n\\n    address_dict = {}\\n    for data in address_list:\\n        installment_no = data[\\\"installment_no\\\"]\\n        address = [data[\\\"address\\\"]]\\n        if installment_no not in address_dict:\\n            address_dict[installment_no] = address\\n        else:\\n            address_dict[installment_no].append(data[\\\"address\\\"])\\n\\n    return list(address_dict.values())\\n\\n\\ndef _get_parameters_from_finance_address(address: str) -> Dict[str, Union[str, int, Decimal]]:\\n    \\\"\\\"\\\"\\n    Gets all financing parameters from a given financing address.\\n    \\\"\\\"\\\"\\n    if len(address.split(\\\"_\\\")) > 2:\\n        address_type = address[0 : len(address) - 2]\\n        installment_no = address.split(\\\"_\\\")[-1]\\n    else:\\n        address_type = address\\n        installment_no = \\\"0\\\"\\n    return {\\n        \\\"address_type\\\": address_type,\\n        \\\"installment_no\\\": installment_no,\\n    }\\n\\n\\n# Generic helper functions\\ndef _instruct_posting_batch(\\n    vault,\\n    posting_instructions: List[PostingInstruction],\\n    effective_date: datetime,\\n    event_type: str,\\n) -> None:\\n    \\\"\\\"\\\"\\n    Instructs posting batch if posting_instructions variable contains any posting instructions.\\n\\n    :param vault: Vault object\\n    :param posting_instructions: posting instructions\\n    :param effective_date: date and time of hook being run\\n    :param event_type: type of event triggered by the hook\\n    \\\"\\\"\\\"\\n    if posting_instructions:\\n        vault.instruct_posting_batch(\\n            posting_instructions=posting_instructions,\\n            effective_date=effective_date,\\n            client_batch_id=f\\\"{event_type}_{vault.get_hook_execution_id()}\\\",\\n        )\\n\",\n            \"smart_contract_param_vals\": {\n                \"denomination\": \"IDR\",\n                \"repayment_period\": \"1\",\n                \"fulfillment_precision\": \"2\",\n                \"accrual_precision\": \"2\",\n                \"equivalent_rate\": \"0.09\",\n                \"check_overdue_hour\": \"0\",\n                \"check_overdue_minute\": \"1\",\n                \"check_overdue_second\": \"1\",\n                \"accrue_margin_second\": \"0\",\n                \"accrue_margin_hour\": \"0\",\n                \"accrue_margin_minute\": \"1\",\n                \"disbursement_account\": \"DISBURSEMENT_ACCOUNT\",\n                \"settlement_account\": \"SETTLEMENT_ACCOUNT\",\n                \"repayment_hour\": \"0\",\n                \"repayment_minute\": \"1\",\n                \"repayment_second\": \"1\",\n                \"margin_income_account\": \"MARGIN_INCOME_ACCOUNT\",\n                \"tawidh_fee\": \"2000\",\n                \"tawidh_fee_income_account\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"early_maturity_margin\": \"0.02\",\n                \"muqasah_payable_account\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"tazir_fee_income_account\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"tazir_period\": \"10\",\n                \"maximum_dpd\": \"90\"\n            },\n            \"smart_contract_version_id\": \"0\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6078362083436979997\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"4551035457670895031\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"6133825318558391846\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"1633781451463198332\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"2530202305488478218\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=LIABILITY.\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Liability Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.LIABILITY\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8825793221396202728\"\n        },\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nTo be called by simulation tests\\nSimulates an instance of a bank's internal account with tside=ASSET\\n\\\"\\\"\\\"\\n\\ndisplay_name = \\\"Testing Internal Asset Account\\\"\\napi = \\\"3.0.0\\\"\\nversion = \\\"1.0.0\\\"\\ntside = Tside.ASSET\\n\",\n            \"smart_contract_param_vals\": {},\n            \"smart_contract_version_id\": \"8681798408874163722\"\n        }\n    ],\n    \"supervisor_contracts\": [],\n    \"contract_modules\": [\n        {\n            \"code\": \"# Copyright @ 2021 Thought Machine Group Limited. All rights reserved.\\n\\\"\\\"\\\"\\nUtils module\\n\\\"\\\"\\\"\\n\\n\\napi = \\\"3.9.0\\\"\\ndisplay_name = \\\"Utils module\\\"\\ndescription = \\\"A series of common functions that are frequently used by multiple smart contracts\\\"\\n\\n# yearly_to_daily_rate\\nVALID_DAYS_IN_YEAR = [\\\"360\\\", \\\"365\\\", \\\"366\\\", \\\"actual\\\"]\\nDEFAULT_DAYS_IN_YEAR = \\\"actual\\\"\\n\\n# misc\\nROUNDING_TYPES = Union[\\n    ROUND_CEILING,\\n    ROUND_DOWN,\\n    ROUND_FLOOR,\\n    ROUND_HALF_DOWN,\\n    ROUND_HALF_EVEN,\\n    ROUND_HALF_UP,\\n    ROUND_05UP,\\n]\\n\\n\\ndef get_parameter(\\n    vault,\\n    name: str,\\n    at: datetime = None,\\n    is_json: bool = False,\\n    is_boolean: bool = False,\\n    union: bool = False,\\n    optional: bool = False,\\n    upper_case_dict_values: bool = False,\\n    upper_case_list_values: bool = False,\\n) -> Any:\\n    \\\"\\\"\\\"\\n    Get the parameter value for a given parameter\\n    :param vault:\\n    :param name: name of the parameter to retrieve\\n    :param at: datetime, time at which to retrieve the parameter value. If not\\n    specified the latest value is retrieved\\n    :param is_json: if true json_loads is called on the retrieved parameter value\\n    :param is_boolean: if true str_to_bool is called on the retrieved parameter value\\n    :param union: if True parameter will be treated as a UnionItem\\n    :param optional: if true we treat the parameter as optional\\n    :param upper_case_dict_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:Dict[str,str]], we will convert the Dict[str,str] values to\\n    upper case\\n    :param upper_case_list_values: if is_json is True and we are expecting the\\n    parameter to take shape Dict[str:List[str]], we will convert the List[str] values to upper case\\n    then we will return the dict values in upper case, whether these values are str/list/dict\\n    :return:\\n    \\\"\\\"\\\"\\n    if at:\\n        parameter = vault.get_parameter_timeseries(name=name).at(timestamp=at)\\n    else:\\n        parameter = vault.get_parameter_timeseries(name=name).latest()\\n\\n    if optional:\\n        parameter = parameter.value if parameter.is_set() else None\\n\\n    if union and parameter is not None:\\n        parameter = parameter.key\\n\\n    if is_boolean and parameter is not None:\\n        return str_to_bool(parameter)\\n\\n    if is_json and parameter is not None:\\n        try:\\n            parameter = json_loads(parameter)\\n        except:  # noqa: E722, B001\\n            raise InvalidContractParameter(\\n                f\\\"Exception while JSON loading parameter {name}\\\\nValue {parameter}\\\"\\n            )\\n\\n        # We convert dictionary values to upper case based on the date type shape.\\n        # The converted values often represent transaction references, which we always\\n        # want to parse in upper case.\\n        # The dictionary keys often represent transaction types, which we want to\\n        # keep in the original case.\\n        if upper_case_dict_values:\\n            parameter = {\\n                key: {str(i).upper(): str(j).upper() for i, j in value.items()}\\n                for key, value in parameter.items()\\n            }\\n        elif upper_case_list_values:\\n            parameter = {key: [str(i).upper() for i in value] for key, value in parameter.items()}\\n\\n    return parameter\\n\\n\\ndef str_to_bool(string: str) -> bool:\\n    \\\"\\\"\\\"\\n    Convert a string true to bool True, default value of False.\\n    :param string:\\n    :return:\\n    \\\"\\\"\\\"\\n    return str(string).lower() == \\\"true\\\"\\n\\n\\ndef yearly_to_daily_rate(yearly_rate: Decimal, year: int, days_in_year: str = \\\"actual\\\") -> Decimal:\\n    \\\"\\\"\\\"\\n    Convert yearly rate to daily rate.\\n    \\\"\\\"\\\"\\n    days_in_year = days_in_year if days_in_year in VALID_DAYS_IN_YEAR else DEFAULT_DAYS_IN_YEAR\\n    if days_in_year == \\\"actual\\\":\\n        days_in_year = Decimal(\\\"366\\\") if is_leap_year(year) else Decimal(\\\"365\\\")\\n    else:\\n        days_in_year = Decimal(days_in_year)\\n\\n    return yearly_rate / days_in_year\\n\\n\\ndef is_leap_year(year: int) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if given year is a leap year (i.e. has 366 days in the year)\\n    \\\"\\\"\\\"\\n    if year % 400 == 0:\\n        return True\\n    elif year % 100 == 0:\\n        return False\\n    elif year % 4 == 0:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef round_decimal(\\n    amount: Decimal,\\n    decimal_places: int,\\n    rounding: ROUNDING_TYPES = ROUND_HALF_UP,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Round an amount to specified number of decimal places\\n    :param amount: Decimal, amount to round\\n    :param decimal_places: int, number of places to round to\\n    :param rounding: the type of rounding strategy to use\\n    :return: Decimal, rounded amount\\n    \\\"\\\"\\\"\\n    return amount.quantize(Decimal((0, (1,), -decimal_places)), rounding=rounding)\\n\\n\\ndef rounded_days_between(start_date: datetime, end_date: datetime) -> int:\\n    \\\"\\\"\\\"\\n    Calculates the rounded up number of days between two dates, positive or negative.\\n\\n    :param start_date: datetime, date from which to start counting days\\n    :param end_date: datetime, date until which to count\\n    :return: int, number of days\\n    \\\"\\\"\\\"\\n    # timedelta is actually dateutil.relativedelta, apply to arbitrary date to get real timedelta\\n    delta = timedelta(end_date, start_date) + start_date - start_date\\n    one_day = timedelta(days=1) + start_date - start_date\\n    days = delta.total_seconds() / one_day.total_seconds()\\n    rounding = \\\"ROUND_CEILING\\\" if days > 0 else \\\"ROUND_FLOOR\\\"\\n    return int(Decimal(days).quantize(Decimal(\\\"1\\\"), rounding=rounding))\\n\\n\\ndef is_flag_in_list_applied(\\n    vault, parameter_name: str, application_timestamp: datetime = None\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determine if a flag is set and active for a customer from a given list of flag names\\n    :param vault:\\n    :param parameter_name: str, name of the parameter to retrieve\\n    :param application_timestamp: datetime, optional time at which to check if any flags\\n    were applied. If not specified latest is used.\\n    :return: bool, True if any of the flags in the parameterised list are applied at the\\n    timestamp\\n    \\\"\\\"\\\"\\n    list_of_flag_names = get_parameter(vault, name=parameter_name, is_json=True)\\n\\n    return any(\\n        vault.get_flag_timeseries(flag=flag_name).at(timestamp=application_timestamp)\\n        if application_timestamp\\n        else vault.get_flag_timeseries(flag=flag_name).latest()\\n        for flag_name in list_of_flag_names\\n    )\\n\\n\\ndef create_schedule_dict_from_datetime(schedule_datetime: datetime) -> Dict[str, str]:\\n    \\\"\\\"\\\"\\n    Creates a dict representing a schedule from datetime as function input\\n    \\\"\\\"\\\"\\n    return {\\n        \\\"year\\\": str(schedule_datetime.year),\\n        \\\"month\\\": str(schedule_datetime.month),\\n        \\\"day\\\": str(schedule_datetime.day),\\n        \\\"hour\\\": str(schedule_datetime.hour),\\n        \\\"minute\\\": str(schedule_datetime.minute),\\n        \\\"second\\\": str(schedule_datetime.second),\\n    }\\n\\n\\ndef has_parameter_value_changed(\\n    parameter_name: str,\\n    old_parameters: Dict[str, str],\\n    updated_parameters: Dict[str, str],\\n) -> bool:\\n    \\\"\\\"\\\"\\n    Determines if a parameter has changed. To be used within post-parameter change hook.\\n\\n    :param parameter_name: str, name of the parameter\\n    :param old_parameters: dict, map of parameter name -> old parameter value\\n    :param updated_parameters: dict, map of parameter name -> new parameter value\\n    :return: bool, True if parameter value has changed, False otherwise\\n    \\\"\\\"\\\"\\n\\n    return (\\n        parameter_name in updated_parameters\\n        and old_parameters[parameter_name] != updated_parameters[parameter_name]\\n    )\\n\\n\\ndef are_optional_parameters_set(vault, parameters: List[str]) -> bool:\\n    \\\"\\\"\\\"\\n    Determines whether the list of optional parameter names are set\\n\\n    :param vault:\\n    :param parameters: List of vault parameter names\\n\\n    :return: bool, True if all parameters are set, False otherwise\\n    \\\"\\\"\\\"\\n    return all(\\n        get_parameter(vault, parameter, optional=True) is not None for parameter in parameters\\n    )\\n\\n\\ndef get_balance_sum(\\n    vault,\\n    addresses: List[str],\\n    timestamp: datetime = None,\\n    denomination: str = None,\\n    phase: Phase = Phase.COMMITTED,\\n    balances: BalanceDefaultDict = None,\\n) -> Decimal:\\n    \\\"\\\"\\\"\\n    Sum balances for list of given addresses.\\n    :param vault: balances, parameters\\n    :param addresses: list of addresses\\n    :param timestamp: optional datetime at which balances to be summed\\n    :param denomination: the denomination of the balance\\n    :param phase: phase of the balance\\n    :return: sum of the balances\\n    \\\"\\\"\\\"\\n    balances = balances or (\\n        vault.get_balance_timeseries().latest()\\n        if timestamp is None\\n        else vault.get_balance_timeseries().at(timestamp=timestamp)\\n    )\\n\\n    if denomination is None:\\n        denomination = get_parameter(vault, \\\"denomination\\\")\\n\\n    return Decimal(\\n        sum(balances[(address, DEFAULT_ASSET, denomination, phase)].net for address in addresses)\\n    )\\n\\n\\ndef get_transaction_type(\\n    instruction_details: Dict[str, str],\\n    txn_code_to_type_map: Dict[str, str],\\n    default_txn_type: str,\\n) -> str:\\n    \\\"\\\"\\\"\\n    Gets the transaction type from Posting instruction metadata.\\n    :param instruction_details: mapping containing instruction-level metadata for the Posting\\n    :param txn_code_to_type_map: map of transaction code to transaction type\\n    :param default_txn_type: transaction type to default to if code not found in the map\\n    :return: the transaction type of the Posting instruction\\n    \\\"\\\"\\\"\\n    txn_code = instruction_details.get(\\\"transaction_code\\\")\\n    return txn_code_to_type_map.get(txn_code, default_txn_type)\\n\\n\\ndef get_previous_schedule_execution_date(\\n    vault, event_type: str, account_start_date: datetime = None\\n) -> datetime:\\n    \\\"\\\"\\\"\\n    Gets the last execution time of an event (if it exists) else returns the start date\\n    of the account\\n    :param event_type: a string of the schedule event type\\n    :param account_start_date: the start date of the account\\n    :return: the last execution time of a schedule else the account start date\\n    \\\"\\\"\\\"\\n\\n    last_schedule_event_date = vault.get_last_execution_time(event_type=event_type)\\n    return last_schedule_event_date if last_schedule_event_date is not None else account_start_date\\n\",\n            \"contract_module_version_id\": \"3a7b6dae-cdbb-4d7d-8427-9e5d8dcf1cf2\"\n        }\n    ],\n    \"instructions\": [\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SUSPENSE_ACCOUNT\",\n                \"product_version_id\": \"6078362083436979997\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"DISBURSEMENT_ACCOUNT\",\n                \"product_version_id\": \"4551035457670895031\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"SETTLEMENT_ACCOUNT\",\n                \"product_version_id\": \"6133825318558391846\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MARGIN_INCOME_ACCOUNT\",\n                \"product_version_id\": \"1633781451463198332\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAWIDH_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"2530202305488478218\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"MUQASAH_PAYABLE_ACCOUNT\",\n                \"product_version_id\": \"8825793221396202728\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"TAZIR_FEE_INCOME_ACCOUNT\",\n                \"product_version_id\": \"8681798408874163722\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {},\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_smart_contract_module_versions_link\": {\n                \"id\": \"sim_link_modules_utils_with_contract_0\",\n                \"smart_contract_version_id\": \"0\",\n                \"alias_to_contract_module_version_id\": {\n                    \"utils\": \"3a7b6dae-cdbb-4d7d-8427-9e5d8dcf1cf2\"\n                }\n            }\n        },\n        {\n            \"timestamp\": \"2022-01-01T00:00:00+00:00\",\n            \"create_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"product_version_id\": \"0\",\n                \"permitted_denominations\": [],\n                \"status\": \"ACCOUNT_STATUS_UNKNOWN\",\n                \"stakeholder_ids\": [],\n                \"instance_param_vals\": {\n                    \"principal\": \"8000000\",\n                    \"total_term\": \"12\",\n                    \"gold_financing_start_date\": \"2022-01-01\"\n                },\n                \"derived_instance_param_vals\": {},\n                \"details\": {}\n            }\n        },\n        {\n            \"timestamp\": \"2022-05-09T00:02:00+00:00\",\n            \"update_account\": {\n                \"id\": \"GOLD_FINANCING_ACCOUNT\",\n                \"status\": \"ACCOUNT_STATUS_PENDING_CLOSURE\"\n            }\n        }\n    ],\n    \"outputs\": []\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/contracts:simulate",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"contracts:simulate"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "E2E",
			"item": [
				{
					"name": "Customer setup",
					"item": [
						{
							"name": "Create customer",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"var jsonData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable(\"customer_id\", jsonData.id);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "X-Auth-Token",
										"value": "{{access_token}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"customer\": {\n    \"status\": \"CUSTOMER_STATUS_ACTIVE\",\n    \"identifiers\": [],\n    \"customer_details\": null,\n    \"additional_details\": {}\n  },\n  \"request_id\": \"{{$guid}}\"\n}"
								},
								"url": {
									"raw": "{{core_api_base}}/v1/customers",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"customers"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Account creation",
					"item": [
						{
							"name": "Create Live Gold Financing Account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"var jsonData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable(\"gold_financing_account_id\", jsonData.id);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Auth-Token",
										"type": "text",
										"value": "{{access_token}}"
									},
									{
										"key": "Content-Type",
										"name": "Content-Type",
										"type": "text",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n          \"request_id\": \"{{$guid}}\",\n          \"account\": {\n            \"product_id\": \"gold_financing\",\n            \"stakeholder_ids\": [\n              \"{{customer_id}}\"\n            ],\n            \"instance_param_vals\": {\n                \"principal\": \"20000000\",\n                \"total_term\": \"24\",\n                \"gold_financing_start_date\": \"2022-12-05\"\n            },\n            \"details\": {},\n            \"status\": \"ACCOUNT_STATUS_OPEN\"\n          }\n        }\n   "
								},
								"url": {
									"raw": "{{core_api_base}}/v1/accounts",
									"host": [
										"{{core_api_base}}"
									],
									"path": [
										"v1",
										"accounts"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Update instance parameter",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Auth-Token",
								"value": "{{access_token}}",
								"type": "text"
							},
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"request_id\": \"{{$timestamp}}\",\n    \"account_update\": {\n        \"account_id\": \"a97c9aa1-2a60-042f-b8c8-ba56eb8f0e5f\",\n        \"instance_param_vals_update\": {\n            \"instance_param_vals\": {\n                \"bonus_distribution\": \"no\"\n            }\n        }\n    }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{core_api_base}}/v1/account-updates",
							"host": [
								"{{core_api_base}}"
							],
							"path": [
								"v1",
								"account-updates"
							]
						}
					},
					"response": []
				}
			]
		}
	]
}