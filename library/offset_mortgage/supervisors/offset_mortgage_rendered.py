# Code auto-generated using Inception Smart Contract Renderer Version 2.0.1


# Objects below have been imported from:
#    offset_mortgage.py
# md5:e857d232d6784f3460380df409394010

from contracts_api import (
    DEFAULT_ADDRESS,
    DEFAULT_ASSET,
    AuthorisationAdjustment,
    Balance,
    BalanceCoordinate,
    BalanceDefaultDict,
    BalanceTimeseries,
    CalendarEvents,
    CustomInstruction,
    EndOfMonthSchedule,
    FlagTimeseries,
    InboundAuthorisation,
    InboundHardSettlement,
    OptionalValue,
    OutboundAuthorisation,
    OutboundHardSettlement,
    Phase,
    Posting,
    PostingInstructionType,
    Rejection,
    RejectionReason,
    Release,
    ScheduledEvent,
    ScheduleExpression,
    ScheduleFailover,
    ScheduleSkip,
    Settlement,
    Transfer,
    Tside,
    UnionItemValue,
    UpdateAccountEventTypeDirective,
    AccountNotificationDirective,
    PostingInstructionsDirective,
    PostPostingHookResult,
    ScheduledEventHookResult,
    SupervisorContractEventType,
    SupervisorScheduledEventHookArguments,
    UpdatePlanEventTypeDirective,
    BalancesObservationFetcher,
    DefinedDateTime,
    Override,
    PostingsIntervalFetcher,
    RelativeDateTime,
    Shift,
    AccountIdShape,
    NumberShape,
    Parameter,
    ParameterLevel,
    SmartContractEventType,
    UnionItem,
    UnionShape,
    ScheduledEventHookArguments,
    ParameterUpdatePermission,
    OptionalShape,
    StringShape,
    BalancesFilter,
    BalancesObservation,
    SmartContractDescriptor,
    SupervisorActivationHookArguments,
    SupervisorActivationHookResult,
    SupervisorScheduledEventHookResult,
    requires,
)
from calendar import isleap
from datetime import datetime
from dateutil.relativedelta import relativedelta
from decimal import Decimal, ROUND_HALF_UP
from json import loads
from typing import Optional, Callable, Union, Any, Iterable, Mapping, NamedTuple
from zoneinfo import ZoneInfo

api = "4.0.0"
version = "2.0.2"
supervised_smart_contracts = [
    SmartContractDescriptor(
        alias="mortgage", smart_contract_version_id="&{mortgage}", supervise_post_posting_hook=False
    ),
    SmartContractDescriptor(
        alias="savings_account",
        smart_contract_version_id="&{savings_account}",
        supervise_post_posting_hook=False,
    ),
    SmartContractDescriptor(
        alias="current_account",
        smart_contract_version_id="&{current_account}",
        supervise_post_posting_hook=False,
    ),
]


def activation_hook(
    vault: Any, hook_arguments: SupervisorActivationHookArguments
) -> Optional[SupervisorActivationHookResult]:
    scheduled_events: dict[str, ScheduledEvent] = {}
    plan_opening_datetime = vault.get_plan_opening_datetime()
    scheduled_events[ACCRUE_OFFSET_INTEREST_EVENT] = ScheduledEvent(
        start_datetime=plan_opening_datetime,
        expression=ScheduleExpression(hour=0, minute=0, second=1),
    )
    return SupervisorActivationHookResult(scheduled_events_return_value=scheduled_events)


@requires(
    event_type="ACCRUE_OFFSET_INTEREST",
    balances="latest",
    data_scope="all",
    parameters=True,
    supervisee_hook_directives="all",
)
def scheduled_event_hook(
    vault: Any, hook_arguments: SupervisorScheduledEventHookArguments
) -> Optional[SupervisorScheduledEventHookResult]:
    """
    Executes the logic of the schedules only accrual of offset interest is supported.
    :param vault: the supervisor vault object
    :param hook_arguments: the scheduled event's hook arguments
    :return: SupervisorScheduledEventHookResult containing the generated offset postings and
    preserves the other directives generated by the supervisees.
    """
    event_type = hook_arguments.event_type
    if event_type == ACCRUE_OFFSET_INTEREST_EVENT:
        (notifications, postings, update_event_types) = _handle_accrue_offset_interest(
            vault=vault, hook_arguments=hook_arguments
        )
        if notifications or postings or update_event_types:
            return SupervisorScheduledEventHookResult(
                supervisee_account_notification_directives=notifications,
                supervisee_posting_instructions_directives=postings,
                supervisee_update_account_event_type_directives=update_event_types,
            )
    return None


# Objects below have been imported from:
#    addresses.py
# md5:860f50af37f2fe98540f540fa6394eb7

addresses_INTERNAL_CONTRA = "INTERNAL_CONTRA"

# Objects below have been imported from:
#    utils.py
# md5:b4718e1c735d11f6848158f777e7084f

utils_VALID_DAYS_IN_YEAR = ["360", "365", "366", "actual"]
utils_DEFAULT_DAYS_IN_YEAR = "actual"
utils_RATE_DECIMAL_PLACES = 10


def utils_str_to_bool(string: str) -> bool:
    """
    Convert a string true to bool True, default value of False.
    :param string:
    :return:
    """
    return str(string).lower() == "true"


def utils_round_decimal(
    amount: Decimal, decimal_places: int, rounding: str = ROUND_HALF_UP
) -> Decimal:
    """
    Round an amount to specified number of decimal places
    :param amount: Decimal, amount to round
    :param decimal_places: int, number of places to round to
    :param rounding: the type of rounding strategy to use
    :return: Decimal, rounded amount
    """
    return amount.quantize(Decimal((0, (1,), -int(decimal_places))), rounding=rounding)


def utils_yearly_to_daily_rate(
    effective_date: datetime, yearly_rate: Decimal, days_in_year: str = "actual"
) -> Decimal:
    """
    Calculate the daily rate from a yearly rate, for a given `days_in_year` convention and date
    :param effective_date: the date as of which the conversion happens. This may affect the outcome
    based on the `days_in_year` value.
    :param yearly_rate: the rate to convert
    :param days_in_year: the number of days in the year to assume for the calculation. One of `360`,
    `365`, `366` or `actual`. If actual is used, the number of days is based on effective_date's
    year
    :return: the corresponding daily rate
    """
    days_in_year = (
        days_in_year if days_in_year in utils_VALID_DAYS_IN_YEAR else utils_DEFAULT_DAYS_IN_YEAR
    )
    if days_in_year == "actual":
        num_days_in_year = Decimal("366") if isleap(effective_date.year) else Decimal("365")
    else:
        num_days_in_year = Decimal(days_in_year)
    return utils_round_decimal(
        yearly_rate / num_days_in_year, decimal_places=utils_RATE_DECIMAL_PLACES
    )


def utils_yearly_to_monthly_rate(yearly_rate: Decimal) -> Decimal:
    return utils_round_decimal(yearly_rate / 12, decimal_places=utils_RATE_DECIMAL_PLACES)


def utils_get_parameter(
    vault: Any,
    name: str,
    at_datetime: Optional[datetime] = None,
    is_json: bool = False,
    is_boolean: bool = False,
    is_union: bool = False,
    is_optional: bool = False,
    default_value: Optional[Any] = None,
) -> Any:
    """
    Get the parameter value for a given parameter
    :param vault:
    :param name: name of the parameter to retrieve
    :param at_datetime: datetime, time at which to retrieve the parameter value. If not
    specified the latest value is retrieved
    :param is_json: if true json_loads is called on the retrieved parameter value
    :param is_boolean: boolean parameters are treated as union parameters before calling
    str_to_bool on the retrieved parameter value
    :param is_union: if True parameter will be treated as a UnionItem
    :param is_optional: if true we treat the parameter as optional
    :param default_value: only used in conjunction with the is_optional arg, the value to use if the
    parameter is not set.
    :return: the parameter value, this is type hinted as Any because the parameter could be
    json loaded, therefore it value can be any json serialisable type and we gain little benefit
    from having an extensive Union list
    """
    if at_datetime:
        parameter = vault.get_parameter_timeseries(name=name).at(at_datetime=at_datetime)
    else:
        parameter = vault.get_parameter_timeseries(name=name).latest()
    if is_optional:
        parameter = parameter.value if parameter.is_set() else default_value
    if is_union and parameter is not None:
        parameter = parameter.key
    if is_boolean and parameter is not None:
        parameter = utils_str_to_bool(parameter.key)
    if is_json and parameter is not None:
        parameter = loads(parameter)
    return parameter


def utils_create_postings(
    amount: Decimal,
    debit_account: str,
    credit_account: str,
    debit_address: str = DEFAULT_ADDRESS,
    credit_address: str = DEFAULT_ADDRESS,
    denomination: str = "GBP",
    asset: str = DEFAULT_ASSET,
) -> list[Posting]:
    """
    Creates a pair of postings to debit the debit_address on debit_account
    and credit the credit_address on credit_account by the specified amount

    :param amount: The amount to pay. If the amount is <= 0, an empty list is returned
    :param debit_account: The account from which to debit the amount
    :param credit_account: The account to which to credit the amount
    :param debit_address: The address from which to move the amount
    :param credit_address: The address to which to move the amount
    :param denomination: The denomination of the postings
    :param asset: The asset of the postings
    :return: The credit-debit pair of postings
    """
    if amount <= Decimal("0"):
        return []
    return [
        Posting(
            credit=True,
            amount=amount,
            denomination=denomination,
            account_id=credit_account,
            account_address=credit_address,
            asset=asset,
            phase=Phase.COMMITTED,
        ),
        Posting(
            credit=False,
            amount=amount,
            denomination=denomination,
            account_id=debit_account,
            account_address=debit_address,
            asset=asset,
            phase=Phase.COMMITTED,
        ),
    ]


def utils_standard_instruction_details(
    description: str, event_type: str, gl_impacted: bool = False, account_type: str = ""
) -> dict[str, str]:
    """
    Generates standard posting instruction details
    :param description: a description of the instruction, usually for human consumption
    :param event_type: event type name that resulted in the instruction the eg "ACCRUE_INTEREST"
    :param gl_impacted: indicates if this posting instruction has GL implications
    :param account_type: the account type for GL purposes (e.g. to identify postings pertaining to
    current accounts vs savings accounts)
    :return: the instruction details
    """
    return {
        "description": description,
        "event": event_type,
        "gl_impacted": str(gl_impacted),
        "account_type": account_type,
    }


def utils_sum_balances(
    *,
    balances: BalanceDefaultDict,
    addresses: list[str],
    denomination: str,
    asset: str = DEFAULT_ASSET,
    phase: Phase = Phase.COMMITTED,
    decimal_places: Optional[int] = None,
) -> Decimal:
    balance_sum = Decimal(
        sum(
            (
                balances[BalanceCoordinate(address, asset, denomination, phase)].net
                for address in addresses
            )
        )
    )
    return (
        balance_sum
        if decimal_places is None
        else utils_round_decimal(amount=balance_sum, decimal_places=decimal_places)
    )


def utils_balance_at_coordinates(
    *,
    balances: BalanceDefaultDict,
    address: str = DEFAULT_ADDRESS,
    denomination: str,
    asset: str = DEFAULT_ASSET,
    phase: Phase = Phase.COMMITTED,
    decimal_places: Optional[int] = None,
) -> Decimal:
    balance_net = balances[BalanceCoordinate(address, asset, denomination, phase)].net
    return (
        balance_net
        if decimal_places is None
        else utils_round_decimal(amount=balance_net, decimal_places=decimal_places)
    )


def utils_get_balance_default_dict_from_mapping(
    mapping: Mapping[BalanceCoordinate, BalanceTimeseries],
    effective_datetime: Optional[datetime] = None,
) -> BalanceDefaultDict:
    """
    Converts the balances mapping fetched from `vault.get_balances_timeseries()` into a
    BalanceDefaultDict, taking either the latest or at_datetime entry of the timeseries

    :param mapping: map of balance coordinates to balance timeseries
    :param effective_datetime: if provided, the timeseries value at that timestamp will be used,
    otherwise the latest value will be used
    :return: BalanceDefaultDict from the timeseries mapping
    """
    balance_mapping: dict[BalanceCoordinate, Balance] = {
        coord: ts.at(at_datetime=effective_datetime) if effective_datetime else ts.latest()
        for (coord, ts) in mapping.items()
    }
    return BalanceDefaultDict(mapping=balance_mapping)


# Objects below have been imported from:
#    supervisor_utils.py
# md5:badd574e398fc715274627e947d1a001


def supervisor_utils_get_supervisees_for_alias(vault: Any, alias: str) -> list[Any]:
    """
    Returns a list of supervisee vault objects for the given alias, ordered by account creation date
    TODO: (INC-8671) reintroduce num_requested logic from v3

    :param vault: supervisor vault object
    :param alias: the supervisee alias to filter for
    :return: supervisee vault objects for given alias, ordered by account creation date

    """
    return supervisor_utils_sort_supervisees(
        [supervisee for supervisee in vault.supervisees.values() if supervisee.get_alias() == alias]
    )


def supervisor_utils_sort_supervisees(supervisees: list[Any]) -> list[Any]:
    """
    Sorts supervisees first by creation date, and then alphabetically by id if
    numerous supervisees share the same creation date and creates a list of ordered
    vault objects.

    :param supervisees: list of supervisee vault objects
    :return sorted_supervisees: list of ordered vault objects
    """
    sorted_supervisees_by_id = sorted(supervisees, key=lambda vault: vault.account_id)
    sorted_supervisees_by_age_then_id = sorted(
        sorted_supervisees_by_id, key=lambda vault: vault.get_account_creation_datetime()
    )
    return sorted_supervisees_by_age_then_id


def supervisor_utils_get_supervisee_directives_mapping(
    vault: Any,
) -> tuple[
    dict[str, list[AccountNotificationDirective]],
    dict[str, list[PostingInstructionsDirective]],
    dict[str, list[UpdateAccountEventTypeDirective]],
]:
    """
    Return the mapping from supervisee account id to list of AccountNotificationDirective,
    PostingInstructionsDirectives and UpdateAccountEventTypeDirective to be returned
    in the supervisor ScheduledEventHookResult and PostPostingHookResult

    :param vault: supervisee vault account
    :return: dictionary mapping of a tuple of vault account id to their respective directive.
    """
    supervisee_hook_results: Union[
        PostPostingHookResult, ScheduledEventHookResult
    ] = vault.get_hook_result()
    supervisee_notification_directives = supervisee_hook_results.account_notification_directives
    supervisee_notification_directives_dict = (
        {vault.account_id: supervisee_notification_directives}
        if supervisee_notification_directives
        else {}
    )
    supervisee_posting_directives = supervisee_hook_results.posting_instructions_directives
    supervisee_posting_directives_dict = (
        {vault.account_id: supervisee_posting_directives} if supervisee_posting_directives else {}
    )
    supervisee_update_account_event_type_directives = (
        supervisee_hook_results.update_account_event_type_directives
    )
    supervisee_update_account_event_type_directives_dict = (
        {vault.account_id: supervisee_update_account_event_type_directives}
        if supervisee_update_account_event_type_directives
        else {}
    )
    return (
        supervisee_notification_directives_dict,
        supervisee_posting_directives_dict,
        supervisee_update_account_event_type_directives_dict,
    )


# Objects below have been imported from:
#    fetchers.py
# md5:dcba39f23bd6808d7c243d6f0f8ff8d0

fetchers_EOD_FETCHER_ID = "EOD_FETCHER"
fetchers_EFFECTIVE_OBSERVATION_FETCHER_ID = "EFFECTIVE_FETCHER"

# Objects below have been imported from:
#    accruals.py
# md5:becbe7f07a49ad9560c9d05985a2e3ab

accruals_AccrualDetail = NamedTuple("AccrualDetail", [("amount", Decimal), ("description", str)])


def accruals_accrual_custom_instruction(
    customer_account: str,
    customer_address: str,
    denomination: str,
    amount: Decimal,
    internal_account: str,
    payable: bool,
    instruction_details: Optional[dict[str, str]] = None,
    reversal: bool = False,
) -> list[CustomInstruction]:
    """
    Create a Custom Instruction containing customer and internal account postings for accruing a
    charge.
    :param customer_account: the customer account id to use
    :param customer_address: the address to use on the customer account
    :param denomination: the denomination of the accrual
    :param amount: the accrual amount. If this is amount is <= 0 an empty list is returned
    :param internal_account: the internal account id to use. The default address is always
    used on this account
    :param payable: set to True if accruing a payable charge, or False for a receivable charge
    :param instruction_details: instruction details to add to the postings
    Useful if more than one accrual affects a given balance (e.g. un-netted tiered interest)
    :param reversal: set to True if reversing the accrual, or False otherwise
    :return: Custom instructions to accrue interest, if required
    """
    if amount <= 0:
        return []
    postings = accruals_accrual_postings(
        customer_account=customer_account,
        denomination=denomination,
        amount=amount,
        internal_account=internal_account,
        customer_address=customer_address,
        payable=payable,
        reversal=reversal,
    )
    if postings:
        return [
            CustomInstruction(
                postings=postings,
                instruction_details=instruction_details,
                override_all_restrictions=True,
            )
        ]
    else:
        return []


def accruals_accrual_postings(
    customer_account: str,
    customer_address: str,
    denomination: str,
    amount: Decimal,
    internal_account: str,
    payable: bool,
    reversal: bool = False,
) -> list[Posting]:
    """
    Create customer and internal account postings for accruing a charge.
    :param customer_account: the customer account id to use
    :param customer_address: the address to use on the customer account
    :param denomination: the denomination of the accrual
    :param amount: the accrual amount. If this is amount is <= 0 an empty list is returned.
    :param internal_account: the internal account id to use. The default address is always
    used on this account
    :param payable: set to True if accruing a payable charge, or False for a receivable charge
    :param reversal: set to True if reversing the accrual, or False otherwise
    :return: the accrual postings
    """
    if amount <= 0:
        return []
    if payable and reversal or (not payable and (not reversal)):
        debit_account = customer_account
        debit_address = customer_address
        credit_account = internal_account
        credit_address = DEFAULT_ADDRESS
    else:
        debit_account = internal_account
        debit_address = DEFAULT_ADDRESS
        credit_account = customer_account
        credit_address = customer_address
    return [
        Posting(
            credit=True,
            amount=amount,
            denomination=denomination,
            account_id=credit_account,
            account_address=credit_address,
            asset=DEFAULT_ASSET,
            phase=Phase.COMMITTED,
        ),
        Posting(
            credit=False,
            amount=amount,
            denomination=denomination,
            account_id=debit_account,
            account_address=debit_address,
            asset=DEFAULT_ASSET,
            phase=Phase.COMMITTED,
        ),
    ]


# Objects below have been imported from:
#    interest_accrual_common.py
# md5:162f41e06e859ca63b416be0f14ea285

interest_accrual_common_ACCRUAL_EVENT = "ACCRUE_INTEREST"
interest_accrual_common_ACCRUED_INTEREST_RECEIVABLE = "ACCRUED_INTEREST_RECEIVABLE"
interest_accrual_common_PARAM_DAYS_IN_YEAR = "days_in_year"
interest_accrual_common_PARAM_ACCRUAL_PRECISION = "accrual_precision"


def interest_accrual_common_daily_accrual(
    customer_account: str,
    customer_address: str,
    denomination: str,
    internal_account: str,
    payable: bool,
    effective_balance: Decimal,
    effective_datetime: datetime,
    yearly_rate: Decimal,
    days_in_year: str,
    precision: int,
    rounding: str,
    account_type: str,
    event_type: str = interest_accrual_common_ACCRUAL_EVENT,
) -> list[CustomInstruction]:
    """
    Calculates daily accrual amount and returns a CustomInstruction with the relevant customer and
    internal account postings. Note: if an income/expense account is used for the internal account
    and the customer address is set accordingly, this function can be used to apply a charge on a
    cash basis
    :param customer_account: the customer account id to use
    :param customer_address: the address to use on the customer account
    :param denomination: the denomination of the accrual
    :param internal_account: the internal account id to use. The default address is always
    used on this account
    :param payable: set to True if accruing a payable charge, or False for a receivable charge
    :param effective_balance: the balance to accrue on
    :param effective_datetime: the datetime to accrue as of. This may impact the actual rate
    depending on the `days_in_year` value
    :param yearly_rate: the yearly rate to use, which will be converted to a daily rate
    :param days_in_year: the number of days in the year to assume for the calculation. One of `360`,
    `365`, `366` or `actual`. If actual is used, the number of days is based on effective_date's
    year.
    :param precision: the number of decimal places to round to
    :param rounding: the type of rounding to use, as per decimal's supported options
    :param account_type: the account type for GL purposes (e.g. to identify postings pertaining to
    current accounts vs savings accounts)
    :param event_type: event type name that resulted in the instruction the eg "ACCRUE_INTEREST"
    :return: Custom instructions to accrue interest, if required
    """
    accrual_detail = interest_accrual_common_calculate_daily_accrual(
        effective_balance=effective_balance,
        effective_datetime=effective_datetime,
        yearly_rate=yearly_rate,
        days_in_year=days_in_year,
        rounding=rounding,
        precision=precision,
    )
    if accrual_detail is None:
        return []
    return accruals_accrual_custom_instruction(
        customer_account=customer_account,
        customer_address=customer_address,
        denomination=denomination,
        amount=accrual_detail.amount,
        internal_account=internal_account,
        payable=payable,
        instruction_details=utils_standard_instruction_details(
            description=accrual_detail.description,
            event_type=event_type,
            gl_impacted=True,
            account_type=account_type,
        ),
    )


def interest_accrual_common_calculate_daily_accrual(
    effective_balance: Decimal,
    effective_datetime: datetime,
    yearly_rate: Decimal,
    days_in_year: str,
    rounding: str = ROUND_HALF_UP,
    precision: int = 5,
) -> Optional[accruals_AccrualDetail]:
    """
    Calculate the amount to accrue on a daily basis
    :param effective_balance: the balance to accrue on
    :param effective_datetime: accruals are calculated as of this datetime, which may impact the
    actual rate depending on the `days_in_year` value
    :param yearly_rate: the yearly rate to use, which will be converted to a daily rate
    :param days_in_year: the number of days in the year to assume for the calculation. One of `360`,
    `365`, `366` or `actual`. If actual is used, the number of days is based on effective_date's
    year.
    :param rounding: the type of rounding to use, as per decimal's supported options
    :param precision: the number of decimal places to round to
    :return: the daily accrual details, which may be None if no accruals are needed
    """
    if effective_balance == Decimal("0"):
        return None
    daily_rate = utils_yearly_to_daily_rate(
        days_in_year=days_in_year, yearly_rate=yearly_rate, effective_date=effective_datetime
    )
    accrual_amount = utils_round_decimal(
        amount=effective_balance * daily_rate, decimal_places=precision, rounding=rounding
    )
    if accrual_amount == 0:
        return None
    return accruals_AccrualDetail(
        amount=accrual_amount,
        description=f"Daily interest accrued at {daily_rate * 100:0.5f}% on balance of {effective_balance:0.2f}",
    )


# Objects below have been imported from:
#    lending_addresses.py
# md5:d546448643732336308da8f52c0901d4

lending_addresses_ACCRUED_INTEREST_RECEIVABLE = "ACCRUED_INTEREST_RECEIVABLE"
lending_addresses_DUE_CALCULATION_EVENT_COUNTER = "DUE_CALCULATION_EVENT_COUNTER"
lending_addresses_INTERNAL_CONTRA = addresses_INTERNAL_CONTRA
lending_addresses_PRINCIPAL = "PRINCIPAL"

# Objects below have been imported from:
#    lending_interfaces.py
# md5:a0df1ba0adcd14fa7f99308269ad58a7

lending_interfaces_InterestRate = NamedTuple(
    "InterestRate",
    [
        ("get_daily_interest_rate", Callable[..., Decimal]),
        ("get_monthly_interest_rate", Callable[..., Decimal]),
        ("get_annual_interest_rate", Callable[..., Decimal]),
    ],
)

# Objects below have been imported from:
#    interest_accrual.py
# md5:07236706e076b2c0568b51146520a313

interest_accrual_ACCRUED_INTEREST_RECEIVABLE = interest_accrual_common_ACCRUED_INTEREST_RECEIVABLE
interest_accrual_PARAM_DAYS_IN_YEAR = interest_accrual_common_PARAM_DAYS_IN_YEAR
interest_accrual_PARAM_ACCRUED_INTEREST_RECEIVABLE_ACCOUNT = "accrued_interest_receivable_account"


def interest_accrual_daily_accrual_logic(
    vault: Union[Any, Any],
    hook_arguments: Union[ScheduledEventHookArguments, SupervisorScheduledEventHookArguments],
    interest_rate_feature: lending_interfaces_InterestRate,
    account_type: str,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
    principal_addresses: Optional[list[str]] = None,
    inflight_postings: Optional[list[CustomInstruction]] = None,
    customer_accrual_address: Optional[str] = None,
    accrual_internal_account: Optional[str] = None,
) -> list[CustomInstruction]:
    """
    Accrue receivable interest on the sum of EOD balances held at the principal addresses.
    :param vault: Vault object for the account accruing interest
    :param hook_args: scheduled event hook arguments
    :param interest_rate_feature: interest rate feature to get the yearly interest rate
    :param account_type: the account type for GL purposes (e.g. to identify postings pertaining to
    current accounts vs savings accounts)
    :param balances: the eod balances to use for accrual. If None, EOD_FETCHER_ID is used to
    fetch the balances.
    :param denomination: the denomination to use for accrual. If None, the latest value of the
    `denomination` parameter is used.
    :param principal_addresses: the addresses of balances to accrue on. Defaults to `PRINCIPAL`
    :param inflight_postings: Any inflight postings that are to be merged with the EOD balances,
    common use case is when interest is capitalised at the end of a repayment holiday and so the
    accrual effective balance needs to be adjusted
    :param customer_accrual_address: the address to accrue to. If None, accrual address is
    ACCRUED_INTEREST_RECEIVABLE otherwise
    :return: The custom instructions to accrue interest, if required
    """
    midnight = hook_arguments.effective_datetime - relativedelta(hour=0, minute=0, second=0)
    principal_addresses = principal_addresses or [lending_addresses_PRINCIPAL]
    if denomination is None:
        denomination = utils_get_parameter(vault=vault, name="denomination")
    if balances is None:
        balances = vault.get_balances_observation(fetcher_id=fetchers_EOD_FETCHER_ID).balances
    if inflight_postings:
        for custom_instruction in inflight_postings:
            balances += custom_instruction.balances(account_id=vault.account_id, tside=Tside.ASSET)
    effective_balance = Decimal(
        sum(
            (
                utils_balance_at_coordinates(
                    balances=balances, address=principal_address, denomination=denomination
                )
                for principal_address in principal_addresses
            )
        )
    )
    if customer_accrual_address is None:
        customer_accrual_address = interest_accrual_ACCRUED_INTEREST_RECEIVABLE
    if accrual_internal_account is None:
        accrual_internal_account = utils_get_parameter(
            vault=vault, name=interest_accrual_PARAM_ACCRUED_INTEREST_RECEIVABLE_ACCOUNT
        )
    return interest_accrual_common_daily_accrual(
        customer_account=vault.account_id,
        customer_address=customer_accrual_address,
        denomination=denomination,
        internal_account=accrual_internal_account,
        days_in_year=utils_get_parameter(
            vault=vault, name=interest_accrual_PARAM_DAYS_IN_YEAR, is_union=True
        ),
        yearly_rate=interest_rate_feature.get_annual_interest_rate(
            vault=vault,
            effective_datetime=hook_arguments.effective_datetime,
            balances=balances,
            denomination=denomination,
        ),
        effective_balance=effective_balance,
        account_type=account_type,
        event_type=hook_arguments.event_type,
        effective_datetime=midnight,
        payable=False,
        precision=utils_get_parameter(
            vault=vault, name=interest_accrual_common_PARAM_ACCRUAL_PRECISION
        ),
        rounding=ROUND_HALF_UP,
    )


# Objects below have been imported from:
#    fixed.py
# md5:f2f9eef46e1a533911ac0476c6df2d10


def fixed_get_annual_interest_rate(
    vault: Any,
    effective_datetime: Optional[datetime] = None,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    return Decimal(
        utils_get_parameter(vault, "fixed_interest_rate", at_datetime=effective_datetime)
    )


def fixed_get_daily_interest_rate(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    annual_rate = fixed_get_annual_interest_rate(vault=vault)
    days_in_year = utils_get_parameter(vault, "days_in_year", is_union=True)
    return utils_yearly_to_daily_rate(effective_datetime, annual_rate, days_in_year)


def fixed_get_monthly_interest_rate(
    vault: Any,
    effective_datetime: Optional[datetime] = None,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    annual_rate = fixed_get_annual_interest_rate(vault=vault, effective_datetime=effective_datetime)
    return utils_yearly_to_monthly_rate(annual_rate)


# Objects below have been imported from:
#    variable.py
# md5:8bdd1a99e6d1305e392203f5e65c2065

variable_PARAM_ANNUAL_INTEREST_RATE_CAP = "annual_interest_rate_cap"
variable_PARAM_ANNUAL_INTEREST_RATE_FLOOR = "annual_interest_rate_floor"
variable_PARAM_VARIABLE_RATE_ADJUSTMENT = "variable_rate_adjustment"
variable_PARAM_VARIABLE_INTEREST_RATE = "variable_interest_rate"


def variable_get_daily_interest_rate(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    annual_rate = variable_get_annual_interest_rate(
        vault=vault, effective_datetime=effective_datetime
    )
    days_in_year = utils_get_parameter(
        vault, "days_in_year", is_union=True, at_datetime=effective_datetime
    )
    return utils_yearly_to_daily_rate(effective_datetime, annual_rate, days_in_year)


def variable_get_monthly_interest_rate(
    vault: Any,
    effective_datetime: Optional[datetime] = None,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    annual_rate = variable_get_annual_interest_rate(
        vault=vault, effective_datetime=effective_datetime
    )
    return utils_yearly_to_monthly_rate(annual_rate)


def variable_get_annual_interest_rate(
    vault: Any,
    effective_datetime: Optional[datetime] = None,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    """
    Determines the annual interest rate, including any variable rate adjustment and
    accounts for any maximum or minimum interest rate limits that may be set.
    """
    annual_rate = Decimal(
        utils_get_parameter(
            vault=vault, name=variable_PARAM_VARIABLE_INTEREST_RATE, at_datetime=effective_datetime
        )
    ) + Decimal(
        utils_get_parameter(
            vault=vault,
            name=variable_PARAM_VARIABLE_RATE_ADJUSTMENT,
            at_datetime=effective_datetime,
        )
    )
    interest_rate_cap: Decimal = utils_get_parameter(
        vault=vault,
        name=variable_PARAM_ANNUAL_INTEREST_RATE_CAP,
        is_optional=True,
        default_value=Decimal("inf"),
        at_datetime=effective_datetime,
    )
    interest_rate_floor: Decimal = utils_get_parameter(
        vault=vault,
        name=variable_PARAM_ANNUAL_INTEREST_RATE_FLOOR,
        is_optional=True,
        default_value=Decimal("-inf"),
        at_datetime=effective_datetime,
    )
    return max(min(annual_rate, interest_rate_cap), interest_rate_floor)


# Objects below have been imported from:
#    term_helpers.py
# md5:daf4d2c8e08d1b80a139d4905726ffff


def term_helpers_calculate_elapsed_term(balances: BalanceDefaultDict, denomination: str) -> int:
    return int(
        utils_balance_at_coordinates(
            balances=balances,
            address=lending_addresses_DUE_CALCULATION_EVENT_COUNTER,
            denomination=denomination,
        )
    )


# Objects below have been imported from:
#    fixed_to_variable.py
# md5:fccd6dae2d8a9d9fc1483b1b267d8570


def fixed_to_variable_is_within_fixed_rate_term(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> bool:
    fixed_rate_term = int(utils_get_parameter(vault, "fixed_interest_term"))
    if fixed_rate_term == 0:
        return False
    if effective_datetime == vault.get_account_creation_datetime():
        elapsed_term = 0
    else:
        if balances is None:
            balances = vault.get_balances_observation(
                fetcher_id=fetchers_EFFECTIVE_OBSERVATION_FETCHER_ID
            ).balances
        if denomination is None:
            denomination = utils_get_parameter(vault=vault, name="denomination")
        elapsed_term = term_helpers_calculate_elapsed_term(
            balances=balances, denomination=denomination
        )
    return elapsed_term < fixed_rate_term


def fixed_to_variable_get_daily_interest_rate(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    is_fixed_interest = fixed_to_variable_is_within_fixed_rate_term(
        vault=vault,
        effective_datetime=effective_datetime,
        balances=balances,
        denomination=denomination,
    )
    if is_fixed_interest:
        return fixed_get_daily_interest_rate(vault=vault, effective_datetime=effective_datetime)
    else:
        return variable_get_daily_interest_rate(vault=vault, effective_datetime=effective_datetime)


def fixed_to_variable_get_monthly_interest_rate(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    is_fixed_interest = fixed_to_variable_is_within_fixed_rate_term(
        vault=vault,
        effective_datetime=effective_datetime,
        balances=balances,
        denomination=denomination,
    )
    if is_fixed_interest:
        return fixed_get_monthly_interest_rate(vault=vault, effective_datetime=effective_datetime)
    else:
        return variable_get_monthly_interest_rate(
            vault=vault, effective_datetime=effective_datetime
        )


def fixed_to_variable_get_annual_interest_rate(
    vault: Any,
    effective_datetime: datetime,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> Decimal:
    is_fixed_interest = fixed_to_variable_is_within_fixed_rate_term(
        vault=vault,
        effective_datetime=effective_datetime,
        balances=balances,
        denomination=denomination,
    )
    if is_fixed_interest:
        return fixed_get_annual_interest_rate(vault=vault, effective_datetime=effective_datetime)
    else:
        return variable_get_annual_interest_rate(vault=vault, effective_datetime=effective_datetime)


fixed_to_variable_InterestRate = lending_interfaces_InterestRate(
    get_daily_interest_rate=fixed_to_variable_get_daily_interest_rate,
    get_monthly_interest_rate=fixed_to_variable_get_monthly_interest_rate,
    get_annual_interest_rate=fixed_to_variable_get_annual_interest_rate,
)

# Objects below have been imported from:
#    overpayment.py
# md5:a8cb4d2f6f955706d1b72f5c93822334

overpayment_ACCRUED_EXPECTED_INTEREST = "ACCRUED_EXPECTED_INTEREST"
overpayment_EMI_PRINCIPAL_EXCESS = "EMI_PRINCIPAL_EXCESS"
overpayment_OVERPAYMENT = "OVERPAYMENT"
overpayment_EXPECTED_PRINCIPAL = [
    lending_addresses_PRINCIPAL,
    overpayment_OVERPAYMENT,
    overpayment_EMI_PRINCIPAL_EXCESS,
]
overpayment_EXPECTED_INTEREST_ACCRUAL_EOD_FETCHER_ID = "EXPECTED_INTEREST_ACCRUAL_EOD_FETCHER"


def overpayment_track_interest_on_expected_principal(
    vault: Any,
    hook_arguments: Union[ScheduledEventHookArguments, SupervisorScheduledEventHookArguments],
    interest_rate_feature: lending_interfaces_InterestRate,
    balances: Optional[BalanceDefaultDict] = None,
    denomination: Optional[str] = None,
) -> list[CustomInstruction]:
    """Creates posting instructions to track interest on expected principal, which excludes the
    impact of overpayments. This function is intended for use as part of daily interest accrual.

    Expected interest helps determine the additional principal indirectly paid off after an
    overpayment due to subsequent accruals having a reduced principal, which in turn increases the
    portion of principal in the corresponding emi payments. This in turn avoids reamortisation for
    non-overpayment reasons (e.g. variable rate change) from accidentally including the impact of
    overpayments that are meant to reduce the term.
    :param vault: vault object for the account
    :param hook_arguments: hook arguments for the interest accrual event
    :param interest_rate_feature: feature used to determine the interest rate as of the
    hook_arguments' effective_datetime
    :param balances: Optional balances. Defaults to latest EOD balances before the hook_arguments'
    effective_datetime
    :param denomination: denomination to track in. Defaults to the `denomination` parameter
    :return: postings to track expected interest. Empty list if not required (e.g. 0 principal or 0
    interest rate)
    """
    if balances is None:
        balances = vault.get_balances_observation(
            fetcher_id=overpayment_EXPECTED_INTEREST_ACCRUAL_EOD_FETCHER_ID
        ).balances
    if denomination is None:
        denomination = str(utils_get_parameter(vault=vault, name="denomination"))
    precision = int(
        utils_get_parameter(vault=vault, name=interest_accrual_common_PARAM_ACCRUAL_PRECISION)
    )
    days_in_year: str = utils_get_parameter(
        vault=vault, name=interest_accrual_common_PARAM_DAYS_IN_YEAR, is_union=True
    )
    expected_principal = utils_sum_balances(
        balances=balances, denomination=denomination, addresses=overpayment_EXPECTED_PRINCIPAL
    )
    yearly_rate = interest_rate_feature.get_annual_interest_rate(
        vault, hook_arguments.effective_datetime, balances=balances, denomination=denomination
    )
    accrual = interest_accrual_common_calculate_daily_accrual(
        effective_balance=expected_principal,
        effective_datetime=hook_arguments.effective_datetime,
        yearly_rate=yearly_rate,
        days_in_year=days_in_year,
        precision=precision,
    )
    if accrual and accrual.amount > 0:
        return [
            CustomInstruction(
                postings=utils_create_postings(
                    amount=accrual.amount,
                    debit_account=vault.account_id,
                    debit_address=overpayment_ACCRUED_EXPECTED_INTEREST,
                    credit_account=vault.account_id,
                    credit_address=lending_addresses_INTERNAL_CONTRA,
                    denomination=denomination,
                ),
                instruction_details={
                    "description": f"Tracking expected interest at yearly rate {yearly_rate} on expected principal {expected_principal}"
                },
                override_all_restrictions=True,
            )
        ]
    return []


# Objects below have been imported from:
#    offset_mortgage.py
# md5:e857d232d6784f3460380df409394010

ACCOUNT_TYPE = "OFFSET_MORTGAGE"
MORTGAGE_ALIAS = "mortgage"
SAVINGS_ACCOUNT_ALIAS = "savings_account"
CURRENT_ACCOUNT_ALIAS = "current_account"
ACCRUE_OFFSET_INTEREST_EVENT = "ACCRUE_OFFSET_INTEREST"
event_types = [
    SupervisorContractEventType(
        name=ACCRUE_OFFSET_INTEREST_EVENT,
        overrides_event_types=[
            (MORTGAGE_ALIAS, "ACCRUE_INTEREST"),
            (SAVINGS_ACCOUNT_ALIAS, "ACCRUE_INTEREST"),
            (CURRENT_ACCOUNT_ALIAS, "ACCRUE_INTEREST"),
        ],
        scheduler_tag_ids=["OFFSET_MORTGAGE_ACCRUE_OFFSET_INTEREST_AST"],
    )
]
PARAM_DENOMINATION = "denomination"
PRINCIPAL = "PRINCIPAL"


def _handle_accrue_offset_interest(
    vault: Any, hook_arguments: SupervisorScheduledEventHookArguments
) -> tuple[
    dict[str, list[AccountNotificationDirective]],
    dict[str, list[PostingInstructionsDirective]],
    dict[str, list[UpdateAccountEventTypeDirective]],
]:
    supervisee_notification_directives: dict[str, list[AccountNotificationDirective]] = {}
    supervisee_posting_directives: dict[str, list[PostingInstructionsDirective]] = {}
    supervisee_update_account_event_type_directives: dict[
        str, list[UpdateAccountEventTypeDirective]
    ] = {}
    mortgage_accounts = supervisor_utils_get_supervisees_for_alias(
        vault=vault, alias=MORTGAGE_ALIAS
    )
    savings_accounts = supervisor_utils_get_supervisees_for_alias(
        vault=vault, alias=SAVINGS_ACCOUNT_ALIAS
    )
    current_accounts = supervisor_utils_get_supervisees_for_alias(
        vault=vault, alias=CURRENT_ACCOUNT_ALIAS
    )
    all_casa_accounts = savings_accounts + current_accounts
    if not mortgage_accounts and (not all_casa_accounts):
        return ({}, {}, {})
    if mortgage_accounts and (not all_casa_accounts):
        mortgage_account = mortgage_accounts[0]
        directives = supervisor_utils_get_supervisee_directives_mapping(vault=mortgage_account)
        return (directives[0], directives[1], directives[2])
    elif all_casa_accounts and (not mortgage_accounts):
        for casa_account in all_casa_accounts:
            directives = supervisor_utils_get_supervisee_directives_mapping(vault=casa_account)
            supervisee_notification_directives.update(directives[0])
            supervisee_posting_directives.update(directives[1])
            supervisee_update_account_event_type_directives.update(directives[2])
        return (
            supervisee_notification_directives,
            supervisee_posting_directives,
            supervisee_update_account_event_type_directives,
        )
    mortgage_account = mortgage_accounts[0]
    mortgage_denomination = _get_denomination_parameter(vault=mortgage_account)
    (eligible_accounts, ineligible_accounts) = _split_supervisees_by_eligibility(
        casa_accounts=all_casa_accounts, mortgage_denomination=mortgage_denomination
    )
    for account in ineligible_accounts:
        directives = supervisor_utils_get_supervisee_directives_mapping(vault=account)
        supervisee_notification_directives.update(directives[0])
        supervisee_posting_directives.update(directives[1])
        supervisee_update_account_event_type_directives.update(directives[2])
    if not eligible_accounts:
        directives = supervisor_utils_get_supervisee_directives_mapping(vault=mortgage_account)
        supervisee_notification_directives.update(directives[0])
        supervisee_posting_directives.update(directives[1])
        supervisee_update_account_event_type_directives.update(directives[2])
        return (
            supervisee_notification_directives,
            supervisee_posting_directives,
            supervisee_update_account_event_type_directives,
        )
    mortgage_posting_directives = mortgage_account.get_hook_result().posting_instructions_directives
    if not mortgage_posting_directives:
        for account in eligible_accounts:
            directives = supervisor_utils_get_supervisee_directives_mapping(vault=account)
            supervisee_notification_directives.update(directives[0])
            supervisee_posting_directives.update(directives[1])
            supervisee_update_account_event_type_directives.update(directives[2])
        return (
            supervisee_notification_directives,
            supervisee_posting_directives,
            supervisee_update_account_event_type_directives,
        )
    supervisee_posting_directives.update(
        _generate_offset_accrual_posting_directives_mapping(
            mortgage_account=mortgage_account,
            mortgage_posting_directives=mortgage_posting_directives,
            eligible_accounts=eligible_accounts,
            mortgage_denomination=mortgage_denomination,
            hook_arguments=hook_arguments,
        )
    )
    return (
        supervisee_notification_directives,
        supervisee_posting_directives,
        supervisee_update_account_event_type_directives,
    )


def _generate_offset_accrual_posting_directives_mapping(
    mortgage_account: Any,
    mortgage_posting_directives: list[PostingInstructionsDirective],
    eligible_accounts: list[Any],
    mortgage_denomination: str,
    hook_arguments: SupervisorScheduledEventHookArguments,
) -> dict[str, list[PostingInstructionsDirective]]:
    """
    Generate the offset accrual PostingInstructionsDirective mapping for the mortgage account
    when all the eligibility criteria have been met.
    All non-standard interest accrual instructions are preserved

    :param mortgage_account: vault object for the mortgage account
    :param mortgage_posting_directives: non-empty list of PostingInstructionsDirectives returned
    from the mortgage accrual schedule result
    :param eligible_accounts: list of eligible CA/SA account vault objects
    :param mortgage_denomination: denomination of the mortgage account
    :param effective_datetime: effective datetime of the hook
    :return: PostingInstructionsDirective mapping containing instructions for offset accrual
    """
    posting_instructions: list[CustomInstruction] = [
        instruction
        for directive in mortgage_posting_directives
        for instruction in directive.posting_instructions
    ]
    (
        offset_eligible_instructions,
        instructions_to_preserve,
    ) = _split_instructions_into_offset_eligible_and_preserved(
        posting_instructions=posting_instructions,
        mortgage_account_id=mortgage_account.account_id,
        mortgage_denomination=mortgage_denomination,
    )
    if not offset_eligible_instructions:
        return {
            mortgage_account.account_id: [
                PostingInstructionsDirective(
                    posting_instructions=instructions_to_preserve,
                    value_datetime=hook_arguments.effective_datetime,
                )
            ]
        }
    offset_accrual_instructions = _get_offset_accrual_instructions(
        mortgage_account=mortgage_account,
        eligible_accounts=eligible_accounts,
        mortgage_denomination=mortgage_denomination,
        hook_arguments=hook_arguments,
    )
    return {
        mortgage_account.account_id: [
            PostingInstructionsDirective(
                posting_instructions=[*instructions_to_preserve, *offset_accrual_instructions],
                value_datetime=hook_arguments.effective_datetime,
            )
        ]
    }


def _get_offset_accrual_instructions(
    mortgage_account: Any,
    eligible_accounts: list[Any],
    mortgage_denomination: str,
    hook_arguments: SupervisorScheduledEventHookArguments,
) -> list[CustomInstruction]:
    mortgage_balances = utils_get_balance_default_dict_from_mapping(
        mapping=mortgage_account.get_balances_timeseries()
    )
    total_casa_effective_balance = Decimal(
        sum(
            (
                utils_balance_at_coordinates(
                    balances=utils_get_balance_default_dict_from_mapping(
                        mapping=account.get_balances_timeseries()
                    ),
                    denomination=mortgage_denomination,
                )
                for account in eligible_accounts
            )
        )
    )
    principal_coordinate = BalanceCoordinate(
        account_address=lending_addresses_PRINCIPAL,
        asset=DEFAULT_ASSET,
        denomination=mortgage_denomination,
        phase=Phase.COMMITTED,
    )
    mortgage_balances[principal_coordinate] += Balance(
        credit=total_casa_effective_balance, debit=Decimal(0), net=-total_casa_effective_balance
    )
    instructions = interest_accrual_daily_accrual_logic(
        vault=mortgage_account,
        hook_arguments=hook_arguments,
        interest_rate_feature=fixed_to_variable_InterestRate,
        account_type=ACCOUNT_TYPE,
        balances=mortgage_balances,
        denomination=mortgage_denomination,
    )
    instructions += overpayment_track_interest_on_expected_principal(
        vault=mortgage_account,
        hook_arguments=hook_arguments,
        balances=mortgage_balances,
        denomination=mortgage_denomination,
        interest_rate_feature=fixed_to_variable_InterestRate,
    )
    for instruction in instructions:
        instruction.instruction_details[
            "description"
        ] += f" offset by balance {mortgage_denomination} {total_casa_effective_balance}"
    return instructions


def _split_instructions_into_offset_eligible_and_preserved(
    posting_instructions: list[CustomInstruction],
    mortgage_account_id: str,
    mortgage_denomination: str,
) -> tuple[list[CustomInstruction], list[CustomInstruction]]:
    """
    Only CustomInstructions that affect the ACCRUED_INTEREST_RECEIVABLE address
    are eligible for offsetting, and all other instructions should be preserved.

    :param posting_instructions: list of CustomInstructions provided in the
    mortgage account
    :param mortgage_account_id: account id for the mortgage
    :param mortgage_denomination: denomination for the mortgage
    :return: list of offset eligible instructions, list of instructions to preserve
    """
    offset_eligible_instructions: list[CustomInstruction] = []
    instructions_to_preserve: list[CustomInstruction] = []
    accrued_interest_receivable_coordinate = BalanceCoordinate(
        account_address=lending_addresses_ACCRUED_INTEREST_RECEIVABLE,
        asset=DEFAULT_ASSET,
        denomination=mortgage_denomination,
        phase=Phase.COMMITTED,
    )
    accrued_interest_expected_coordinate = BalanceCoordinate(
        account_address=overpayment_ACCRUED_EXPECTED_INTEREST,
        asset=DEFAULT_ASSET,
        denomination=mortgage_denomination,
        phase=Phase.COMMITTED,
    )
    for custom_instruction in posting_instructions:
        balances = custom_instruction.balances(account_id=mortgage_account_id)
        if balances[accrued_interest_receivable_coordinate].net + balances[
            accrued_interest_expected_coordinate
        ].net == Decimal("0"):
            instructions_to_preserve.append(custom_instruction)
        else:
            offset_eligible_instructions.append(custom_instruction)
    return (offset_eligible_instructions, instructions_to_preserve)


def _split_supervisees_by_eligibility(
    casa_accounts: list[Any], mortgage_denomination: str
) -> tuple[list[Any], list[Any]]:
    """
    Eligible accounts have same denomination parameter value as mortgage and have a positive balance
    Constructs two lists of vault objects, one with eligible accounts
    and one with ineligible accounts.

    :param casa_accounts: List of CA/SA vault objects
    :param mortgage_denomination: Denomination of the mortgage account
    :return: list of eligible accounts, list of ineligible accounts
    """
    eligible_accounts: list[SuperviseeContractVault] = []
    ineligible_accounts: list[SuperviseeContractVault] = []
    for account in casa_accounts:
        account_denomination = _get_denomination_parameter(vault=account)
        if account_denomination == mortgage_denomination and utils_balance_at_coordinates(
            balances=utils_get_balance_default_dict_from_mapping(
                mapping=account.get_balances_timeseries()
            ),
            denomination=mortgage_denomination,
        ) > Decimal("0"):
            eligible_accounts.append(account)
        else:
            ineligible_accounts.append(account)
    return (eligible_accounts, ineligible_accounts)


def _get_denomination_parameter(vault: Any) -> str:
    denomination: str = utils_get_parameter(vault=vault, name=PARAM_DENOMINATION)
    return denomination
